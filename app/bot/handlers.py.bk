"""
Callback handlers for TelegramMail Bot.
"""
import logging
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply, InputMediaPhoto
from telegram.ext import ContextTypes
import html  # 导入html模块以使用escape函数
import traceback
from typing import Dict, Any, List, Optional, Tuple, Union
import json
from datetime import datetime, timedelta
import asyncio  # 导入asyncio模块用于异步延迟
import ssl
import re
import os

from app.database.operations import (
    get_user_settings, update_user_settings,
    link_account_to_chat_id, get_all_active_accounts, 
    get_email_by_id, mark_email_as_read, delete_email, 
    AccountOperations, get_email_account_by_id, 
    MessageOperations, get_attachment_telegram_ids, add_reply_to_email
)
from app.email.imap_client import IMAPClient
from app.email.smtp_client import SMTPClient
from app.utils.config import config
from app.email.operations import EmailOperations

# 配置日志
logger = logging.getLogger(__name__)

async def handle_settings_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    处理设置菜单的回调查询
    """
    query = update.callback_query
    await query.answer()
    
    callback_data = query.data
    
    if callback_data == "settings_notifications":
        await handle_notification_settings(update, context)
    elif callback_data == "settings_accounts":
        await handle_account_settings(update, context)
    elif callback_data == "settings_display":
        await handle_display_settings(update, context)
    elif callback_data == "settings_privacy":
        await handle_privacy_settings(update, context)
    elif callback_data.startswith("back_to_settings"):
        await back_to_settings_menu(update, context)
    elif callback_data.startswith("delete_account_"):
        # 处理删除账户请求
        account_id = int(callback_data.split("_")[-1])
        await handle_delete_account(update, context, account_id)
    elif callback_data.startswith("confirm_delete_account_"):
        # 处理确认删除账户
        account_id = int(callback_data.split("_")[-1])
        await handle_confirm_delete_account(update, context, account_id)
    elif callback_data == "cancel_delete_account":
        # 处理取消删除账户
        await handle_cancel_delete_account(update, context)
    else:
        logger.warning(f"未知设置回调数据: {callback_data}")
        await query.edit_message_text(
            "抱歉，发生了未知错误。请使用 /settings 重新打开设置菜单。"
        )

async def handle_notification_settings(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """处理通知设置"""
    query = update.callback_query
    
    # 这里应该从数据库获取用户当前的通知设置
    # 为了演示，我们假设默认值
    receive_all_emails = True
    receive_important_only = False
    silent_mode = False
    
    keyboard = [
        [
            InlineKeyboardButton(
                f"{'✅' if receive_all_emails else '❌'} 接收所有邮件", 
                callback_data="toggle_all_emails"
            ),
        ],
        [
            InlineKeyboardButton(
                f"{'✅' if receive_important_only else '❌'} 仅重要邮件", 
                callback_data="toggle_important_emails"
            ),
        ],
        [
            InlineKeyboardButton(
                f"{'✅' if silent_mode else '❌'} 静音模式", 
                callback_data="toggle_silent_mode"
            ),
        ],
        [
            InlineKeyboardButton("« 返回", callback_data="back_to_settings"),
        ],
    ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text(
        "🔔 <b>通知设置</b>\n\n"
        "配置您希望如何接收邮件通知。",
        reply_markup=reply_markup,
        parse_mode="HTML"
    )

async def handle_account_settings(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """处理账户设置"""
    query = update.callback_query
    
    # 这里应该从数据库获取用户的邮件账户
    # 为了演示，我们假设有一些账户
    accounts = [
        {"name": "工作邮箱", "email": "work@example.com", "active": True},
        {"name": "个人邮箱", "email": "personal@example.com", "active": False},
    ]
    
    keyboard = []
    for account in accounts:
        status = "✅ 已启用" if account["active"] else "❌ 已禁用"
        keyboard.append([
            InlineKeyboardButton(
                f"{account['name']} ({status})",
                callback_data=f"account_{account['email']}"
            )
        ])
    
    keyboard.append([InlineKeyboardButton("+ 添加新账户", callback_data="add_account")])
    keyboard.append([InlineKeyboardButton("« 返回", callback_data="back_to_settings")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text(
        "📧 <b>账户管理</b>\n\n"
        "管理您的邮件账户。",
        reply_markup=reply_markup,
        parse_mode="HTML"
    )

async def handle_display_settings(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """处理显示设置"""
    query = update.callback_query
    
    # 这里应该从数据库获取用户的显示设置
    # 为了演示，我们假设默认值
    show_previews = True
    compact_mode = False
    render_html = True
    
    keyboard = [
        [
            InlineKeyboardButton(
                f"{'✅' if show_previews else '❌'} 显示邮件预览", 
                callback_data="toggle_previews"
            ),
        ],
        [
            InlineKeyboardButton(
                f"{'✅' if compact_mode else '❌'} 紧凑模式", 
                callback_data="toggle_compact_mode"
            ),
        ],
        [
            InlineKeyboardButton(
                f"{'✅' if render_html else '❌'} 渲染HTML", 
                callback_data="toggle_render_html"
            ),
        ],
        [
            InlineKeyboardButton("« 返回", callback_data="back_to_settings"),
        ],
    ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text(
        "🖥️ <b>显示设置</b>\n\n"
        "配置邮件如何显示。",
        reply_markup=reply_markup,
        parse_mode="HTML"
    )

async def handle_privacy_settings(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """处理隐私设置"""
    query = update.callback_query
    
    # 这里应该从数据库获取用户的隐私设置
    # 为了演示，我们假设默认值
    cache_emails = True
    auto_delete = False
    
    keyboard = [
        [
            InlineKeyboardButton(
                f"{'✅' if cache_emails else '❌'} 缓存邮件内容", 
                callback_data="toggle_cache"
            ),
        ],
        [
            InlineKeyboardButton(
                f"{'✅' if auto_delete else '❌'} 自动删除旧邮件", 
                callback_data="toggle_auto_delete"
            ),
        ],
        [
            InlineKeyboardButton("🗑️ 清除所有数据", callback_data="clear_all_data"),
        ],
        [
            InlineKeyboardButton("« 返回", callback_data="back_to_settings"),
        ],
    ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text(
        "🔒 <b>隐私设置</b>\n\n"
        "管理您的数据和隐私选项。",
        reply_markup=reply_markup,
        parse_mode="HTML"
    )

async def back_to_settings_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """返回主设置菜单"""
    query = update.callback_query
    
    keyboard = [
        [
            InlineKeyboardButton("通知设置", callback_data="settings_notifications"),
            InlineKeyboardButton("账户管理", callback_data="settings_accounts"),
        ],
        [
            InlineKeyboardButton("显示选项", callback_data="settings_display"),
            InlineKeyboardButton("隐私设置", callback_data="settings_privacy"),
        ],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text("⚙️ 请选择要管理的设置类别：", reply_markup=reply_markup)

async def handle_email_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    处理邮件相关的回调查询
    """
    query = update.callback_query
    await query.answer()
    
    callback_data = query.data
    
    if callback_data.startswith("view_email_"):
        email_id = int(callback_data.split("_")[2])
        await handle_view_email(update, context, email_id)
    elif callback_data.startswith("mark_read_"):
        email_id = int(callback_data.split("_")[2])
        await handle_mark_email_read(update, context, email_id)
    elif callback_data.startswith("reply_email_"):
        email_id = int(callback_data.split("_")[2])
        await handle_reply_email(update, context, email_id)
    elif callback_data.startswith("forward_email_"):
        email_id = int(callback_data.split("_")[2])
        await handle_forward_email(update, context, email_id)
    elif callback_data.startswith("delete_email_"):
        email_id = int(callback_data.split("_")[2])
        await handle_delete_email(update, context, email_id)
    elif callback_data.startswith("download_attachments_"):
        email_id = int(callback_data.split("_")[2])
        await handle_download_attachments(update, context, email_id)
    else:
        logger.warning(f"未知邮件回调数据: {callback_data}")
        await query.edit_message_text(
            "抱歉，发生了未知错误。请重新尝试操作。"
        )

async def handle_view_email(update: Update, context: ContextTypes.DEFAULT_TYPE, email_id: int) -> None:
    """
    处理查看邮件详情
    """
    query = update.callback_query
    
    # 从数据库获取邮件
    email = get_email_by_id(email_id)
    if not email:
        await query.edit_message_text("抱歉，找不到该邮件或已被删除。")
        return
    
    # 准备邮件详情消息
    message_text = (
        f"📧 <b>{html.escape(email.subject)}</b>\n\n"
        f"<b>发件人:</b> {html.escape(email.sender)}\n"
        f"<b>收件人:</b> {html.escape(email.recipients)}\n"
        f"<b>日期:</b> {email.date.strftime('%Y-%m-%d %H:%M')}\n\n"
    )
    
    # 添加正文提示信息 - 不再从数据库获取正文
    message_text += "<i>📝 邮件内容已通过单独消息发送，请在聊天历史中查找。</i>\n"
    message_text += "<i>如需重新查看邮件内容，可使用 /check 命令检查新邮件。</i>\n"
    
    # 检查是否有附件
    if email.has_attachments:
        message_text += f"\n\n📎 <b>附件:</b> {email.attachment_count}个"
    
    # 创建操作按钮 - 移除"标记为已读"按钮
    keyboard = [
        [
            InlineKeyboardButton("📤 下载附件", callback_data=f"download_attachments_{email_id}"),
        ],
        [
            InlineKeyboardButton("↩️ 回复", callback_data=f"reply_email_{email_id}"),
            InlineKeyboardButton("🔄 转发", callback_data=f"forward_email_{email_id}"),
            InlineKeyboardButton("🗑️ 删除", callback_data=f"delete_email_{email_id}"),
        ],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    # 发送消息
    await query.edit_message_text(
        message_text,
        reply_markup=reply_markup,
        parse_mode="HTML",
        disable_web_page_preview=True
    )

async def handle_mark_email_read(update: Update, context: ContextTypes.DEFAULT_TYPE, email_id: int) -> None:
    """
    处理标记邮件为已读
    """
    query = update.callback_query
    
    # 从数据库获取邮件
    email = get_email_by_id(email_id)
    if not email:
        await query.edit_message_text("抱歉，找不到该邮件或已被删除。")
        return
    
    # 标记邮件为已读
    success = mark_email_as_read(email_id)
    
    if success:
        await query.edit_message_text(
            f"✅ 邮件 \"{html.escape(email.subject)}\" 已标记为已读。",
            parse_mode="HTML"
        )
    else:
        await query.edit_message_text(
            f"❌ 标记邮件为已读时发生错误。请重试。",
            parse_mode="HTML"
        )

async def handle_reply_email(update: Update, context: ContextTypes.DEFAULT_TYPE, email_id: int) -> None:
    """
    处理回复邮件 - 启动回复邮件会话
    """
    query = update.callback_query
    
    # 从数据库获取邮件
    email = get_email_by_id(email_id)
    if not email:
        await query.edit_message_text("抱歉，找不到该邮件或已被删除。")
        return
    
    # 获取账户信息
    account = get_email_account_by_id(email.account_id)
    if not account:
        await query.edit_message_text("抱歉，找不到对应的邮箱账户。")
        return
    
    # 存储邮件和账户信息到用户数据
    context.user_data["reply_email_id"] = email_id
    context.user_data["reply_account_id"] = email.account_id
    context.user_data["reply_account_email"] = account.email
    
    # 处理回复邮件的主题（添加Re:前缀）
    subject = email.subject
    if not subject.lower().startswith("re:"):
        subject = f"Re: {subject}"
    context.user_data["reply_subject"] = subject
    
    # 存储原始消息ID以便回复时引用
    if hasattr(query.message, 'message_id'):
        context.user_data["reply_original_message_id"] = query.message.message_id
    
    # 初始化消息ID列表以便后续清理
    context.user_data["reply_messages"] = []
    if hasattr(update, 'message') and update.message:
        context.user_data["reply_messages"].append(update.message.message_id)
    
    # 准备收件人候选列表（从原邮件的发件人、收件人、抄送和密送列表中提取）
    # 原邮件的发件人作为默认收件人
    context.user_data["reply_default_recipient"] = email.sender
    
    # 根据json格式解析原邮件的收件人列表
    import json
    recipients_list = []
    cc_list = []
    bcc_list = []
    
    # 尝试解析原邮件的收件人列表
    try:
        if email.recipients:
            if email.recipients.startswith('[') and email.recipients.endswith(']'):
                recipients_list = json.loads(email.recipients)
            else:
                recipients_list = [email.recipients]
    except json.JSONDecodeError:
        recipients_list = [email.recipients]
    
    # 尝试解析原邮件的抄送列表
    try:
        if email.cc:
            if email.cc.startswith('[') and email.cc.endswith(']'):
                cc_list = json.loads(email.cc)
            else:
                cc_list = [email.cc]
    except json.JSONDecodeError:
        if email.cc:
            cc_list = [email.cc]
    
    # 尝试解析原邮件的密送列表
    try:
        if email.bcc:
            if email.bcc.startswith('[') and email.bcc.endswith(']'):
                bcc_list = json.loads(email.bcc)
            else:
                bcc_list = [email.bcc]
    except json.JSONDecodeError:
        if email.bcc:
            bcc_list = [email.bcc]
    
    # 存储候选人列表，用于后续选择
    context.user_data["reply_candidates"] = {
        "recipients": recipients_list,
        "cc": cc_list,
        "bcc": bcc_list
    }
    
    # 初始化回复邮件的收件人、抄送和密送列表
    context.user_data["reply_recipients"] = [email.sender]  # 默认回复给原邮件的发件人
    context.user_data["reply_cc"] = []
    context.user_data["reply_bcc"] = []
    
    # 创建键盘布局，帮助用户从候选人中选择或手动添加
    keyboard = [
        ["📤 使用默认收件人（原发件人）"],
        ["👥 管理收件人列表"],
        ["📋 管理抄送列表"],
        ["🕶 管理密送列表"],
        ["✅ 继续编写正文", "❌ 取消"]
    ]
    
    reply_markup = ReplyKeyboardMarkup(
        keyboard,
        one_time_keyboard=True,
        resize_keyboard=True,
        input_field_placeholder="选择操作或输入回复内容"
    )
    
    # 发送回复邮件的初始提示
    message = await query.message.reply_text(
        f"📤 <b>回复邮件</b>\n\n"
        f"<b>账号:</b> {html.escape(account.email)}\n"
        f"<b>主题:</b> {html.escape(subject)}\n"
        f"<b>收件人:</b> {html.escape(email.sender)}\n\n"
        f"请选择操作以继续邮件回复流程：\n"
        f"• 使用默认收件人 - 直接回复给原邮件发件人\n"
        f"• 管理收件人/抄送/密送列表 - 自定义接收者\n"
        f"• 继续编写正文 - 进入邮件正文编写\n"
        f"• 取消 - 放弃当前回复操作",
        parse_mode="HTML",
        reply_markup=reply_markup,
        disable_notification=True
    )
    
    # 记录消息ID以便后续清理
    context.user_data["reply_messages"].append(message.message_id)
    
    # 更新会话状态
    return REPLY_ENTER_RECIPIENTS

async def handle_forward_email(update: Update, context: ContextTypes.DEFAULT_TYPE, email_id: int) -> None:
    """
    处理转发邮件
    """
    query = update.callback_query
    
    # 从数据库获取邮件
    email = get_email_by_id(email_id)
    if not email:
        await query.edit_message_text("抱歉，找不到该邮件或已被删除。")
        return
    
    # 将邮件ID存储在用户数据中，以便后续处理
    context.user_data["forward_email_id"] = email_id
    
    # 提示用户输入收件人
    await query.edit_message_text(
        f"🔄 <b>转发邮件</b>\n\n"
        f"<b>主题:</b> Fwd: {html.escape(email.subject)}\n\n"
        f"请输入收件人邮箱地址，使用逗号分隔多个地址，或使用 /cancel 取消操作。",
        parse_mode="HTML"
    )
    
    # 设置会话状态
    context.user_data["state"] = "awaiting_forward_recipients"

async def handle_delete_email(update: Update, context: ContextTypes.DEFAULT_TYPE, email_id: int) -> None:
    """
    处理删除邮件
    """
    query = update.callback_query
    
    # 从数据库获取邮件
    email = get_email_by_id(email_id)
    if not email:
        await query.answer("抱歉，找不到该邮件或已被删除。", show_alert=True)
        return
    
    # 使用ReplyKeyboardMarkup询问用户是否确定删除
    keyboard = ReplyKeyboardMarkup(
        [
            ["✅ 确认删除"],
            ["❌ 取消删除"]
        ],
        one_time_keyboard=True,
        resize_keyboard=True
    )
    
    # 保存正在删除的邮件ID到上下文中
    context.user_data["delete_email_id"] = email_id
    # 保存原始消息ID（用于稍后删除）
    context.user_data["delete_origin_message_id"] = query.message.message_id
    
    # 发送确认消息
    await query.answer()
    confirmation_message = await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text=f"🗑️ <b>删除邮件确认</b>\n\n"
             f"您确定要删除主题为 <b>\"{html.escape(email.subject)}\"</b> 的邮件吗？\n"
             f"此操作无法撤销。",
        parse_mode="HTML",
        reply_markup=keyboard,
        disable_notification=True
    )
    
    # 保存确认消息ID，以便在操作后删除
    context.user_data["delete_confirm_message_id"] = confirmation_message.message_id

async def handle_confirm_delete_email(update: Update, context: ContextTypes.DEFAULT_TYPE, email_id: int) -> None:
    """
    处理确认删除邮件
    """
    query = update.callback_query
    await query.answer()
    
    # 从数据库获取邮件
    email = get_email_by_id(email_id)
    if not email:
        # 使用answer回调而不是编辑消息
        await query.answer("抱歉，找不到该邮件或已被删除。", show_alert=True)
        return
    
    # 获取邮件账户
    account = get_email_account_by_id(email.account_id)
    if not account:
        await query.answer("抱歉，找不到该邮件的邮箱账户。", show_alert=True)
        return
    
    # 尝试创建临时状态消息 - 但不中断流程
    delete_in_progress_message = None
    try:
        # 判断消息类型，针对不同类型使用不同的编辑方法
        if query.message and not query.message.document and not query.message.photo and query.message.text:
            # 如果是文本消息
            delete_in_progress_message = await query.edit_message_text("⏳ 正在删除邮件...", parse_mode="HTML")
        elif query.message and query.message.caption is not None:
            # 如果是带caption的消息（图片或文档）
            delete_in_progress_message = await query.edit_message_caption(
                caption="⏳ 正在删除邮件...", 
                parse_mode="HTML"
            )
        else:
            # 如果无法编辑，使用回调通知
            await query.answer("正在删除邮件...", show_alert=False)
    except Exception as e:
        logger.error(f"编辑消息失败: {e}")
        # 这里不返回，继续执行删除逻辑
    
    imap_delete_success = False
    
    # 连接到IMAP服务器并删除邮件
    client = IMAPClient(account=account)
    if await client.connect():
        try:
            # 是否为已发送邮件（检查消息ID中是否包含sent标识或其他属性）
            mailbox = None
            # 尝试先在收件箱中查找
            if await client.select_mailbox():
                message_nums = await client.search_by_message_id(email.message_id)
                if message_nums:
                    # 删除邮件
                    imap_delete_success = await client.delete_message(message_nums[0])
                else:
                    # 如果在收件箱中找不到，尝试在已发送文件夹中查找
                    if await client.select_mailbox('sent'):
                        message_nums = await client.search_by_message_id(email.message_id)
                        if message_nums:
                            # 删除已发送邮件
                            imap_delete_success = await client.delete_message(message_nums[0])
        except Exception as e:
            logger.error(f"IMAP删除邮件时发生错误: {e}")
        finally:
            client.disconnect()
    
    # 无论IMAP操作是否成功，都在数据库中标记为已删除
    success = delete_email(email_id)
    
    if success:
        try:
            # 删除原始Telegram消息
            await query.message.delete()
            
            # 发送一条提示消息，3秒后自动删除
            sent_message = await context.bot.send_message(
                chat_id=query.message.chat_id,
                text=f"✅ 邮件 \"{html.escape(email.subject)}\" 已成功删除。",
                parse_mode="HTML"
            )
            
            # 设置3秒后删除消息的任务
            context.job_queue.run_once(
                lambda job_context: delete_message(job_context, update.effective_chat.id, success_message.message_id),
                3,  # 3秒后删除
                name=f"delete_success_msg_{sent_message.message_id}"
            )
        except Exception as e:
            logger.error(f"处理Telegram消息时发生错误: {e}")
            await query.answer("✅ 邮件已成功删除", show_alert=True)
    else:
        try:
            # 尝试通知删除失败
            if query.message and not query.message.document and not query.message.photo and query.message.text:
                await query.edit_message_text(
                    f"❌ 删除邮件时发生错误。请重试。",
                    parse_mode="HTML"
                )
            elif query.message and query.message.caption is not None:
                await query.edit_message_caption(
                    caption=f"❌ 删除邮件时发生错误。请重试。",
                    parse_mode="HTML"
                )
            else:
                await query.answer("❌ 删除邮件时发生错误。请重试。", show_alert=True)
        except Exception as e:
            logger.error(f"编辑消息失败: {e}")
            await query.answer("❌ 删除邮件时发生错误。请重试。", show_alert=True)

async def handle_cancel_delete_email(update: Update, context: ContextTypes.DEFAULT_TYPE, email_id: int = None) -> None:
    """处理取消删除邮件的回调"""
    query = update.callback_query
    await query.answer()
    
    # 如果没有传入email_id参数，则从回调数据中提取
    if email_id is None:
        email_id = int(query.data.split("_")[2])
    
    # 获取邮件信息
    email = get_email_by_id(email_id)
    if not email:
        await query.answer("无法找到邮件信息。", show_alert=True)
        return
    
    try:
        # 尝试使用handle_view_email恢复原始视图
        await handle_view_email(update, context, email_id)
    except Exception as e:
        logger.error(f"恢复邮件视图失败: {e}")
        await query.answer("已取消删除操作", show_alert=True)

# 账户添加对话处理相关函数
from telegram import ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import ConversationHandler, CommandHandler, MessageHandler, filters, CallbackQueryHandler
import asyncio

# 定义对话状态
ENTER_EMAIL = "ENTER_EMAIL"
ENTER_NAME = "ENTER_NAME"
ENTER_USERNAME = "ENTER_USERNAME"
ENTER_PASSWORD = "ENTER_PASSWORD"

# 常见邮箱服务商的配置信息
EMAIL_PROVIDERS = {
    "gmail.com": {
        "imap_server": "imap.gmail.com",
        "imap_port": 993,
        "imap_use_ssl": True,
        "smtp_server": "smtp.gmail.com",
        "smtp_port": 587,
        "smtp_use_ssl": True,
        "name": "Gmail"
    },
    "163.com": {
        "imap_server": "imap.163.com",
        "imap_port": 993,
        "imap_use_ssl": True,
        "smtp_server": "smtp.163.com",
        "smtp_port": 465,
        "smtp_use_ssl": True,
        "name": "网易163邮箱"
    },
    "126.com": {
        "imap_server": "imap.126.com",
        "imap_port": 993,
        "imap_use_ssl": True,
        "smtp_server": "smtp.126.com",
        "smtp_port": 465,
        "smtp_use_ssl": True,
        "name": "网易126邮箱"
    },
    "qq.com": {
        "imap_server": "imap.qq.com",
        "imap_port": 993,
        "imap_use_ssl": True,
        "smtp_server": "smtp.qq.com",
        "smtp_port": 465,
        "smtp_use_ssl": True,
        "name": "QQ邮箱"
    },
    "outlook.com": {
        "imap_server": "outlook.office365.com",
        "imap_port": 993,
        "imap_use_ssl": True,
        "smtp_server": "smtp.office365.com",
        "smtp_port": 587,
        "smtp_use_ssl": True,
        "name": "Outlook"
    },
    "hotmail.com": {
        "imap_server": "outlook.office365.com",
        "imap_port": 993,
        "imap_use_ssl": True,
        "smtp_server": "smtp.office365.com",
        "smtp_port": 587,
        "smtp_use_ssl": True,
        "name": "Hotmail"
    },
    "live.com": {
        "imap_server": "outlook.office365.com",
        "imap_port": 993,
        "imap_use_ssl": True,
        "smtp_server": "smtp.office365.com",
        "smtp_port": 587,
        "smtp_use_ssl": True,
        "name": "Live"
    },
    "yahoo.com": {
        "imap_server": "imap.mail.yahoo.com",
        "imap_port": 993,
        "imap_use_ssl": True,
        "smtp_server": "smtp.mail.yahoo.com",
        "smtp_port": 587,
        "smtp_use_ssl": True,
        "name": "Yahoo"
    },
    "foxmail.com": {
        "imap_server": "imap.qq.com",
        "imap_port": 993,
        "imap_use_ssl": True,
        "smtp_server": "smtp.qq.com",
        "smtp_port": 465,
        "smtp_use_ssl": True,
        "name": "Foxmail"
    }
}

async def handle_add_account_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> str:
    """处理添加账户按钮回调"""
    query = update.callback_query
    await query.answer()
    
    # 发送引导信息
    message = await query.message.reply_text(
        "📬 <b>添加新邮箱账户</b>\n\n"
        "请输入您的邮箱地址（例如：example@gmail.com）\n\n"
        "您可以随时输入 /cancel 取消操作。",
        parse_mode="HTML",
        disable_notification=True
    )
    
    # 保存此消息ID，以便后续删除
    context.user_data["guide_message_id"] = message.message_id
    context.user_data["last_step_message_ids"] = []
    
    return ENTER_EMAIL

async def handle_enter_email(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """处理输入邮箱地址"""
    # 记录这一步的消息ID
    if "last_step_message_ids" not in context.user_data:
        context.user_data["last_step_message_ids"] = []
    context.user_data["last_step_message_ids"].append(update.message.message_id)
    
    email = update.message.text.strip()
    
    # 检查是否取消操作
    if email.lower() == "/cancel":
        return await handle_cancel_account(update, context)
    
    # 简单验证邮箱格式
    if "@" not in email or "." not in email:
        message = await update.message.reply_text(
            "❌ 邮箱格式不正确，请重新输入一个有效的邮箱地址。",
            disable_notification=True
        )
        context.user_data["last_step_message_ids"].append(message.message_id)
        return ENTER_EMAIL
    
    # 检查是否已存在该邮箱账户
    existing_account = AccountOperations.get_account_by_email(email)
    if existing_account:
        message = await update.message.reply_text(
            f"❌ 邮箱 {email} 已经添加过了，请使用其他邮箱。",
            disable_notification=True
        )
        context.user_data["last_step_message_ids"].append(message.message_id)
        return ENTER_EMAIL
    
    # 保存邮箱到上下文
    context.user_data["new_account"] = {"email": email}
    
    # 尝试自动配置邮箱服务器信息
    email_domain = email.split("@")[1].lower()
    
    # 检查是否是常见邮箱提供商
    if email_domain in EMAIL_PROVIDERS:
        provider = EMAIL_PROVIDERS[email_domain]
        provider_name = provider["name"]
        context.user_data["new_account"].update({
            "imap_server": provider["imap_server"],
            "imap_port": provider["imap_port"],
            "imap_use_ssl": provider["imap_use_ssl"],
            "smtp_server": provider["smtp_server"],
            "smtp_port": provider["smtp_port"],
            "smtp_use_ssl": provider["smtp_use_ssl"]
        })
        
        # 删除前一步的消息
        await delete_last_step_messages(context, update.effective_chat.id)
        
        # 发送配置成功消息
        message = await update.message.reply_text(
            f"📧 已自动配置{provider_name}服务器信息。\n\n"
            f"请为此账户设置一个名称 (例如: 工作邮箱, 个人邮箱)，\n"
            f"或直接发送 /skip 跳过。",
            disable_notification=True
        )
        context.user_data["last_step_message_ids"] = [message.message_id]
    else:
        # 对于不常见的邮箱，我们直接跳过服务器配置，后面会提示用户手动输入
        # 这里我们使用默认的通用配置，但要在后面验证连接时确认
        context.user_data["new_account"].update({
            "imap_server": f"imap.{email_domain}",
            "imap_port": 993,
            "imap_use_ssl": True,
            "smtp_server": f"smtp.{email_domain}",
            "smtp_port": 587,
            "smtp_use_ssl": True
        })
        
        # 删除前一步的消息
        await delete_last_step_messages(context, update.effective_chat.id)
        
        # 发送下一步指引
        message = await update.message.reply_text(
            f"📧 为{email}设置一个名称 (例如: 工作邮箱, 个人邮箱)，\n"
            f"或直接发送 /skip 跳过。\n\n"
            f"注意：系统将尝试使用自动生成的服务器配置，如果连接失败，将提示您手动输入。",
            disable_notification=True
        )
        context.user_data["last_step_message_ids"] = [message.message_id]
    
    return ENTER_NAME

async def handle_enter_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """处理输入账户名称"""
    # 记录这一步的消息ID
    context.user_data["last_step_message_ids"].append(update.message.message_id)
    
    text = update.message.text.strip()
    
    # 检查是否取消操作
    if text.lower() == "/cancel":
        return await handle_cancel_account(update, context)
    
    if text == "/skip":
        context.user_data["new_account"]["name"] = None
    else:
        context.user_data["new_account"]["name"] = text
    
    # 删除前一步的消息
    await delete_last_step_messages(context, update.effective_chat.id)
    
    # 提示输入用户名
    message = await update.message.reply_text(
        f"请输入您的邮箱用户名 (通常就是完整的邮箱地址)。\n\n"
        f"例如: {context.user_data['new_account']['email']}",
        disable_notification=True
    )
    context.user_data["last_step_message_ids"] = [message.message_id]
    
    return ENTER_USERNAME

async def handle_enter_username(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """处理输入用户名"""
    # 记录这一步的消息ID
    context.user_data["last_step_message_ids"].append(update.message.message_id)
    
    username = update.message.text.strip()
    
    # 检查是否取消操作
    if username.lower() == "/cancel":
        return await handle_cancel_account(update, context)
    
    context.user_data["new_account"]["username"] = username
    
    # 删除前一步的消息
    await delete_last_step_messages(context, update.effective_chat.id)
    
    # 提示输入密码
    message = await update.message.reply_text(
        "请输入您的邮箱密码或应用专用密码。\n\n"
        "👀 <b>注意</b>：如果您的邮箱启用了两步验证，请使用应用专用密码而非登录密码。\n\n"
        "<i>您的密码将被安全加密存储，且只会用于邮件收发。</i>",
        parse_mode="HTML",
        disable_notification=True
    )
    context.user_data["last_step_message_ids"] = [message.message_id]
    
    return ENTER_PASSWORD

async def handle_enter_password(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """处理输入密码"""
    # 记录这一步的消息ID
    context.user_data["last_step_message_ids"].append(update.message.message_id)
    
    password = update.message.text.strip()
    
    # 检查是否取消操作
    if password.lower() == "/cancel":
        return await handle_cancel_account(update, context)
    
    # 删除密码消息以保护隐私
    try:
        await update.message.delete()
    except Exception:
        pass
    
    # 删除前一步的提示消息
    await delete_last_step_messages(context, update.effective_chat.id, exclude_last=True)
    
    # 保存密码到上下文
    context.user_data["new_account"]["password"] = password
    
    # 发送测试连接的提示
    message = await update.message.reply_text("🔄 正在测试邮箱连接，请稍候...", disable_notification=True)
    context.user_data["testing_message_id"] = message.message_id
    
    # 开始进行连接测试
    return await test_account_connection(update, context)

async def delete_last_step_messages(context, chat_id, exclude_last=False):
    """删除上一步的问答消息"""
    if "last_step_message_ids" in context.user_data:
        message_ids = context.user_data["last_step_message_ids"]
        # 如果需要排除最后一条消息
        if exclude_last and message_ids:
            message_ids = message_ids[:-1]
            
        for msg_id in message_ids:
            try:
                await context.bot.delete_message(chat_id=chat_id, message_id=msg_id)
            except Exception:
                pass
        
        if exclude_last and context.user_data["last_step_message_ids"]:
            context.user_data["last_step_message_ids"] = [context.user_data["last_step_message_ids"][-1]]
        else:
            context.user_data["last_step_message_ids"] = []

async def test_account_connection(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """测试邮箱连接"""
    account = context.user_data["new_account"]
    
    # 创建IMAP客户端进行测试
    from app.email.imap_client import IMAPClient
    from app.email.smtp_client import SMTPClient
    
    imap_client = IMAPClient(
        server=account["imap_server"],
        port=account["imap_port"],
        username=account["username"],
        password=account["password"],
        use_ssl=account.get("imap_use_ssl", True)
    )
    
    # 测试IMAP连接
    imap_success = await imap_client.test_connection()
    
    # 如果IMAP连接成功，使用检测到的配置覆盖原有设置
    if imap_success:
        # 更新当前的IMAP配置以使用检测到的端口和SSL设置
        account["imap_port"] = imap_client.port
        account["imap_use_ssl"] = imap_client.use_ssl
        
        # 测试SMTP连接
        smtp_client = SMTPClient(
            server=account["smtp_server"],
            port=account["smtp_port"],
            username=account["username"],
            password=account["password"],
            use_ssl=account.get("smtp_use_ssl", True)
        )
        
        smtp_success = await smtp_client.test_connection()
        
        # 如果SMTP连接成功，使用检测到的配置覆盖原有设置
        if smtp_success:
            account["smtp_port"] = smtp_client.port
            account["smtp_use_ssl"] = smtp_client.use_ssl
    else:
        smtp_success = False
    
    # 尝试删除测试连接的提示消息
    if "testing_message_id" in context.user_data:
        try:
            await context.bot.delete_message(
                chat_id=update.effective_chat.id,
                message_id=context.user_data["testing_message_id"]
            )
        except Exception:
            pass
    
    # 如果连接测试成功
    if imap_success and smtp_success:
        # 将账户保存到数据库
        added_account = AccountOperations.add_account(
            email=account["email"],
            name=account.get("name") or "",
            imap_server=account["imap_server"],
            imap_port=account["imap_port"],
            imap_use_ssl=account["imap_use_ssl"],
            smtp_server=account["smtp_server"],
            smtp_port=account["smtp_port"],
            smtp_use_ssl=account["smtp_use_ssl"],
            username=account["username"],
            password=account["password"]
        )
        
        if added_account:
            # 发送成功消息并设置3秒后自动删除
            success_message = await update.message.reply_text(
                "✅ 账户添加成功！\n\n"
                f"邮箱: {account['email']}\n"
                f"名称: {account.get('name') or '未设置'}\n\n"
                "您现在可以使用此账户发送和接收邮件。\n"
                "可以使用 /accounts 命令查看您的所有账户。\n\n"
                "<i>此消息将在3秒后自动删除</i>",
                parse_mode="HTML",
                disable_notification=True
            )
            
            # 设置3秒后删除成功消息
            context.job_queue.run_once(
                lambda ctx: delete_message(ctx, update.effective_chat.id, success_message.message_id),
                3
            )
            
            # 自动触发检查新邮件
            try:
                from app.email.email_monitor import get_email_monitor
                monitor = get_email_monitor()
                
                if monitor:
                    # 发送正在检查的消息
                    checking_message = await update.message.reply_text(
                        "🔍 正在检查新账户的邮件...",
                        disable_notification=True
                    )
                    
                    # 检查新邮件
                    new_email_count = await monitor.check_emails(context)
                    
                    # 更新消息为检查完成
                    if new_email_count > 0:
                        await checking_message.edit_text(
                            f"✅ 邮件检查完成！发现 {new_email_count} 封新邮件。"
                        )
                        # 设置3秒后删除检查消息
                        context.job_queue.run_once(
                            lambda ctx: delete_message(ctx, update.effective_chat.id, checking_message.message_id),
                            3
                        )
                    else:
                        await checking_message.edit_text(
                            "✅ 邮件检查完成！没有新邮件。"
                        )
                        # 设置3秒后删除检查消息
                        context.job_queue.run_once(
                            lambda ctx: delete_message(ctx, update.effective_chat.id, checking_message.message_id),
                            3
                        )
            except Exception as e:
                logger.error(f"自动检查新邮件时出错: {e}")
            
            # 清理上下文数据
            context.user_data.clear()
            
            # 结束对话
            return ConversationHandler.END
        else:
            # 保存数据库失败
            error_message = await update.message.reply_text(
                "❌ 连接测试成功，但保存账户时出错。\n"
                "请稍后再试或联系管理员。",
                disable_notification=True
            )
            
            # 清理上下文数据
            context.user_data.clear()
            
            # 结束对话
            return ConversationHandler.END
    else:
        # 连接测试失败
        if not imap_success:
            error_type = "IMAP连接"
        else:
            error_type = "SMTP连接" 
            
        # 提示连接测试失败，需要重新开始
        await update.message.reply_text(
            f"❌ {error_type}测试失败！\n\n"
            f"请检查您的邮箱地址、用户名和密码是否正确。\n"
            f"对于Gmail等需要两步验证的邮箱，请确保使用了应用专用密码。\n\n"
            f"请使用 /addaccount 重新开始添加流程。",
            disable_notification=True
        )
        
        # 清理上下文数据
        context.user_data.clear()
        
        # 结束对话
        return ConversationHandler.END

async def handle_cancel_account(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """处理取消账户添加"""
    # 删除所有已产生的消息
    if "last_step_message_ids" in context.user_data:
        for msg_id in context.user_data["last_step_message_ids"]:
            try:
                await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=msg_id)
            except Exception:
                pass
    
    # 删除指南消息
    if "guide_message_id" in context.user_data:
        try:
            await context.bot.delete_message(
                chat_id=update.effective_chat.id,
                message_id=context.user_data["guide_message_id"]
            )
        except Exception:
            pass
    
    # 发送取消消息并设置3秒后自动删除
    cancel_message = await update.message.reply_text(
        "❌ 已取消添加账户。\n\n"
        "您可以使用 /addaccount 命令重新开始。\n\n"
        "<i>此消息将在3秒后自动删除</i>",
        parse_mode="HTML",
        disable_notification=True
    )
    
    # 设置3秒后删除取消消息
    context.job_queue.run_once(
        lambda ctx: delete_message(ctx, update.effective_chat.id, cancel_message.message_id),
        3
    )
    
    # 删除用户发送的取消命令
    try:
        await update.message.delete()
    except Exception:
        pass
    
    # 清理上下文数据
    context.user_data.clear()
    
    # 结束对话
    return ConversationHandler.END

async def delete_message(context, chat_id, message_id):
    """删除指定消息的辅助函数"""
    try:
        await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
    except Exception:
        pass

# 对话处理函数字典
addaccount_conversation = {
    ENTER_EMAIL: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_enter_email)],
    ENTER_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_enter_name)],
    ENTER_USERNAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_enter_username)],
    ENTER_PASSWORD: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_enter_password)],
}

# Account conversation handler
def handle_account_conversation():
    """Return a ConversationHandler for account management"""
    return ConversationHandler(
        entry_points=[
            CommandHandler("addaccount", addaccount_command),
            CallbackQueryHandler(handle_add_account_callback, pattern="^add_account$")
        ],
        states=addaccount_conversation,
        fallbacks=[CommandHandler("cancel", handle_cancel_account)],
        name="account_conversation",
        persistent=False
    )

async def handle_delete_account(update: Update, context: ContextTypes.DEFAULT_TYPE, account_id: int) -> None:
    """处理删除账户请求"""
    query = update.callback_query
    
    # 获取账户信息
    account = AccountOperations.get_account(account_id)
    
    if not account:
        await query.edit_message_text("❌ 账户不存在或已被删除。")
        return
    
    # 构建确认删除的键盘
    keyboard = [
        [
            InlineKeyboardButton("✅ 确认删除", callback_data=f"confirm_delete_account_{account_id}"),
            InlineKeyboardButton("❌ 取消", callback_data="cancel_delete_account"),
        ]
    ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    # 发送确认消息
    await query.edit_message_text(
        f"⚠️ <b>删除账户确认</b>\n\n"
        f"您确定要删除以下账户吗？此操作无法撤销。\n\n"
        f"账户: <b>{account.email}</b>\n"
        f"名称: {account.name or '未设置'}\n",
        reply_markup=reply_markup,
        parse_mode="HTML"
    )

async def handle_confirm_delete_account(update: Update, context: ContextTypes.DEFAULT_TYPE, account_id: int) -> None:
    """处理确认删除账户"""
    query = update.callback_query
    
    # 获取账户信息
    account = AccountOperations.get_account(account_id)
    
    if not account:
        await query.edit_message_text("❌ 账户不存在或已被删除。")
        return
    
    # 保存账户邮箱以便在删除后显示
    email = account.email
    name = account.name or "未设置"
    
    # 执行删除操作
    success = AccountOperations.delete_account(account_id)
    
    if success:
        await query.edit_message_text(
            f"✅ 账户删除成功\n\n"
            f"邮箱: <b>{email}</b>\n"
            f"名称: {name}\n\n"
            f"此账户已从系统中永久删除。",
            parse_mode="HTML"
        )
    else:
        await query.edit_message_text(
            f"❌ 删除账户时出错\n\n"
            f"邮箱: <b>{email}</b>\n"
            f"请稍后再试或联系管理员。",
            parse_mode="HTML"
        )

async def handle_cancel_delete_account(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """处理取消删除账户"""
    query = update.callback_query
    
    # 重新获取所有账户并显示列表
    accounts = AccountOperations.get_all_active_accounts()
    
    if not accounts:
        await query.edit_message_text(
            "📭 您已没有任何邮箱账户。\n"
            "使用 /addaccount 命令添加新账户。"
        )
        return
    
    # 构建账户列表消息
    accounts_text = "📧 <b>已添加的邮箱账户</b>\n\n"
    
    for i, account in enumerate(accounts):
        accounts_text += (
            f"{i+1}. <b>{account.email}</b>\n"
            f"   名称: {account.name or '未设置'}\n"
            f"   IMAP: {account.imap_server}:{account.imap_port}\n"
            f"   SMTP: {account.smtp_server}:{account.smtp_port}\n\n"
        )
    
    # 添加管理按钮
    keyboard = []
    
    # 为每个账户添加删除按钮
    for account in accounts:
        keyboard.append([
            InlineKeyboardButton(f"删除 {account.email}", callback_data=f"delete_account_{account.id}")
        ])
    
    # 添加"添加新账户"按钮
    keyboard.append([
        InlineKeyboardButton("添加新账户", callback_data="add_account")
    ])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text(
        accounts_text,
        reply_markup=reply_markup,
        parse_mode="HTML"
    )

async def reply_command_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    处理用户回复消息中的 /reply 命令
    
    当用户回复某条邮件通知并发送 /reply 命令时，触发邮件回复流程
    """
    message = update.message
    
    # 检查是否是回复某条消息
    if not message.reply_to_message:
        await message.reply_text("❌ 请回复一条邮件通知消息并使用 /reply 命令", disable_notification=True)
        return
    
    # 获取原始消息ID
    original_message_id = message.reply_to_message.message_id
    
    # 根据消息ID查找对应的邮件ID
    email_id = MessageOperations.get_email_id_by_telegram_message_id(str(original_message_id))
    
    if not email_id:
        await message.reply_text("❌ 抱歉，找不到与此消息关联的邮件", disable_notification=True)
        return
    
    # 删除命令消息，保持聊天整洁
    try:
        await message.delete()
    except Exception as e:
        logger.warning(f"无法删除命令消息: {e}")
    
    # 创建回调数据
    callback_data = f"reply_email_{email_id}"
    
    # 创建一个模拟的回调查询对象来触发回复邮件会话
    class MockCallbackQuery:
        def __init__(self, message_obj, data):
            self.message = message_obj
            self.data = data
        
        async def answer(self):
            pass
    
    # 创建模拟的回调查询
    mock_query = MockCallbackQuery(message.reply_to_message, callback_data)
    
    # 更新update对象用于传递给handle_reply_email
    update.callback_query = mock_query
    
    # 调用handle_reply_email函数启动回复邮件会话
    await handle_reply_email(update, context, email_id)

async def forward_command_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    处理用户回复消息中的 /forward 命令
    
    当用户回复某条邮件通知并发送 /forward 命令时，触发邮件转发流程
    """
    message = update.message
    
    # 检查是否是回复某条消息
    if not message.reply_to_message:
        await message.reply_text("❌ 请回复一条邮件通知消息并使用 /forward 命令", disable_notification=True)
        return
    
    # 获取原始消息ID
    original_message_id = message.reply_to_message.message_id
    
    # 根据消息ID查找对应的邮件ID
    email_id = MessageOperations.get_email_id_by_telegram_message_id(str(original_message_id))
    
    if not email_id:
        await message.reply_text("❌ 抱歉，找不到与此消息关联的邮件", disable_notification=True)
        return
    
    # 删除命令消息，保持聊天整洁
    try:
        await message.delete()
    except Exception as e:
        logger.warning(f"无法删除命令消息: {e}")
    
    # 使用现有的转发邮件处理器
    # 创建一个模拟的回调查询对象
    class MockCallbackQuery:
        def __init__(self, message_id):
            self.message = message.reply_to_message
            self.data = f"forward_email_{email_id}"
        
        async def answer(self):
            pass
        
        async def edit_message_text(self, text, parse_mode=None):
            return await message.reply_to_message.reply_text(text, parse_mode=parse_mode)
    
    # 创建模拟的回调查询
    mock_query = MockCallbackQuery(original_message_id)
    
    # 更新update对象用于传递给handle_forward_email
    update.callback_query = mock_query
    
    # 使用现有的转发邮件处理器
    await handle_forward_email(update, context, email_id)

# 基本命令处理函数

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """处理/start命令"""
    user = update.effective_user
    
    # 获取用户的邮箱账户
    accounts = AccountOperations.get_all_active_accounts()
    
    if not accounts:
        # 用户没有添加邮箱账户，引导添加第一个账户
        keyboard = [
            [InlineKeyboardButton("添加邮箱账户", callback_data="add_account")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_html(
            f"你好，{user.mention_html()}！👋\n\n"
            f"欢迎使用TelegramMail - 你的Telegram邮件助手。\n\n"
            f"看起来你还没有添加任何邮箱账户。要开始使用，请先添加一个邮箱账户。\n\n"
            f"你可以点击下方按钮或使用 /addaccount 命令添加账户。",
            reply_markup=reply_markup
        )
    else:
        # 用户已有邮箱账户，显示正常欢迎消息
        await update.message.reply_html(
            f"你好，{user.mention_html()}！👋\n\n"
            f"欢迎使用TelegramMail - 你的Telegram邮件助手。\n\n"
            f"使用 /help 查看可用命令。"
        )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """处理/help命令"""
    help_text = (
        "📬 <b>TelegramMail帮助</b> 📬\n\n"
        "<b>基本命令：</b>\n"
        "/start - 启动机器人\n"
        "/help - 显示此帮助信息\n"
        "/accounts - 查看已添加的邮箱账户\n"
        "/addaccount - 添加新邮箱账户\n"
        "/check - 手动检查新邮件\n\n"
        "<b>回复命令：</b>\n"
        "回复某条邮件通知并发送 /reply - 回复该邮件\n"
        "回复某条邮件通知并发送 /forward - 转发该邮件\n\n"
        "<b>接收通知：</b>\n"
        "当你收到新邮件时，机器人会自动通知你。\n"
        "删除Telegram消息将自动删除对应的邮件。"
    )
    await update.message.reply_html(help_text)

async def accounts_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """处理/accounts命令，列出已添加的邮箱账户"""
    accounts = AccountOperations.get_all_active_accounts()
    
    if not accounts:
        await update.message.reply_text(
            "📭 您还没有添加任何邮箱账户。\n"
            "使用 /addaccount 命令添加新账户。",
            disable_notification=True
        )
        return
    
    # 构建账户列表消息
    accounts_text = "📧 <b>已添加的邮箱账户</b>\n\n"
    
    for i, account in enumerate(accounts):
        accounts_text += (
            f"{i+1}. <b>{account.email}</b>\n"
            f"   名称: {account.name or '未设置'}\n"
            f"   IMAP: {account.imap_server}:{account.imap_port}\n"
            f"   SMTP: {account.smtp_server}:{account.smtp_port}\n\n"
        )
    
    # 添加管理按钮
    keyboard = []
    
    # 为每个账户添加删除按钮
    for account in accounts:
        keyboard.append([
            InlineKeyboardButton(f"删除 {account.email}", callback_data=f"delete_account_{account.id}")
        ])
    
    # 添加"添加新账户"按钮
    keyboard.append([
        InlineKeyboardButton("添加新账户", callback_data="add_account")
    ])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_html(accounts_text, reply_markup=reply_markup)

async def check_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """处理/check命令，手动检查新邮件"""
    # 获取邮件监听器实例
    from app.email.email_monitor import get_email_monitor
    monitor = get_email_monitor()
    
    if not monitor:
        await update.message.reply_text(
            "❌ 邮件监听器未启动，无法检查新邮件。",
            disable_notification=True
        )
        return
    
    # 发送正在检查的消息
    checking_message = await update.message.reply_text(
        "🔍 正在检查新邮件...",
        disable_notification=True
    )
    
    try:
        # 执行邮件检查，传入上下文用于发送通知
        new_email_count = await monitor.check_emails(context)
        
        # 更新消息为检查完成
        if new_email_count > 0:
            await checking_message.edit_text(
                f"✅ 邮件检查完成！发现 {new_email_count} 封新邮件。",
                disable_notification=True
            )
        else:
            await checking_message.edit_text(
                "✅ 邮件检查完成！没有新邮件。",
                disable_notification=True
            )
    except Exception as e:
        logger.error(f"检查邮件时出错: {e}")
        logger.error(traceback.format_exc())
        await checking_message.edit_text(
            f"❌ 检查邮件时出错: {str(e)}",
            disable_notification=True
        )

async def settings_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """处理设置相关的回调查询"""
    query = update.callback_query
    await query.answer()
    
    callback_data = query.data
    
    if callback_data.startswith("delete_account_"):
        account_id = int(callback_data.split("_")[2])
        await handle_delete_account(update, context, account_id)
    elif callback_data.startswith("confirm_delete_account_"):
        account_id = int(callback_data.split("_")[3])
        await handle_confirm_delete_account(update, context, account_id)
    elif callback_data == "cancel_delete_account":
        await handle_cancel_delete_account(update, context)
    elif callback_data == "add_account":
        # 重定向到 addaccount 命令
        await query.message.reply_text(
            "请使用 /addaccount 命令添加新邮箱账户。",
            disable_notification=True
        )
    else:
        await query.edit_message_text(
            "抱歉，无法识别的操作。",
            disable_notification=True
        )

# 对话状态定义
# EMAIL, NAME, IMAP_SERVER, IMAP_PORT, SMTP_SERVER, SMTP_PORT, USERNAME, PASSWORD, CONFIRM = range(9)

# 对话处理函数字典
addaccount_conversation = {
    ENTER_EMAIL: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_enter_email)],
    ENTER_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_enter_name)],
    ENTER_USERNAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_enter_username)],
    ENTER_PASSWORD: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_enter_password)],
}

# Account conversation handler (stub for now)
def handle_account_conversation():
    """Return a ConversationHandler for account management"""
    return ConversationHandler(
        entry_points=[
            CommandHandler("addaccount", addaccount_command),
            CallbackQueryHandler(handle_add_account_callback, pattern="^add_account$")
        ],
        states=addaccount_conversation,
        fallbacks=[CommandHandler("cancel", handle_cancel_account)],
        name="account_conversation",
        persistent=False
    )

async def addaccount_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> str:
    """处理/addaccount命令，开始添加新邮箱账户的交互过程"""
    # 初始化对话状态的存储
    if "new_account" in context.user_data:
        context.user_data.clear()  # 清除任何旧的数据
    
    # 发送引导信息
    message = await update.message.reply_text(
        "📬 <b>添加新邮箱账户</b>\n\n"
        "请输入您的邮箱地址。\n\n"
        "例如: example@gmail.com\n\n"
        "发送 /cancel 随时取消操作。",
        parse_mode="HTML",
        disable_notification=True
    )
    
    # 保存此消息ID，以便后续删除
    context.user_data["guide_message_id"] = message.message_id
    context.user_data["last_step_message_ids"] = []
    
    # 返回相关状态，交由对话处理器处理
    return ENTER_EMAIL 

async def handle_delete_cancellation(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """处理用户取消删除邮件"""
    # 获取之前保存的消息ID并删除确认消息
    if "delete_confirm_message_id" in context.user_data:
        try:
            await context.bot.delete_message(
                chat_id=update.effective_chat.id,
                message_id=context.user_data["delete_confirm_message_id"]
            )
        except Exception as e:
            logger.error(f"删除确认消息失败: {e}")
    
    # 删除用户的回复消息
    try:
        await update.message.delete()
    except Exception as e:
        logger.error(f"删除用户回复消息失败: {e}")
    
    # 恢复正常键盘
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text="已取消删除操作。",
        reply_markup=ReplyKeyboardRemove(),
        disable_notification=True
    )
    
    # 清理上下文数据
    if "delete_email_id" in context.user_data:
        del context.user_data["delete_email_id"]
    if "delete_origin_message_id" in context.user_data:
        del context.user_data["delete_origin_message_id"]
    if "delete_confirm_message_id" in context.user_data:
        del context.user_data["delete_confirm_message_id"]

async def handle_delete_confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """处理用户确认删除邮件"""
    # 获取要删除的邮件ID
    if "delete_email_id" not in context.user_data:
        await update.message.reply_text(
            "无法完成删除操作，邮件ID丢失。请重试。",
            reply_markup=ReplyKeyboardRemove(),
            disable_notification=True
        )
        return
    
    email_id = context.user_data["delete_email_id"]
    
    # 删除确认消息
    if "delete_confirm_message_id" in context.user_data:
        try:
            await context.bot.delete_message(
                chat_id=update.effective_chat.id,
                message_id=context.user_data["delete_confirm_message_id"]
            )
        except Exception as e:
            logger.error(f"删除确认消息失败: {e}")
    
    # 删除用户的回复消息
    try:
        await update.message.delete()
    except Exception as e:
        logger.error(f"删除用户回复消息失败: {e}")
    
    # 从数据库获取邮件
    email = get_email_by_id(email_id)
    if not email:
        # 邮件不存在，显示简短错误
        error_message = await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="抱歉，找不到该邮件或已被删除。",
            reply_markup=ReplyKeyboardRemove(),
            disable_notification=True
        )
        # 3秒后自动删除错误消息
        context.job_queue.run_once(
            lambda job_context: delete_message(job_context, update.effective_chat.id, error_message.message_id),
            3
        )
        # 清理上下文数据
        _clear_delete_context(context)
        return
    
    # 获取邮件账户
    account = get_email_account_by_id(email.account_id)
    if not account:
        # 邮箱账户不存在，显示简短错误
        error_message = await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="抱歉，找不到该邮件的邮箱账户。",
            reply_markup=ReplyKeyboardRemove(),
            disable_notification=True
        )
        # 3秒后自动删除错误消息
        context.job_queue.run_once(
            lambda job_context: delete_message(job_context, update.effective_chat.id, error_message.message_id),
            3
        )
        # 清理上下文数据
        _clear_delete_context(context)
        return
    
    # 获取原始邮件消息ID
    origin_message_id = None
    if "delete_origin_message_id" in context.user_data:
        origin_message_id = context.user_data["delete_origin_message_id"]
    
    # 获取附件消息ID列表
    attachment_message_ids = get_attachment_telegram_ids(email_id)
    
    # 连接到IMAP服务器并删除邮件
    imap_delete_success = False
    client = IMAPClient(account=account)
    if await client.connect():
        try:
            # 尝试先在收件箱中查找
            if await client.select_mailbox():
                message_nums = await client.search_by_message_id(email.message_id)
                if message_nums:
                    # 删除邮件
                    imap_delete_success = await client.delete_message(message_nums[0])
                else:
                    # 如果在收件箱中找不到，尝试在已发送文件夹中查找
                    if await client.select_mailbox('sent'):
                        message_nums = await client.search_by_message_id(email.message_id)
                        if message_nums:
                            # 删除已发送邮件
                            imap_delete_success = await client.delete_message(message_nums[0])
        except Exception as e:
            logger.error(f"IMAP删除邮件时发生错误: {e}")
        finally:
            client.disconnect()
    
    # 无论IMAP操作是否成功，都在数据库中标记为已删除
    success = delete_email(email_id)
    
    if success:
        # 删除原始Telegram消息（不显示任何提示，直接删除）
        if origin_message_id:
            try:
                await context.bot.delete_message(
                    chat_id=update.effective_chat.id,
                    message_id=origin_message_id
                )
            except Exception as e:
                logger.error(f"删除原始消息失败: {e}")
        
        # 删除附件消息
        for msg_id in attachment_message_ids:
            try:
                await context.bot.delete_message(
                    chat_id=update.effective_chat.id,
                    message_id=int(msg_id)
                )
            except Exception as e:
                logger.error(f"删除附件消息失败 (ID: {msg_id}): {e}")
        
        # 显示成功消息
        success_message = await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"✅ 邮件 \"{html.escape(email.subject)}\" 已成功删除。",
            reply_markup=ReplyKeyboardRemove(),
            disable_notification=True
        )
        # 3秒后自动删除成功消息
        context.job_queue.run_once(
            lambda job_context: delete_message(job_context, update.effective_chat.id, success_message.message_id),
            3
        )
    else:
        # 只有在出错时才显示消息
        error_message = await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="❌ 删除邮件时发生错误，请重试。",
            reply_markup=ReplyKeyboardRemove(),
            disable_notification=True
        )
        # 3秒后自动删除错误消息
        context.job_queue.run_once(
            lambda job_context: delete_message(job_context, update.effective_chat.id, error_message.message_id),
            3
        )
    
    # 清理上下文数据
    _clear_delete_context(context)

def _clear_delete_context(context: ContextTypes.DEFAULT_TYPE):
    """清理删除邮件相关的上下文数据"""
    if "delete_email_id" in context.user_data:
        del context.user_data["delete_email_id"]
    if "delete_origin_message_id" in context.user_data:
        del context.user_data["delete_origin_message_id"]
    if "delete_confirm_message_id" in context.user_data:
        del context.user_data["delete_confirm_message_id"] 

# 创建新邮件的会话状态
SELECTING_ACCOUNT, ENTER_SUBJECT, ENTER_RECIPIENTS, ENTER_CC, ENTER_BCC, ENTER_BODY, ADD_ATTACHMENTS = range(7)

# 回复邮件的会话状态
REPLY_ENTER_RECIPIENTS, REPLY_ENTER_CC, REPLY_ENTER_BCC, REPLY_ENTER_BODY, REPLY_ADD_ATTACHMENTS = range(7, 12)

async def compose_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    处理 /compose 命令 - 启动新邮件创建对话
    """
    user_id = update.effective_chat.id
    
    # 获取用户的所有邮箱账户
    accounts = AccountOperations.get_all_active_accounts()
    
    if not accounts:
        await update.message.reply_text(
            "⚠️ 您还没有添加任何邮箱账户。请先使用 /addaccount 命令添加一个邮箱账户。",
            disable_notification=True
        )
        return ConversationHandler.END
    
    # 创建优化后的ReplyKeyboardMarkup让用户选择一个账户
    keyboard = []
    # 每行放置两个账户，提高布局美观度
    for i in range(0, len(accounts), 2):
        row = []
        row.append(accounts[i].email)
        if i + 1 < len(accounts):
            row.append(accounts[i + 1].email)
        keyboard.append(row)
    
    # 单独一行放置取消按钮
    keyboard.append(["❌ 取消"])
    
    reply_markup = ReplyKeyboardMarkup(
        keyboard, 
        one_time_keyboard=True,
        resize_keyboard=True,
        input_field_placeholder="选择一个邮箱账户"
    )
    
    # 存储当前会话的消息ID，以便后续清理
    context.user_data["compose_messages"] = []
    
    # 发送选择账号的消息
    message = await update.message.reply_text(
        "📧 请选择要使用的发送邮箱：",
        reply_markup=reply_markup,
        disable_notification=True
    )
    
    # 记录消息ID以便后续清理
    context.user_data["compose_messages"].append(message.message_id)
    context.user_data["compose_messages"].append(update.message.message_id)  # 记录用户的命令消息
    
    return SELECTING_ACCOUNT

async def select_account(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """处理用户选择的邮箱账户"""
    user_input = update.message.text
    chat_id = update.effective_chat.id
    
    # 检查用户是否取消操作
    if user_input.lower() == "/cancel" or user_input == "❌ 取消":
        await cancel_compose(update, context)
        return ConversationHandler.END
    
    # 保存用户消息ID以便后续清理
    context.user_data["compose_messages"].append(update.message.message_id)
    
    # 验证选择的邮箱是否存在
    account = AccountOperations.get_account_by_email(user_input)
    if not account:
        message = await update.message.reply_text(
            "⚠️ 未找到此邮箱账户，请重新选择或使用 /cancel 取消操作。",
            reply_markup=ForceReply(selective=True),
            disable_notification=True
        )
        context.user_data["compose_messages"].append(message.message_id)
        return SELECTING_ACCOUNT
    
    # 存储选定的账户信息
    context.user_data["compose_account_id"] = account.id
    context.user_data["compose_account_email"] = account.email
    
    # 提示用户输入邮件主题
    message = await update.message.reply_text(
        "✏️ 请输入邮件主题：\n(使用 /cancel 取消操作)",
        reply_markup=ForceReply(selective=True),
        disable_notification=True
    )
    context.user_data["compose_messages"].append(message.message_id)
    
    return ENTER_SUBJECT

async def enter_subject(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """处理用户输入的邮件主题"""
    user_input = update.message.text
    chat_id = update.effective_chat.id
    
    # 检查用户是否取消操作
    if user_input.lower() == "/cancel":
        # 取消时一次性清理所有消息
        await cancel_compose(update, context)
        return ConversationHandler.END
    
    # 保存用户消息ID以便后续清理
    context.user_data["compose_messages"].append(update.message.message_id)
    
    # 存储邮件主题
    context.user_data["compose_subject"] = user_input
    
    # 提示用户输入收件人
    message = await update.message.reply_text(
        "👥 请输入收件人邮箱地址：\n"
        "- 多个收件人请用逗号分隔\n"
        "- 使用 /cancel 取消操作",
        reply_markup=ForceReply(selective=True),
        disable_notification=True
    )
    context.user_data["compose_messages"].append(message.message_id)
    
    return ENTER_RECIPIENTS

async def enter_recipients(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """处理用户输入的收件人"""
    user_input = update.message.text
    chat_id = update.effective_chat.id
    
    # 检查用户是否取消操作
    if user_input.lower() == "/cancel":
        # 取消时一次性清理所有消息
        await cancel_compose(update, context)
        return ConversationHandler.END
    
    # 保存用户消息ID以便后续清理
    context.user_data["compose_messages"].append(update.message.message_id)
    
    # 处理收件人列表
    recipients = [email.strip() for email in user_input.split(",") if email.strip()]
    
    # 验证邮箱格式
    invalid_emails = []
    for email in recipients:
        # 简单验证邮箱格式
        if "@" not in email or "." not in email.split("@")[1]:
            invalid_emails.append(email)
    
    if invalid_emails:
        message = await update.message.reply_text(
            f"⚠️ 以下邮箱格式无效，请重新输入：\n"
            f"{', '.join(invalid_emails)}\n\n"
            f"请重新输入所有收件人：",
            reply_markup=ForceReply(selective=True),
            disable_notification=True
        )
        context.user_data["compose_messages"].append(message.message_id)
        return ENTER_RECIPIENTS
    
    # 存储收件人列表
    context.user_data["compose_recipients"] = recipients
    
    # 提示用户输入抄送(CC)列表
    message = await update.message.reply_text(
        "📋 请输入抄送(CC)列表：\n"
        "- 多个地址请用逗号分隔\n"
        "- 如果没有，请直接回复 '-' 或 '无'\n"
        "- 使用 /cancel 取消操作",
        reply_markup=ForceReply(selective=True),
        disable_notification=True
    )
    context.user_data["compose_messages"].append(message.message_id)
    
    return ENTER_CC

async def enter_cc(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """处理用户输入的抄送列表"""
    user_input = update.message.text
    chat_id = update.effective_chat.id
    
    # 检查用户是否取消操作
    if user_input.lower() == "/cancel":
        # 取消时一次性清理所有消息
        await cancel_compose(update, context)
        return ConversationHandler.END
    
    # 保存用户消息ID以便后续清理
    context.user_data["compose_messages"].append(update.message.message_id)
    
    cc_list = []
    
    # 检查是否为空
    if user_input.strip() and user_input.strip() not in ["-", "无"]:
        # 处理抄送列表
        cc_list = [email.strip() for email in user_input.split(",") if email.strip()]
        
        # 验证邮箱格式
        invalid_emails = []
        for email in cc_list:
            # 简单验证邮箱格式
            if "@" not in email or "." not in email.split("@")[1]:
                invalid_emails.append(email)
        
        if invalid_emails:
            message = await update.message.reply_text(
                f"⚠️ 以下邮箱格式无效，请重新输入：\n"
                f"{', '.join(invalid_emails)}\n\n"
                f"请重新输入所有抄送地址：",
                reply_markup=ForceReply(selective=True),
                disable_notification=True
            )
            context.user_data["compose_messages"].append(message.message_id)
            return ENTER_CC
    
    # 存储抄送列表
    context.user_data["compose_cc"] = cc_list
    
    # 提示用户输入密送(BCC)列表
    message = await update.message.reply_text(
        "🔒 请输入密送(BCC)列表：\n"
        "- 多个地址请用逗号分隔\n"
        "- 如果没有，请直接回复 '-' 或 '无'\n"
        "- 使用 /cancel 取消操作",
        reply_markup=ForceReply(selective=True),
        disable_notification=True
    )
    context.user_data["compose_messages"].append(message.message_id)
    
    return ENTER_BCC

async def enter_bcc(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """处理用户输入的密送列表"""
    user_input = update.message.text
    chat_id = update.effective_chat.id
    
    # 检查用户是否取消操作
    if user_input.lower() == "/cancel":
        # 取消时一次性清理所有消息
        await cancel_compose(update, context)
        return ConversationHandler.END
    
    # 保存用户消息ID以便后续清理
    context.user_data["compose_messages"].append(update.message.message_id)
    
    bcc_list = []
    
    # 检查是否为空
    if user_input.strip() and user_input.strip() not in ["-", "无"]:
        # 处理密送列表
        bcc_list = [email.strip() for email in user_input.split(",") if email.strip()]
        
        # 验证邮箱格式
        invalid_emails = []
        for email in bcc_list:
            # 简单验证邮箱格式
            if "@" not in email or "." not in email.split("@")[1]:
                invalid_emails.append(email)
        
        if invalid_emails:
            message = await update.message.reply_text(
                f"⚠️ 以下邮箱格式无效，请重新输入：\n"
                f"{', '.join(invalid_emails)}\n\n"
                f"请重新输入所有密送地址：",
                reply_markup=ForceReply(selective=True),
                disable_notification=True
            )
            context.user_data["compose_messages"].append(message.message_id)
            return ENTER_BCC
    
    # 存储密送列表
    context.user_data["compose_bcc"] = bcc_list
    
    # 提示用户输入邮件正文，支持Markdown
    keyboard = [["❌ 取消"]]
    reply_markup = ReplyKeyboardMarkup(
        keyboard, 
        one_time_keyboard=True,
        resize_keyboard=True
    )
    
    message = await update.message.reply_text(
        "✍️ 请输入邮件正文：\n\n"
        "📝 支持Markdown格式：\n"
        "• 斜体：*文本*\n"
        "• 链接：[文本](URL)\n"
        "• 标题：# 标题1, ## 标题2\n"
        "• 有序列表：1. 项目1\n"
        "• 无序列表：- 项目或* 项目\n"
        "• 引用：> 引用文本\n\n"
        "⚠️ 特殊格式标记（Telegram会渲染常规标记导致格式丢失）：\n"
        "• 加粗：\\*\\*文本\\*\\*\n"
        "• 内联代码：\\`代码\\`\n"
        "• 代码块：\n\\`\\`\\`\n代码块\n\\`\\`\\`\n\n"
        "💡 提示：使用上述带转义符号的格式，系统会自动处理成正确的格式发送\n\n"
        "📌 确保空行正确以保持段落格式",
        reply_markup=reply_markup,
        disable_notification=True
    )
    context.user_data["compose_messages"].append(message.message_id)
    
    return ENTER_BODY

async def enter_body(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """处理用户输入的邮件正文"""
    user_input = update.message.text
    chat_id = update.effective_chat.id
    
    # 检查用户是否取消操作
    if user_input.lower() == "/cancel" or user_input == "❌ 取消":
        # 取消时一次性清理所有消息
        await cancel_compose(update, context)
        return ConversationHandler.END
    
    # 保存用户消息ID以便后续清理
    context.user_data["compose_messages"].append(update.message.message_id)
    
    # 存储邮件正文
    context.user_data["compose_body"] = user_input
    
    # 提示用户添加附件
    keyboard = [
        ["✅ 发送邮件（无附件）"],
        ["📎 添加附件"],
        ["❌ 取消"]
    ]
    reply_markup = ReplyKeyboardMarkup(
        keyboard, 
        one_time_keyboard=True,
        resize_keyboard=True
    )
    
    message = await update.message.reply_text(
        """📩 您的邮件已准备就绪!

您可以选择直接发送邮件，或者添加附件后发送。

📎 若要添加附件，请点击"添加附件"按钮，然后上传文件。
✅ 若不需要附件，请点击"发送邮件(无附件)"按钮。
❌ 若要取消发送，请点击"取消"按钮。""",
        reply_markup=reply_markup,
        disable_notification=True
    )
    context.user_data["compose_messages"].append(message.message_id)
    
    # 初始化附件列表
    if "compose_attachments" not in context.user_data:
        context.user_data["compose_attachments"] = []
    
    return ADD_ATTACHMENTS

async def handle_attachments(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """处理用户选择的附件操作"""
    chat_id = update.effective_chat.id
    
    # 保存用户消息ID以便后续清理
    context.user_data["compose_messages"].append(update.message.message_id)
    
    # 初始化附件列表（如果不存在）
    if "compose_attachments" not in context.user_data:
        context.user_data["compose_attachments"] = []
    
    # 判断是否为媒体消息
    is_media = (update.message.document or update.message.photo or 
                hasattr(update.message, 'media_group_id') and update.message.media_group_id)
    
    # 处理媒体（文档、照片等）
    if is_media:
        # 检查是否是媒体组（多个文件）
        is_media_group = hasattr(update.message, 'media_group_id') and update.message.media_group_id
        
        # 显示处理中状态消息
        processing_msg = None
        if is_media_group:
            processing_msg = await update.message.reply_text(
                "📎 正在处理多个附件，请稍候...",
                disable_notification=True
            )
            context.user_data["compose_messages"].append(processing_msg.message_id)
        
        added_files = []
        
        # 处理文档
        if update.message.document:
            document = update.message.document
            file_name = document.file_name
            file_id = document.file_id
            mime_type = document.mime_type or "application/octet-stream"
            
            # 下载文件
            file = await context.bot.get_file(file_id)
            file_bytes = await file.download_as_bytearray()
            
            # 将附件添加到列表
            attachment = {
                'filename': file_name,
                'content': file_bytes,
                'content_type': mime_type
            }
            
            context.user_data["compose_attachments"].append(attachment)
            added_files.append(file_name)
        
        # 处理照片
        elif update.message.photo:
            # 获取最大尺寸的照片
            photo = update.message.photo[-1]
            file_id = photo.file_id
            
            # 生成文件名 (照片没有原始文件名)
            current_time = datetime.now().strftime("%Y%m%d_%H%M%S")
            file_name = f"photo_{current_time}.jpg"
            
            # 下载文件
            file = await context.bot.get_file(file_id)
            file_bytes = await file.download_as_bytearray()
            
            # 将附件添加到列表
            attachment = {
                'filename': file_name,
                'content': file_bytes,
                'content_type': 'image/jpeg'
            }
            
            context.user_data["compose_attachments"].append(attachment)
            added_files.append(file_name)
        
        # 如果是媒体组，需要等待所有文件都处理完再响应
        # 这里我们通过检查媒体组ID来确定是否是媒体组的最后一个文件
        if is_media_group:
            # 存储当前媒体组ID到上下文
            media_group_id = update.message.media_group_id
            
            # 如果第一次遇到这个媒体组，初始化计数器和定时器
            if "current_media_group" not in context.user_data:
                context.user_data["current_media_group"] = {
                    "id": media_group_id,
                    "processed_count": 1,
                    "files": [file_name],  # 记录已处理的文件
                    "last_update_time": datetime.now(),  # 记录最后更新时间
                    "completion_task": None  # 完成检测任务
                }
                
                # 创建定时任务来检测处理完成
                completion_task = asyncio.create_task(
                    _check_media_group_completion(update, context, chat_id, media_group_id, processing_msg)
                )
                context.user_data["current_media_group"]["completion_task"] = completion_task
                
            elif context.user_data["current_media_group"]["id"] == media_group_id:
                # 增加已处理计数并记录文件
                context.user_data["current_media_group"]["processed_count"] += 1
                context.user_data["current_media_group"]["files"].append(file_name)
                context.user_data["current_media_group"]["last_update_time"] = datetime.now()
                
                # 更新处理状态消息
                if processing_msg:
                    try:
                        await processing_msg.edit_text(
                            f"📎 已处理 {context.user_data['current_media_group']['processed_count']} 个附件，请稍候..."
                        )
                    except Exception as e:
                        logger.error(f"更新处理状态消息失败: {e}")
            else:
                # 如果是新的媒体组，取消旧的完成检测任务
                old_task = context.user_data["current_media_group"].get("completion_task")
                if old_task and not old_task.done():
                    old_task.cancel()
                    
                # 重置为新的媒体组
                context.user_data["current_media_group"] = {
                    "id": media_group_id,
                    "processed_count": 1,
                    "files": [file_name],
                    "last_update_time": datetime.now(),
                    "completion_task": None
                }
                
                # 创建新的完成检测任务
                completion_task = asyncio.create_task(
                    _check_media_group_completion(update, context, chat_id, media_group_id, processing_msg)
                )
                context.user_data["current_media_group"]["completion_task"] = completion_task
            
            # 继续处理其他附件，不立即显示选项
            return ADD_ATTACHMENTS
        
        # 显示当前附件列表
        attachment_names = [att['filename'] for att in context.user_data["compose_attachments"]]
        attachment_list = "\n".join([f"- {name}" for name in attachment_names])
        
        # 创建键盘提供继续选项
        keyboard = [
            ["✅ 发送邮件"],
            ["📎 添加更多附件"],
            ["❌ 取消"]
        ]
        reply_markup = ReplyKeyboardMarkup(
            keyboard, 
            one_time_keyboard=True,
            resize_keyboard=True
        )
        
        # 显示消息
        if len(added_files) == 1:
            message_text = f"""✅ 已添加附件：{added_files[0]}

当前附件列表({len(attachment_names)}个)：
{attachment_list}

您可以：
📎 继续添加更多附件
✅ 发送带有当前附件的邮件
❌ 取消发送"""
        else:
            message_text = f"""✅ 已添加新附件

当前附件列表({len(attachment_names)}个)：
{attachment_list}

您可以：
📎 继续添加更多附件
✅ 发送带有当前附件的邮件
❌ 取消发送"""
        
        # 如果有处理状态消息，先删除它
        if processing_msg:
            try:
                await context.bot.delete_message(chat_id=chat_id, message_id=processing_msg.message_id)
                # 从记录列表中移除，避免后续重复删除
                if processing_msg.message_id in context.user_data["compose_messages"]:
                    context.user_data["compose_messages"].remove(processing_msg.message_id)
            except Exception as e:
                logger.error(f"删除处理状态消息失败: {e}")
        
        message = await update.message.reply_text(
            message_text,
            reply_markup=reply_markup,
            disable_notification=True
        )
        context.user_data["compose_messages"].append(message.message_id)
        
        # 清理媒体组状态
        if "current_media_group" in context.user_data:
            del context.user_data["current_media_group"]
        
        return ADD_ATTACHMENTS
    
    # 处理文本消息
    if update.message.text:
        user_input = update.message.text
        
        # 检查用户是否取消操作
        if user_input.lower() == "/cancel" or user_input == "❌ 取消":
            # 取消时一次性清理所有消息
            await cancel_compose(update, context)
            return ConversationHandler.END
        
        # 用户选择发送邮件（无附件）
        if user_input == "✅ 发送邮件（无附件）":
            # 发送邮件
            await send_composed_email(update, context)
            return ConversationHandler.END
        
        # 用户选择添加附件
        if user_input == "📎 添加附件" or user_input == "📎 添加更多附件":
            keyboard = [["❌ 取消"]]
            reply_markup = ReplyKeyboardMarkup(
                keyboard, 
                one_time_keyboard=True,
                resize_keyboard=True
            )
            
            message = await update.message.reply_text(
                """📎 请上传您想要添加的附件文件。

⚠️ 您可以一次上传单个文件或多个文件。上传后，您可以继续添加更多附件或发送邮件。

支持的文件类型：文档、图片、音频、视频等。
最大文件大小：50MB（受Telegram限制）""",
                reply_markup=reply_markup,
                disable_notification=True
            )
            context.user_data["compose_messages"].append(message.message_id)
            
            # 保持在同一状态，等待文件上传
            return ADD_ATTACHMENTS
        
        # 用户选择发送带附件的邮件
        if user_input == "✅ 发送邮件":
            # 发送邮件
            await send_composed_email(update, context)
            return ConversationHandler.END
        
        # 如果是其他消息，提示用户上传文件
        message = await update.message.reply_text(
            "⚠️ 请上传文件作为附件，或从下方键盘选择操作。",
            reply_markup=update.message.reply_markup,
            disable_notification=True
        )
        context.user_data["compose_messages"].append(message.message_id)
    
    return ADD_ATTACHMENTS

async def send_composed_email(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """发送已创建的邮件"""
    chat_id = update.effective_chat.id
    
    # 获取账户信息
    account_id = context.user_data.get("compose_account_id")
    account = get_email_account_by_id(account_id)
    
    if not account:
        await update.message.reply_text(
            "⚠️ 发送邮件时出现错误：无法获取邮箱账户信息。",
            reply_markup=ReplyKeyboardRemove(),
            disable_notification=True
        )
        # 清理所有消息
        await clean_compose_messages(context, chat_id)
        return
    
    # 获取邮件信息
    subject = context.user_data.get("compose_subject", "无主题")
    recipients = context.user_data.get("compose_recipients", [])
    cc_list = context.user_data.get("compose_cc", [])
    bcc_list = context.user_data.get("compose_bcc", [])
    body_markdown = context.user_data.get("compose_body", "")
    attachments = context.user_data.get("compose_attachments", [])
    
    # 显示发送状态 - 使用新消息而不是编辑
    status_msg = await update.message.reply_text(
        "📤 正在连接到邮件服务器...",
        reply_markup=ReplyKeyboardRemove(),
        disable_notification=True
    )
    # 记录状态消息以便后续清理
    context.user_data["compose_messages"].append(status_msg.message_id)
    
    # 转换Markdown为HTML，增强对Markdown的支持
    try:
        import markdown
        from markdown.extensions.extra import ExtraExtension
        from markdown.extensions.nl2br import Nl2BrExtension
        from markdown.extensions.sane_lists import SaneListExtension
        from markdown.extensions.fenced_code import FencedCodeExtension
        from markdown.extensions.codehilite import CodeHiliteExtension
        
        # 预处理Markdown内容，确保加粗和代码块正确处理
        # 首先移除转义符号，将用户输入的\*\*, \`, \`\`\`转换为实际的格式标记
        # 处理转义的加粗标记 \*\* -> **
        body_markdown = re.sub(r'\\\*\\\*', '**', body_markdown)
        # 处理转义的内联代码标记 \` -> `
        body_markdown = re.sub(r'\\`', '`', body_markdown)
        # 处理转义的代码块标记 \`\`\` -> ```
        body_markdown = re.sub(r'\\`\\`\\`', '```', body_markdown)
        
        html_body = markdown.markdown(
            body_markdown,
            extensions=[
                ExtraExtension(),          # 支持表格、脚注等
                Nl2BrExtension(),          # 将换行转换为<br>标签
                SaneListExtension(),        # 更好地处理列表
                FencedCodeExtension(),      # 支持代码块
                CodeHiliteExtension(       # 代码高亮
                    noclasses=True,         # 使用行内样式而非CSS类
                    pygments_style='default' # 使用默认高亮样式
                )
            ]
        )
        
        # 添加自定义CSS样式使邮件更美观
        styled_html = f"""
        <html>
        <head>
            <style>
                body {{ font-family: Arial, sans-serif; line-height: 1.6; color: #333; }}
                h1, h2, h3 {{ color: #2c3e50; }}
                a {{ color: #3498db; text-decoration: none; }}
                a:hover {{ text-decoration: underline; }}
                pre {{ background-color: #f8f8f8; padding: 10px; border-radius: 5px; margin: 15px 0; overflow: auto; }}
                code {{ background-color: #f8f8f8; padding: 2px 4px; border-radius: 3px; font-family: Consolas, Monaco, 'Andale Mono', monospace; }}
                strong {{ font-weight: bold; color: #000; }}
                blockquote {{ border-left: 4px solid #ccc; padding-left: 16px; margin-left: 0; color: #777; }}
                ul, ol {{ padding-left: 20px; }}
            </style>
        </head>
        <body>
            {html_body}
        </body>
        </html>
        """
    except ImportError as e:
        # 记录错误信息
        logger.error(f"Markdown转换错误: {e}")
        # 如果没有安装markdown扩展，使用基本的markdown或纯文本
        try:
            import markdown
            # 注意：移除可能破坏格式的处理
            # body_markdown = re.sub(r'([^\s])\*\*', r'\1 **', body_markdown)
            # body_markdown = re.sub(r'\*\*([^\s])', r'** \1', body_markdown)
            html_body = markdown.markdown(body_markdown)
            
            # 检查是否有加粗文本的标签
            has_bold_tags = '<strong>' in html_body
            logger.debug(f"备用处理 - HTML是否包含加粗标签: {has_bold_tags}")
            logger.debug(f"备用处理 - 生成的HTML内容: {html_body}")
        except ImportError:
            html_body = body_markdown.replace("\n", "<br>").replace("<", "&lt;").replace(">", "&gt;")
        
        styled_html = f"<html><body>{html_body}</body></html>"
    
    # 调试信息
    logger.debug(f"备用处理 - 预处理后Markdown: {body_markdown}")
    
    # 记录最终HTML内容
    logger.debug(f"备用处理 - 最终HTML内容前500字符: {styled_html[:500]}")
    
    # 发送邮件
    from app.email.smtp_client import SMTPClient
    import ssl
    
    smtp_client = SMTPClient(account=account)
    
    try:
        # 尝试连接到SMTP服务器
        connected = await smtp_client.connect()
        
        if not connected:
            final_msg = await update.message.reply_text(
                "⚠️ 连接到邮件服务器失败。\n\n"
                "可能的原因：\n"
                "1. 服务器地址或端口配置错误\n"
                "2. 网络连接问题\n"
                "3. 邮件服务器暂时不可用\n\n"
                "请稍后再试或检查邮箱设置。",
                disable_notification=True
            )
            context.user_data["compose_messages"].append(final_msg.message_id)
            
            # 设置延迟清理任务（3秒后）
            asyncio.create_task(
                delayed_clean_compose_messages(context, chat_id, 3)
            )
            return
        
        # 尝试发送邮件
        sending_msg = await update.message.reply_text("📤 正在发送邮件内容...", disable_notification=True)
        context.user_data["compose_messages"].append(sending_msg.message_id)
        
        # 如果有附件，显示正在处理附件的消息
        if attachments:
            attachment_msg = await update.message.reply_text(
                f"📎 正在处理 {len(attachments)} 个附件...",
                disable_notification=True
            )
            context.user_data["compose_messages"].append(attachment_msg.message_id)
        
        # 定义发送失败时的重试回调
        async def on_retry(retry_count, max_retries):
            # 更新发送消息，显示重试进度
            await sending_msg.edit_text(f"📤 正在发送邮件内容...\n\n🔄 第 {retry_count}/{max_retries} 次尝试")
        
        # 最多尝试3次发送
        max_retries = 3
        sent = False
        last_error = None
        
        # 执行发送操作，带重试
        for retry_count in range(1, max_retries + 1):
            if retry_count > 1:
                # 如果是重试，更新发送状态消息
                await on_retry(retry_count, max_retries)
            
            try:
                # 尝试发送邮件 - 不使用进度回调
                sent = await smtp_client.send_email(
                    from_addr=account.email,
                    to_addrs=recipients,
                    subject=subject,
                    text_body=body_markdown,
                    html_body=styled_html,
                    cc_addrs=cc_list if cc_list else None,
                    bcc_addrs=bcc_list if bcc_list else None,
                    attachments=attachments if attachments else None,
                    max_retries=1  # 每次只尝试一次，外层循环控制总重试次数
                )
                
                # 如果发送成功，跳出循环
                if sent:
                    break
            except ssl.SSLError as e:
                # 记录最后的错误
                last_error = e
                logger.error(f"SSL错误 (尝试 {retry_count}/{max_retries}): {e}")
                
                # 如果是最后一次尝试，不再继续
                if retry_count == max_retries:
                    break
                    
                # 等待短暂时间后重试
                await asyncio.sleep(1)
            except ConnectionRefusedError as e:
                # 记录最后的错误
                last_error = e
                logger.error(f"连接被拒绝 (尝试 {retry_count}/{max_retries}): {e}")
                
                # 如果是最后一次尝试，不再继续
                if retry_count == max_retries:
                    break
                    
                # 等待短暂时间后重试
                await asyncio.sleep(1)
            except Exception as e:
                # 记录最后的错误
                last_error = e
                logger.error(f"发送邮件时出现其他错误 (尝试 {retry_count}/{max_retries}): {e}")
                
                # 如果是最后一次尝试，不再继续
                if retry_count == max_retries:
                    break
                    
                # 等待短暂时间后重试
                await asyncio.sleep(1)
        
        if sent:
            # 成功发送
            success_msg_text = (
                f"✅ 邮件已成功发送！\n\n"
                f"📧 从: {account.email}\n"
                f"📋 主题: {subject}\n"
                f"👥 收件人: {', '.join(recipients)}"
            )
            
            if cc_list:
                success_msg_text += f"\n📝 抄送: {', '.join(cc_list)}"
            
            if bcc_list:
                success_msg_text += f"\n🔒 密送: {', '.join(bcc_list)}"
                
            if attachments:
                attachment_names = [att['filename'] for att in attachments]
                attachment_list = ", ".join(attachment_names)
                success_msg_text += f"\n📎 附件: {attachment_list}"
            
            success_msg = await update.message.reply_text(success_msg_text, disable_notification=True)
            context.user_data["compose_messages"].append(success_msg.message_id)
            
            # 尝试从IMAP获取最新发送的邮件并发送到Telegram
            try:
                from app.email.imap_client import IMAPClient
                from app.bot.notifications import send_sent_email_notification
                from app.database.operations import save_email_metadata
                
                # 创建IMAP客户端
                imap_client = IMAPClient(account=account)
                
                # 获取最新发送的邮件
                latest_sent_email = await imap_client.get_latest_sent_email()
                
                # 断开IMAP连接
                imap_client.disconnect()
                
                if latest_sent_email:
                    # 检查收件人是否匹配，确保获取的是刚刚发送的邮件
                    sent_recipients = set(r.lower().strip() for r in latest_sent_email.get('recipients', []))
                    current_recipients = set(r.lower().strip() for r in recipients)
                    
                    if sent_recipients and current_recipients and sent_recipients.intersection(current_recipients):
                        logger.info(f"找到匹配的已发送邮件，将发送到 Telegram")
                        
                        # 保存邮件元数据到数据库
                        email_id = save_email_metadata(account.id, latest_sent_email)
                        if email_id:
                            # 发送无声通知到Telegram
                            await send_sent_email_notification(context, account.id, latest_sent_email, email_id)
                            logger.info(f"已发送邮件通知已发送到Telegram，ID: {email_id}")
                        else:
                            logger.error("保存已发送邮件元数据失败")
                    else:
                        logger.warning(f"最新已发送邮件的收件人与当前发送不匹配，跳过通知")
                else:
                    logger.warning("未找到最新发送的邮件，无法发送通知")
            except Exception as e:
                logger.error(f"获取和发送已发送邮件通知时出错: {e}")
                logger.error(traceback.format_exc())
        else:
            # 发送失败，但没有特定异常
            fail_msg = await update.message.reply_text(
                f"⚠️ 发送邮件失败 (已尝试 {max_retries} 次)。\n\n"
                "可能的原因：\n"
                "1. 邮件服务器拒绝发送请求\n"
                "2. 连接中断\n"
                "3. 收件人地址无效\n\n"
                "请稍后再试。",
                disable_notification=True
            )
            context.user_data["compose_messages"].append(fail_msg.message_id)
    except Exception as e:
        # 处理其他未捕获的异常
        logger.error(f"发送邮件时出现未处理的异常: {e}")
        error_msg = await update.message.reply_text(f"⚠️ 发送邮件时出现意外错误：{str(e)}", disable_notification=True)
        context.user_data["compose_messages"].append(error_msg.message_id)
    finally:
        # 断开SMTP连接
        smtp_client.disconnect()
        
        # 设置延迟清理任务（3秒后）
        asyncio.create_task(
            delayed_clean_compose_messages(context, chat_id, 3)
        )
    
    # 清理会话数据
    if "compose_account_id" in context.user_data:
        del context.user_data["compose_account_id"]
    if "compose_account_email" in context.user_data:
        del context.user_data["compose_account_email"]
    if "compose_subject" in context.user_data:
        del context.user_data["compose_subject"]
    if "compose_recipients" in context.user_data:
        del context.user_data["compose_recipients"]
    if "compose_cc" in context.user_data:
        del context.user_data["compose_cc"]
    if "compose_bcc" in context.user_data:
        del context.user_data["compose_bcc"]
    if "compose_body" in context.user_data:
        del context.user_data["compose_body"]
    if "compose_attachments" in context.user_data:
        del context.user_data["compose_attachments"]

# 辅助函数：延迟清理邮件创建过程中的所有消息
async def delayed_clean_compose_messages(context, chat_id, delay=5):
    """延迟指定时间后清理所有邮件创建过程的消息"""
    await asyncio.sleep(delay)  # 等待指定的延迟时间
    await clean_compose_messages(context, chat_id)  # 清理所有消息

async def cancel_compose(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """取消创建邮件"""
    chat_id = update.effective_chat.id
    
    # 记录当前消息以便后续清理
    context.user_data["compose_messages"].append(update.message.message_id)
    
    # 发送取消确认消息
    cancel_msg = await update.message.reply_text(
        "❌ 已取消创建新邮件。",
        reply_markup=ReplyKeyboardRemove(),
        disable_notification=True
    )
    context.user_data["compose_messages"].append(cancel_msg.message_id)
    
    # 设置延迟清理任务（3秒后）
    asyncio.create_task(
        delayed_clean_compose_messages(context, chat_id, 3)
    )
    
    # 清理会话数据（但保留消息ID列表，延迟清理后会删除）
    if "compose_account_id" in context.user_data:
        del context.user_data["compose_account_id"]
    if "compose_account_email" in context.user_data:
        del context.user_data["compose_account_email"]
    if "compose_subject" in context.user_data:
        del context.user_data["compose_subject"]
    if "compose_recipients" in context.user_data:
        del context.user_data["compose_recipients"]
    if "compose_cc" in context.user_data:
        del context.user_data["compose_cc"]
    if "compose_bcc" in context.user_data:
        del context.user_data["compose_bcc"]
    if "compose_body" in context.user_data:
        del context.user_data["compose_body"]
    if "compose_attachments" in context.user_data:
        del context.user_data["compose_attachments"]
    
    return ConversationHandler.END

def handle_compose_conversation():
    """创建和配置新邮件会话处理器"""
    return ConversationHandler(
        entry_points=[CommandHandler("compose", compose_command)],
        states={
            SELECTING_ACCOUNT: [MessageHandler(filters.TEXT & ~filters.COMMAND, select_account)],
            ENTER_SUBJECT: [MessageHandler(filters.TEXT & ~filters.COMMAND, enter_subject)],
            ENTER_RECIPIENTS: [MessageHandler(filters.TEXT & ~filters.COMMAND, enter_recipients)],
            ENTER_CC: [MessageHandler(filters.TEXT & ~filters.COMMAND, enter_cc)],
            ENTER_BCC: [MessageHandler(filters.TEXT & ~filters.COMMAND, enter_bcc)],
            ENTER_BODY: [MessageHandler(filters.TEXT & ~filters.COMMAND, enter_body)],
            ADD_ATTACHMENTS: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_attachments),
                MessageHandler(filters.Document.ALL, handle_attachments),
                MessageHandler(filters.PHOTO, handle_attachments),
            ],
        },
        fallbacks=[CommandHandler("cancel", cancel_compose)],
        name="compose_conversation",
        persistent=False
    )

async def clean_compose_messages(context, chat_id):
    """清理新建邮件会话中的历史消息"""
    if "compose_messages" in context.user_data and context.user_data["compose_messages"]:
        try:
            # 使用delete_messages批量删除消息
            await context.bot.delete_messages(
                chat_id=chat_id,
                message_ids=context.user_data["compose_messages"]
            )
        except Exception as e:
            # 如果批量删除失败，回退到逐个删除
            logger.error(f"批量删除消息失败: {e}，尝试逐个删除")
            for msg_id in context.user_data["compose_messages"]:
                try:
                    await context.bot.delete_message(chat_id=chat_id, message_id=msg_id)
                except Exception as inner_e:
                    # 忽略无法删除的消息错误
                    logger.debug(f"无法删除消息 {msg_id}: {inner_e}")
        
        # 清空消息ID列表
        context.user_data["compose_messages"] = []

async def _check_media_group_completion(update, context, chat_id, media_group_id, processing_msg):
    """
    检查媒体组是否已完成处理并显示选项键盘
    
    通过等待一段时间并检查是否有新附件处理来判断是否所有附件都已接收
    """
    try:
        # 等待初始延迟
        await asyncio.sleep(2.0)
        
        # 记录初始计数
        initial_count = context.user_data["current_media_group"]["processed_count"]
        last_count = initial_count
        
        # 检查周期
        max_checks = 5  # 最多检查5次
        for i in range(max_checks):
            # 等待一段时间后检查计数是否有变化
            await asyncio.sleep(1.0)
            
            # 获取当前计数（如果媒体组信息已被删除，则说明处理已完成）
            if "current_media_group" not in context.user_data or context.user_data["current_media_group"]["id"] != media_group_id:
                return
                
            current_count = context.user_data["current_media_group"]["processed_count"]
            
            # 如果计数增加，表示还在接收附件
            if current_count > last_count:
                last_count = current_count
                continue
            
            # 如果计数没有变化，且已经检查了多次，认为所有附件都已接收
            if i >= 2:  # 至少检查3次才能确定
                logger.info(f"媒体组 {media_group_id} 所有附件似乎已接收完毕（共{current_count}个）")
                break
        
        # 所有附件处理完毕，显示选项键盘
        # 准备附件列表
        attachment_names = [att['filename'] for att in context.user_data.get("compose_attachments", [])]
        attachment_list = "\n".join([f"- {name}" for name in attachment_names])
        
        # 创建键盘
        keyboard = [
            ["✅ 发送邮件"],
            ["📎 添加更多附件"],
            ["❌ 取消"]
        ]
        reply_markup = ReplyKeyboardMarkup(
            keyboard, 
            one_time_keyboard=True,
            resize_keyboard=True
        )
        
        # 删除处理状态消息
        if processing_msg:
            try:
                await context.bot.delete_message(chat_id=chat_id, message_id=processing_msg.message_id)
                # 从记录列表中移除，避免后续重复删除
                if processing_msg.message_id in context.user_data.get("compose_messages", []):
                    context.user_data["compose_messages"].remove(processing_msg.message_id)
            except Exception as e:
                logger.error(f"删除处理状态消息失败: {e}")
        
        # 发送完成消息和选项
        completion_message = await update.message.reply_text(
            f"""✅ 已成功添加媒体组附件

当前附件列表({len(attachment_names)}个)：
{attachment_list}

您可以：
📎 继续添加更多附件
✅ 发送带有当前附件的邮件
❌ 取消发送""",
            reply_markup=reply_markup,
            disable_notification=True
        )
        
        # 记录完成消息ID
        if "compose_messages" in context.user_data:
            context.user_data["compose_messages"].append(completion_message.message_id)
        
        # 清理媒体组状态
        if "current_media_group" in context.user_data and context.user_data["current_media_group"]["id"] == media_group_id:
            del context.user_data["current_media_group"]
            
    except asyncio.CancelledError:
        # 任务被取消，什么都不做
        pass
    except Exception as e:
        logger.error(f"检查媒体组完成时出错: {e}")
        logger.error(traceback.format_exc())

async def handle_reply_recipients(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """处理回复邮件的收件人选择"""
    user_input = update.message.text
    chat_id = update.effective_chat.id
    
    # 保存用户消息ID以便后续清理
    context.user_data["reply_messages"].append(update.message.message_id)
    
    # 检查用户是否取消操作
    if user_input.lower() == "/cancel" or user_input == "❌ 取消":
        return await cancel_reply(update, context)
    
    # 使用默认收件人（原发件人）
    if user_input == "📤 使用默认收件人（原发件人）":
        # 已经在初始化时设置了默认收件人，直接继续
        message = await update.message.reply_text(
            "✅ 已设置默认收件人。请选择下一步操作：",
            reply_markup=ReplyKeyboardMarkup(
                [
                    ["👥 管理收件人列表"],
                    ["📋 管理抄送列表"],
                    ["🕶 管理密送列表"],
                    ["✅ 继续编写正文", "❌ 取消"]
                ],
                resize_keyboard=True,
                one_time_keyboard=True
            ),
            disable_notification=True
        )
        context.user_data["reply_messages"].append(message.message_id)
        return REPLY_ENTER_RECIPIENTS
    
    # 管理收件人列表
    elif user_input == "👥 管理收件人列表":
        # 准备候选收件人键盘
        keyboard = []
        recipients_candidates = context.user_data["reply_candidates"]["recipients"]
        
        # 添加已选择的收件人（如果有）
        current_recipients = context.user_data["reply_recipients"]
        if current_recipients:
            keyboard.append(["👤 当前收件人:"])
            for recipient in current_recipients:
                keyboard.append([f"❌ 移除: {recipient}"])
        
        # 添加候选收件人
        if recipients_candidates:
            keyboard.append(["👥 候选收件人:"])
            for candidate in recipients_candidates:
                if candidate not in current_recipients:
                    keyboard.append([f"➕ 添加: {candidate}"])
        
        # 添加操作按钮
        keyboard.append(["➕ 手动添加收件人"])
        keyboard.append(["✅ 完成", "❌ 取消"])
        
        reply_markup = ReplyKeyboardMarkup(
            keyboard,
            resize_keyboard=True,
            one_time_keyboard=True
        )
        
        message = await update.message.reply_text(
            "👥 <b>管理收件人列表</b>\n\n"
            "• 点击候选人可以将其添加到收件人列表\n"
            "• 点击现有收件人可以将其移除\n"
            "• 选择「手动添加收件人」可以输入新的邮箱地址\n"
            "• 完成后点击「完成」继续",
            parse_mode="HTML",
            reply_markup=reply_markup,
            disable_notification=True
        )
        
        context.user_data["reply_messages"].append(message.message_id)
        context.user_data["reply_recipients_state"] = "managing"
        return REPLY_ENTER_RECIPIENTS
    
    # 管理抄送列表
    elif user_input == "📋 管理抄送列表":
        # 准备候选抄送人键盘
        keyboard = []
        cc_candidates = context.user_data["reply_candidates"]["cc"]
        
        # 添加已选择的抄送人（如果有）
        current_cc = context.user_data["reply_cc"]
        if current_cc:
            keyboard.append(["👤 当前抄送:"])
            for cc in current_cc:
                keyboard.append([f"❌ 移除: {cc}"])
        
        # 添加候选抄送人
        if cc_candidates:
            keyboard.append(["👥 候选抄送:"])
            for candidate in cc_candidates:
                if candidate not in current_cc:
                    keyboard.append([f"➕ 添加: {candidate}"])
        
        # 添加操作按钮
        keyboard.append(["➕ 手动添加抄送"])
        keyboard.append(["✅ 完成", "❌ 取消"])
        
        reply_markup = ReplyKeyboardMarkup(
            keyboard,
            resize_keyboard=True,
            one_time_keyboard=True
        )
        
        message = await update.message.reply_text(
            "📋 <b>管理抄送列表</b>\n\n"
            "• 点击候选人可以将其添加到抄送列表\n"
            "• 点击现有抄送人可以将其移除\n"
            "• 选择「手动添加抄送」可以输入新的邮箱地址\n"
            "• 完成后点击「完成」继续",
            parse_mode="HTML",
            reply_markup=reply_markup,
            disable_notification=True
        )
        
        context.user_data["reply_messages"].append(message.message_id)
        context.user_data["reply_recipients_state"] = "managing_cc"
        return REPLY_ENTER_CC
    
    # 管理密送列表
    elif user_input == "🕶 管理密送列表":
        # 准备候选密送人键盘
        keyboard = []
        bcc_candidates = context.user_data["reply_candidates"]["bcc"]
        
        # 添加已选择的密送人（如果有）
        current_bcc = context.user_data["reply_bcc"]
        if current_bcc:
            keyboard.append(["👤 当前密送:"])
            for bcc in current_bcc:
                keyboard.append([f"❌ 移除: {bcc}"])
        
        # 添加候选密送人
        if bcc_candidates:
            keyboard.append(["👥 候选密送:"])
            for candidate in bcc_candidates:
                if candidate not in current_bcc:
                    keyboard.append([f"➕ 添加: {candidate}"])
        
        # 添加操作按钮
        keyboard.append(["➕ 手动添加密送"])
        keyboard.append(["✅ 完成", "❌ 取消"])
        
        reply_markup = ReplyKeyboardMarkup(
            keyboard,
            resize_keyboard=True,
            one_time_keyboard=True
        )
        
        message = await update.message.reply_text(
            "🕶 <b>管理密送列表</b>\n\n"
            "• 点击候选人可以将其添加到密送列表\n"
            "• 点击现有密送人可以将其移除\n"
            "• 选择「手动添加密送」可以输入新的邮箱地址\n"
            "• 完成后点击「完成」继续",
            parse_mode="HTML",
            reply_markup=reply_markup,
            disable_notification=True
        )
        
        context.user_data["reply_messages"].append(message.message_id)
        context.user_data["reply_recipients_state"] = "managing_bcc"
        return REPLY_ENTER_BCC
    
    # 继续编写正文
    elif user_input == "✅ 继续编写正文":
        # 检查是否至少有一个收件人
        if not context.user_data["reply_recipients"]:
            message = await update.message.reply_text(
                "⚠️ 请至少添加一个收件人后再继续。",
                reply_markup=ReplyKeyboardMarkup(
                    [["👥 管理收件人列表"], ["❌ 取消"]],
                    resize_keyboard=True,
                    one_time_keyboard=True
                ),
                disable_notification=True
            )
            context.user_data["reply_messages"].append(message.message_id)
            return REPLY_ENTER_RECIPIENTS
        
        # 进入正文编辑阶段
        return await prompt_reply_body(update, context)
    
    # 处理收件人管理状态下的输入
    elif context.user_data.get("reply_recipients_state") == "managing":
        # 手动添加收件人
        if user_input == "➕ 手动添加收件人":
            message = await update.message.reply_text(
                "✏️ 请输入收件人邮箱地址：\n"
                "- 多个收件人请用逗号分隔\n"
                "- 或输入 /cancel 取消操作",
                reply_markup=ForceReply(selective=True),
                disable_notification=True
            )
            context.user_data["reply_messages"].append(message.message_id)
            context.user_data["reply_recipients_state"] = "adding_manual"
            return REPLY_ENTER_RECIPIENTS
        
        # 完成收件人管理
        elif user_input == "✅ 完成":
            # 返回主菜单
            # 使用html.escape处理显示的收件人列表
            escaped_recipients = [html.escape(r) for r in context.user_data['reply_recipients']] if context.user_data['reply_recipients'] else []
            recipients_display = ", ".join(escaped_recipients)
            
            message = await update.message.reply_text(
                f"✅ 已设置收件人: {recipients_display}。\n请选择下一步操作：",
                reply_markup=ReplyKeyboardMarkup(
                    [
                        ["👥 管理收件人列表"],
                        ["📋 管理抄送列表"],
                        ["🕶 管理密送列表"],
                        ["✅ 继续编写正文", "❌ 取消"]
                    ],
                    resize_keyboard=True,
                    one_time_keyboard=True
                ),
                parse_mode="HTML",
                disable_notification=True
            )
            context.user_data["reply_messages"].append(message.message_id)
            context.user_data["reply_recipients_state"] = None
            return REPLY_ENTER_RECIPIENTS
        
        # 处理添加候选收件人
        elif user_input.startswith("➕ 添加:"):
            recipient = user_input[len("➕ 添加: "):]
            if recipient not in context.user_data["reply_recipients"]:
                context.user_data["reply_recipients"].append(recipient)
            
            # 刷新收件人管理键盘
            return await refresh_reply_recipients_keyboard(update, context)
        
        # 处理移除现有收件人
        elif user_input.startswith("❌ 移除:"):
            recipient = user_input[len("❌ 移除: "):]
            if recipient in context.user_data["reply_recipients"]:
                context.user_data["reply_recipients"].remove(recipient)
            
            # 刷新收件人管理键盘
            return await refresh_reply_recipients_keyboard(update, context)
    
    # 处理手动添加收件人状态下的输入
    elif context.user_data.get("reply_recipients_state") == "adding_manual":
        # 解析用户输入的收件人
        recipients = [r.strip() for r in user_input.split(",") if r.strip()]
        # 添加到收件人列表
        for recipient in recipients:
            if recipient not in context.user_data["reply_recipients"]:
                context.user_data["reply_recipients"].append(recipient)
        
        # 返回收件人管理界面
        context.user_data["reply_recipients_state"] = "managing"
        return await refresh_reply_recipients_keyboard(update, context)
    
    # 其他情况返回主菜单
    message = await update.message.reply_text(
        "⚠️ 未识别的选项。请从下方选择操作：",
        reply_markup=ReplyKeyboardMarkup(
            [
                ["👥 管理收件人列表"],
                ["📋 管理抄送列表"],
                ["🕶 管理密送列表"],
                ["✅ 继续编写正文", "❌ 取消"]
            ],
            resize_keyboard=True,
            one_time_keyboard=True
        ),
        disable_notification=True
    )
    context.user_data["reply_messages"].append(message.message_id)
    return REPLY_ENTER_RECIPIENTS

async def refresh_reply_recipients_keyboard(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """刷新回复邮件收件人管理的键盘"""
    # 准备收件人键盘
    keyboard = []
    recipients_candidates = context.user_data["reply_candidates"]["recipients"]
    
    # 添加已选择的收件人（如果有）
    current_recipients = context.user_data["reply_recipients"]
    if current_recipients:
        keyboard.append(["👤 当前收件人:"])
        for recipient in current_recipients:
            keyboard.append([f"❌ 移除: {recipient}"])
    
    # 添加候选收件人
    if recipients_candidates:
        keyboard.append(["👥 候选收件人:"])
        for candidate in recipients_candidates:
            if candidate not in current_recipients:
                keyboard.append([f"➕ 添加: {candidate}"])
    
    # 添加操作按钮
    keyboard.append(["➕ 手动添加收件人"])
    keyboard.append(["✅ 完成", "❌ 取消"])
    
    reply_markup = ReplyKeyboardMarkup(
        keyboard,
        resize_keyboard=True,
        one_time_keyboard=True
    )
    
    # 使用html.escape处理显示的收件人列表
    escaped_recipients = [html.escape(r) for r in current_recipients] if current_recipients else []
    recipients_display = ", ".join(escaped_recipients) if escaped_recipients else "无"
    
    message = await update.message.reply_text(
        f"👥 <b>收件人列表已更新</b>\n\n当前收件人: {recipients_display}\n\n"
        "• 点击候选人可以将其添加到收件人列表\n"
        "• 点击现有收件人可以将其移除\n"
        "• 选择「手动添加收件人」可以输入新的邮箱地址\n"
        "• 完成后点击「完成」继续",
        parse_mode="HTML",
        reply_markup=reply_markup,
        disable_notification=True
    )
    
    context.user_data["reply_messages"].append(message.message_id)
    return REPLY_ENTER_RECIPIENTS

async def handle_reply_cc(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """处理回复邮件的抄送列表"""
    user_input = update.message.text
    
    # 保存用户消息ID以便后续清理
    context.user_data["reply_messages"].append(update.message.message_id)
    
    # 检查用户是否取消操作
    if user_input.lower() == "/cancel" or user_input == "❌ 取消":
        return await cancel_reply(update, context)
    
    # 完成抄送管理
    if user_input == "✅ 完成":
        # 返回主菜单
        # 使用html.escape处理显示的抄送列表
        escaped_cc = [html.escape(cc) for cc in context.user_data['reply_cc']] if context.user_data['reply_cc'] else []
        cc_display = ", ".join(escaped_cc) if escaped_cc else '无'
        
        message = await update.message.reply_text(
            f"✅ 已设置抄送: {cc_display}。\n请选择下一步操作：",
            reply_markup=ReplyKeyboardMarkup(
                [
                    ["👥 管理收件人列表"],
                    ["📋 管理抄送列表"],
                    ["🕶 管理密送列表"],
                    ["✅ 继续编写正文", "❌ 取消"]
                ],
                resize_keyboard=True,
                one_time_keyboard=True
            ),
            parse_mode="HTML",
            disable_notification=True
        )
        context.user_data["reply_messages"].append(message.message_id)
        context.user_data["reply_recipients_state"] = None
        return REPLY_ENTER_RECIPIENTS
    
    # 手动添加抄送
    elif user_input == "➕ 手动添加抄送":
        message = await update.message.reply_text(
            "✏️ 请输入抄送邮箱地址：\n"
            "- 多个抄送地址请用逗号分隔\n"
            "- 或输入 /cancel 取消操作",
            reply_markup=ForceReply(selective=True),
            disable_notification=True
        )
        context.user_data["reply_messages"].append(message.message_id)
        context.user_data["reply_recipients_state"] = "adding_manual_cc"
        return REPLY_ENTER_CC
    
    # 处理添加候选抄送人
    elif user_input.startswith("➕ 添加:"):
        cc = user_input[len("➕ 添加: "):]
        if cc not in context.user_data["reply_cc"]:
            context.user_data["reply_cc"].append(cc)
        
        # 刷新抄送管理键盘
        return await refresh_reply_cc_keyboard(update, context)
    
    # 处理移除现有抄送人
    elif user_input.startswith("❌ 移除:"):
        cc = user_input[len("❌ 移除: "):]
        if cc in context.user_data["reply_cc"]:
            context.user_data["reply_cc"].remove(cc)
        
        # 刷新抄送管理键盘
        return await refresh_reply_cc_keyboard(update, context)
    
    # 处理手动添加抄送状态下的输入
    elif context.user_data.get("reply_recipients_state") == "adding_manual_cc":
        # 解析用户输入的抄送人
        cc_list = [cc.strip() for cc in user_input.split(",") if cc.strip()]
        # 添加到抄送人列表
        for cc in cc_list:
            if cc not in context.user_data["reply_cc"]:
                context.user_data["reply_cc"].append(cc)
        
        # 返回抄送管理界面
        context.user_data["reply_recipients_state"] = "managing_cc"
        return await refresh_reply_cc_keyboard(update, context)
    
    # 其他情况继续显示抄送管理键盘
    return await refresh_reply_cc_keyboard(update, context)

async def refresh_reply_cc_keyboard(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """刷新回复邮件抄送列表管理的键盘"""
    # 准备抄送键盘
    keyboard = []
    cc_candidates = context.user_data["reply_candidates"]["cc"]
    
    # 添加已选择的抄送人（如果有）
    current_cc = context.user_data["reply_cc"]
    if current_cc:
        keyboard.append(["👤 当前抄送:"])
        for cc in current_cc:
            keyboard.append([f"❌ 移除: {cc}"])
    
    # 添加候选抄送人
    if cc_candidates:
        keyboard.append(["👥 候选抄送:"])
        for candidate in cc_candidates:
            if candidate not in current_cc:
                keyboard.append([f"➕ 添加: {candidate}"])
    
    # 添加操作按钮
    keyboard.append(["➕ 手动添加抄送"])
    keyboard.append(["✅ 完成", "❌ 取消"])
    
    reply_markup = ReplyKeyboardMarkup(
        keyboard,
        resize_keyboard=True,
        one_time_keyboard=True
    )
    
    # 使用html.escape处理显示的抄送列表
    escaped_cc = [html.escape(cc) for cc in current_cc] if current_cc else []
    cc_display = ", ".join(escaped_cc) if escaped_cc else "无"
    
    message = await update.message.reply_text(
        f"📋 <b>抄送列表已更新</b>\n\n当前抄送: {cc_display}\n\n"
        "• 点击候选人可以将其添加到抄送列表\n"
        "• 点击现有抄送人可以将其移除\n"
        "• 选择「手动添加抄送」可以输入新的邮箱地址\n"
        "• 完成后点击「完成」继续",
        parse_mode="HTML",
        reply_markup=reply_markup,
        disable_notification=True
    )
    
    context.user_data["reply_messages"].append(message.message_id)
    return REPLY_ENTER_CC

async def handle_reply_bcc(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """处理回复邮件的密送列表"""
    user_input = update.message.text
    
    # 保存用户消息ID以便后续清理
    context.user_data["reply_messages"].append(update.message.message_id)
    
    # 检查用户是否取消操作
    if user_input.lower() == "/cancel" or user_input == "❌ 取消":
        return await cancel_reply(update, context)
    
    # 完成密送管理
    if user_input == "✅ 完成":
        # 返回主菜单
        # 使用html.escape处理显示的密送列表
        escaped_bcc = [html.escape(bcc) for bcc in context.user_data['reply_bcc']] if context.user_data['reply_bcc'] else []
        bcc_display = ", ".join(escaped_bcc) if escaped_bcc else '无'
        
        message = await update.message.reply_text(
            f"✅ 已设置密送: {bcc_display}。\n请选择下一步操作：",
            reply_markup=ReplyKeyboardMarkup(
                [
                    ["👥 管理收件人列表"],
                    ["📋 管理抄送列表"],
                    ["🕶 管理密送列表"],
                    ["✅ 继续编写正文", "❌ 取消"]
                ],
                resize_keyboard=True,
                one_time_keyboard=True
            ),
            parse_mode="HTML",
            disable_notification=True
        )
        context.user_data["reply_messages"].append(message.message_id)
        context.user_data["reply_recipients_state"] = None
        return REPLY_ENTER_RECIPIENTS
    
    # 手动添加密送
    elif user_input == "➕ 手动添加密送":
        message = await update.message.reply_text(
            "✏️ 请输入密送邮箱地址：\n"
            "- 多个密送地址请用逗号分隔\n"
            "- 或输入 /cancel 取消操作",
            reply_markup=ForceReply(selective=True),
            disable_notification=True
        )
        context.user_data["reply_messages"].append(message.message_id)
        context.user_data["reply_recipients_state"] = "adding_manual_bcc"
        return REPLY_ENTER_BCC
    
    # 处理添加候选密送人
    elif user_input.startswith("➕ 添加:"):
        bcc = user_input[len("➕ 添加: "):]
        if bcc not in context.user_data["reply_bcc"]:
            context.user_data["reply_bcc"].append(bcc)
        
        # 刷新密送管理键盘
        return await refresh_reply_bcc_keyboard(update, context)
    
    # 处理移除现有密送人
    elif user_input.startswith("❌ 移除:"):
        bcc = user_input[len("❌ 移除: "):]
        if bcc in context.user_data["reply_bcc"]:
            context.user_data["reply_bcc"].remove(bcc)
        
        # 刷新密送管理键盘
        return await refresh_reply_bcc_keyboard(update, context)
    
    # 处理手动添加密送状态下的输入
    elif context.user_data.get("reply_recipients_state") == "adding_manual_bcc":
        # 解析用户输入的密送人
        bcc_list = [bcc.strip() for bcc in user_input.split(",") if bcc.strip()]
        # 添加到密送人列表
        for bcc in bcc_list:
            if bcc not in context.user_data["reply_bcc"]:
                context.user_data["reply_bcc"].append(bcc)
        
        # 返回密送管理界面
        context.user_data["reply_recipients_state"] = "managing_bcc"
        return await refresh_reply_bcc_keyboard(update, context)
    
    # 其他情况继续显示密送管理键盘
    return await refresh_reply_bcc_keyboard(update, context)

async def refresh_reply_bcc_keyboard(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """刷新回复邮件密送列表管理的键盘"""
    # 准备密送键盘
    keyboard = []
    bcc_candidates = context.user_data["reply_candidates"]["bcc"]
    
    # 添加已选择的密送人（如果有）
    current_bcc = context.user_data["reply_bcc"]
    if current_bcc:
        keyboard.append(["👤 当前密送:"])
        for bcc in current_bcc:
            keyboard.append([f"❌ 移除: {bcc}"])
    
    # 添加候选密送人
    if bcc_candidates:
        keyboard.append(["👥 候选密送:"])
        for candidate in bcc_candidates:
            if candidate not in current_bcc:
                keyboard.append([f"➕ 添加: {candidate}"])
    
    # 添加操作按钮
    keyboard.append(["➕ 手动添加密送"])
    keyboard.append(["✅ 完成", "❌ 取消"])
    
    reply_markup = ReplyKeyboardMarkup(
        keyboard,
        resize_keyboard=True,
        one_time_keyboard=True
    )
    
    # 使用html.escape处理显示的密送列表
    escaped_bcc = [html.escape(bcc) for bcc in current_bcc] if current_bcc else []
    bcc_display = ", ".join(escaped_bcc) if escaped_bcc else "无"
    
    message = await update.message.reply_text(
        f"🕶 <b>密送列表已更新</b>\n\n当前密送: {bcc_display}\n\n"
        "• 点击候选人可以将其添加到密送列表\n"
        "• 点击现有密送人可以将其移除\n"
        "• 选择「手动添加密送」可以输入新的邮箱地址\n"
        "• 完成后点击「完成」继续",
        parse_mode="HTML",
        reply_markup=reply_markup,
        disable_notification=True
    )
    
    context.user_data["reply_messages"].append(message.message_id)
    return REPLY_ENTER_BCC

async def prompt_reply_body(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """提示用户输入回复邮件正文"""
    keyboard = [
        ["✅ 发送", "❌ 取消"]
    ]
    
    reply_markup = ReplyKeyboardMarkup(
        keyboard, 
        resize_keyboard=True,
        one_time_keyboard=True,
        input_field_placeholder="输入邮件正文..."
    )
    
    message = await update.message.reply_text(
        "✍️ 请输入邮件正文：\n\n"
        "📝 支持Markdown格式：\n"
        "• 斜体：*文本*\n"
        "• 链接：[文本](URL)\n"
        "• 标题：# 标题1, ## 标题2\n"
        "• 有序列表：1. 项目1\n"
        "• 无序列表：- 项目或* 项目\n"
        "• 引用：> 引用文本\n\n"
        "⚠️ 特殊格式标记（Telegram会渲染常规标记导致格式丢失）：\n"
        "• 加粗：\\*\\*文本\\*\\*\n"
        "• 内联代码：\\`代码\\`\n"
        "• 代码块：\n\\`\\`\\`\n代码块\n\\`\\`\\`\n\n"
        "💡 提示：使用上述带转义符号的格式，系统会自动处理成正确的格式发送\n\n"
        "📌 确保空行正确以保持段落格式",
        reply_markup=reply_markup,
        disable_notification=True
    )
    context.user_data["reply_messages"].append(message.message_id)
    
    return REPLY_ENTER_BODY

async def handle_reply_body(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """处理用户输入的回复邮件正文"""
    user_input = update.message.text
    chat_id = update.effective_chat.id
    
    # 保存用户消息ID以便后续清理
    context.user_data["reply_messages"].append(update.message.message_id)
    
    # 检查用户是否取消操作
    if user_input.lower() == "/cancel" or user_input == "❌ 取消":
        return await cancel_reply(update, context)
    
    # 存储邮件正文
    context.user_data["reply_body"] = user_input
    
    # 提示用户添加附件
    keyboard = [
        ["✅ 发送邮件（无附件）"],
        ["📎 添加附件"],
        ["❌ 取消"]
    ]
    reply_markup = ReplyKeyboardMarkup(
        keyboard, 
        one_time_keyboard=True,
        resize_keyboard=True
    )
    
    message = await update.message.reply_text(
        """📩 您的回复邮件已准备就绪!

您可以选择直接发送邮件，或者添加附件后发送。

📎 若要添加附件，请点击"添加附件"按钮，然后上传文件。
✅ 若不需要附件，请点击"发送邮件(无附件)"按钮。
❌ 若要取消发送，请点击"取消"按钮。""",
        reply_markup=reply_markup,
        disable_notification=True
    )
    context.user_data["reply_messages"].append(message.message_id)
    
    # 初始化附件列表
    if "reply_attachments" not in context.user_data:
        context.user_data["reply_attachments"] = []
    
    return REPLY_ADD_ATTACHMENTS

async def handle_reply_attachments(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """处理用户选择的附件操作（针对回复邮件）"""
    chat_id = update.effective_chat.id
    
    # 保存用户消息ID以便后续清理
    context.user_data["reply_messages"].append(update.message.message_id)
    
    # 初始化附件列表（如果不存在）
    if "reply_attachments" not in context.user_data:
        context.user_data["reply_attachments"] = []
    
    # 处理文本输入（按钮选择）
    if update.message.text:
        user_input = update.message.text
        
        # 处理按钮选择
        if user_input == "✅ 发送邮件（无附件）" or user_input == "✅ 发送邮件":
            # 发送邮件
            return await send_reply_email(update, context)
        
        elif user_input == "❌ 取消":
            # 取消发送
            return await cancel_reply(update, context)
        
        elif user_input == "📎 添加附件" or user_input == "📎 添加更多附件":
            # 提示用户上传文件
            message = await update.message.reply_text(
                "📎 请上传文件作为附件，或选择以下操作：",
                reply_markup=ReplyKeyboardMarkup(
                    [["✅ 完成添加", "❌ 取消"]],
                    resize_keyboard=True,
                    one_time_keyboard=True
                ),
                disable_notification=True
            )
            context.user_data["reply_messages"].append(message.message_id)
            return REPLY_ADD_ATTACHMENTS
        
        elif user_input == "✅ 完成添加":
            # 获取当前附件列表
            attachments = context.user_data.get("reply_attachments", [])
            
            if not attachments:
                # 如果没有附件，提示用户添加或继续
                message = await update.message.reply_text(
                    "⚠️ 您还没有添加任何附件。请上传文件或选择操作：",
                    reply_markup=ReplyKeyboardMarkup(
                        [["✅ 发送邮件（无附件）"], ["❌ 取消"]],
                        resize_keyboard=True,
                        one_time_keyboard=True
                    ),
                    disable_notification=True
                )
                context.user_data["reply_messages"].append(message.message_id)
                return REPLY_ADD_ATTACHMENTS
            
            # 显示当前附件列表
            attachment_names = [att['filename'] for att in attachments]
            attachment_list = "\n".join([f"- {name}" for name in attachment_names])
            
            # 创建键盘提供继续选项
            keyboard = [
                ["✅ 发送邮件"],
                ["📎 添加更多附件"],
                ["❌ 取消"]
            ]
            reply_markup = ReplyKeyboardMarkup(
                keyboard, 
                one_time_keyboard=True,
                resize_keyboard=True
            )
            
            message = await update.message.reply_text(
                f"""📩 您的回复邮件已准备就绪!

当前附件列表({len(attachment_names)}个)：
{attachment_list}

您可以：
📎 继续添加更多附件
✅ 发送带有当前附件的邮件
❌ 取消发送""",
                reply_markup=reply_markup,
                disable_notification=True
            )
            context.user_data["reply_messages"].append(message.message_id)
            return REPLY_ADD_ATTACHMENTS
    
    # 判断是否为媒体消息
    is_media = (update.message.document or update.message.photo or 
                hasattr(update.message, 'media_group_id') and update.message.media_group_id)
    
    # 处理媒体（文档、照片等）
    if is_media:
        # 检查是否是媒体组（多个文件）
        is_media_group = hasattr(update.message, 'media_group_id') and update.message.media_group_id
        
        # 显示处理中状态消息
        processing_msg = None
        if is_media_group:
            processing_msg = await update.message.reply_text(
                "📎 正在处理多个附件，请稍候...",
                disable_notification=True
            )
            context.user_data["reply_messages"].append(processing_msg.message_id)
        
        added_files = []
        
        # 处理文档
        if update.message.document:
            document = update.message.document
            file_name = document.file_name
            file_id = document.file_id
            mime_type = document.mime_type or "application/octet-stream"
            
            # 下载文件
            file = await context.bot.get_file(file_id)
            file_bytes = await file.download_as_bytearray()
            
            # 将附件添加到列表
            attachment = {
                'filename': file_name,
                'content': file_bytes,
                'content_type': mime_type
            }
            
            context.user_data["reply_attachments"].append(attachment)
            added_files.append(file_name)
        
        # 处理照片
        elif update.message.photo:
            # 获取最大尺寸的照片
            photo = update.message.photo[-1]
            file_id = photo.file_id
            
            # 生成文件名 (照片没有原始文件名)
            current_time = datetime.now().strftime("%Y%m%d_%H%M%S")
            file_name = f"photo_{current_time}.jpg"
            
            # 下载文件
            file = await context.bot.get_file(file_id)
            file_bytes = await file.download_as_bytearray()
            
            # 将附件添加到列表
            attachment = {
                'filename': file_name,
                'content': file_bytes,
                'content_type': 'image/jpeg'
            }
            
            context.user_data["reply_attachments"].append(attachment)
            added_files.append(file_name)
        
        # 如果是媒体组，需要处理媒体组完成的情况
        if is_media_group:
            # TODO: 实现类似于compose的媒体组处理逻辑
            # 这里简化处理，直接显示添加的文件
            # 在实际实现中应该与compose命令中的媒体组处理保持一致
            
            if processing_msg:
                try:
                    await context.bot.delete_message(chat_id=chat_id, message_id=processing_msg.message_id)
                    # 从记录列表中移除，避免后续重复删除
                    if processing_msg.message_id in context.user_data["reply_messages"]:
                        context.user_data["reply_messages"].remove(processing_msg.message_id)
                except Exception as e:
                    logger.error(f"删除处理状态消息失败: {e}")
        
        # 显示当前附件列表
        attachment_names = [att['filename'] for att in context.user_data["reply_attachments"]]
        attachment_list = "\n".join([f"- {name}" for name in attachment_names])
        
        # 创建键盘提供继续选项
        keyboard = [
            ["✅ 发送邮件"],
            ["📎 添加更多附件"],
            ["❌ 取消"]
        ]
        reply_markup = ReplyKeyboardMarkup(
            keyboard, 
            one_time_keyboard=True,
            resize_keyboard=True
        )
        
        # 显示消息
        if len(added_files) == 1:
            message_text = f"""✅ 已添加附件：{added_files[0]}

当前附件列表({len(attachment_names)}个)：
{attachment_list}

您可以：
📎 继续添加更多附件
✅ 发送带有当前附件的邮件
❌ 取消发送"""
        else:
            message_text = f"""✅ 已添加新附件

当前附件列表({len(attachment_names)}个)：
{attachment_list}

您可以：
📎 继续添加更多附件
✅ 发送带有当前附件的邮件
❌ 取消发送"""
        
        message = await update.message.reply_text(
            message_text,
            reply_markup=reply_markup,
            disable_notification=True
        )
        context.user_data["reply_messages"].append(message.message_id)
        
    return REPLY_ADD_ATTACHMENTS

async def send_reply_email(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """发送回复邮件"""
    # 获取聊天ID
    chat_id = update.effective_chat.id
    
    # 获取所有必要数据
    email_id = context.user_data.get("reply_email_id")
    account_id = context.user_data.get("reply_account_id")
    subject = context.user_data.get("reply_subject", "")
    recipients = context.user_data.get("reply_recipients", [])
    cc = context.user_data.get("reply_cc", [])
    bcc = context.user_data.get("reply_bcc", [])
    body = context.user_data.get("reply_body", "")
    attachments = context.user_data.get("reply_attachments", [])
    
    # 检查有没有收件人
    if not recipients:
        message = await update.message.reply_text(
            "⚠️ 请至少添加一个收件人",
            reply_markup=ReplyKeyboardMarkup(
                [["👥 管理收件人列表"], ["❌ 取消"]],
                resize_keyboard=True,
                one_time_keyboard=True
            ),
            disable_notification=True
        )
        context.user_data["reply_messages"].append(message.message_id)
        return REPLY_ENTER_RECIPIENTS
    
    # 获取回复的原始邮件，添加引用
    original_email = get_email_by_id(email_id)
    # 检查账户
    account = get_email_account_by_id(account_id)
    if not account:
        message = await update.message.reply_text(
            "⚠️ 邮箱账户不存在，无法发送",
            reply_markup=ReplyKeyboardRemove(),
            disable_notification=True
        )
        context.user_data["reply_messages"].append(message.message_id)
        return ConversationHandler.END
    
    # 显示正在发送的消息，并在界面上显示所有收件人
    # 使用html.escape处理所有显示的收件人、抄送、密送列表
    escaped_recipients = [html.escape(r) for r in recipients]
    escaped_cc = [html.escape(c) for c in cc] if cc else []
    escaped_bcc = [html.escape(b) for b in bcc] if bcc else []
    
    recipients_display = ", ".join(escaped_recipients)
    cc_display = ", ".join(escaped_cc) if escaped_cc else "无"
    bcc_display = ", ".join(escaped_bcc) if escaped_bcc else "无"
    
    send_message = await update.message.reply_text(
        f"🕒 <b>正在发送回复邮件...</b>\n\n"
        f"<b>从:</b> {html.escape(account.email)}\n"
        f"<b>主题:</b> {html.escape(subject)}\n"
        f"<b>收件人:</b> {recipients_display}\n"
        f"<b>抄送:</b> {cc_display}\n"
        f"<b>密送:</b> {bcc_display}\n"
        f"<b>附件:</b> {len(attachments)} 个\n\n"
        f"请稍候...",
        parse_mode="HTML",
        reply_markup=ReplyKeyboardRemove(),
        disable_notification=True
    )
    context.user_data["reply_messages"].append(send_message.message_id)
    
    try:
        # 创建SMTP客户端
        smtp_client = SMTPClient(
            server=account.smtp_server,
            port=account.smtp_port,
            username=account.username,
            password=account.password
        )
        
        # 构建回复引用
        quoted_body = f"\n\n-------- 原始邮件 --------\n发件人: {original_email.sender}\n日期: {original_email.date}\n主题: {original_email.subject}\n\n{original_email.text_content or original_email.html_content or '(邮件内容为空或不支持的格式)'}"
        
        # 完整回复内容
        full_reply = f"{body}{quoted_body}"
        
        # 创建HTML版本的回复内容
        # 将纯文本回复内容转换为HTML（处理换行符并转义HTML标签）
        html_body_content = html.escape(body).replace('\n', '<br>')
        
        # 创建HTML版本的引用内容
        html_quoted_content = ""
        if original_email.html_content:
            # 如果原邮件有HTML内容，使用原始HTML作为引用
            html_quoted_content = f"""
            <div style="margin-top:20px; border-top:1px solid #ddd; padding-top:10px;">
                <p style="color:#777;"><b>-------- 原始邮件 --------</b></p>
                <p><b>发件人:</b> {html.escape(original_email.sender)}</p>
                <p><b>日期:</b> {original_email.date}</p>
                <p><b>主题:</b> {html.escape(original_email.subject)}</p>
                <div style="margin-top:10px;">{original_email.html_content}</div>
            </div>
            """
        else:
            # 如果原邮件只有文本内容，将其转换为HTML
            original_content = original_email.text_content or '(邮件内容为空或不支持的格式)'
            html_original_content = html.escape(original_content).replace('\n', '<br>')
            html_quoted_content = f"""
            <div style="margin-top:20px; border-top:1px solid #ddd; padding-top:10px;">
                <p style="color:#777;"><b>-------- 原始邮件 --------</b></p>
                <p><b>发件人:</b> {html.escape(original_email.sender)}</p>
                <p><b>日期:</b> {original_email.date}</p>
                <p><b>主题:</b> {html.escape(original_email.subject)}</p>
                <div style="margin-top:10px; font-family:monospace;">{html_original_content}</div>
            </div>
            """
        
        # 完整HTML回复内容
        full_html_reply = f"""
        <div style="font-family:Arial, sans-serif; line-height:1.6;">
            <div>{html_body_content}</div>
            {html_quoted_content}
        </div>
        """
        
        # 发送邮件
        from_addr = account.email
        
        # 准备附件格式
        formatted_attachments = None
        if attachments:
            formatted_attachments = attachments
        
        # 使用SMTP客户端发送邮件
        success = await smtp_client.send_email(
            from_addr=from_addr,
            to_addrs=recipients,
            subject=subject,
            text_body=full_reply,
            html_body=full_html_reply,  # 添加HTML内容
            cc_addrs=cc,
            bcc_addrs=bcc,
            reply_to=account.email,
            attachments=formatted_attachments
        )
        
        if success:
            # 记录回复信息到数据库
            reply_id = add_reply_to_email(
                email_id=email_id,
                reply_text=body,
                reply_date=datetime.now(),
                sender=account.email
            )
            
            # 发送成功消息
            recipients_str = ", ".join(recipients)
            success_message = await update.message.reply_text(
                f"✅ 回复邮件已成功发送至 {recipients_str}",
                reply_markup=ReplyKeyboardRemove(),
                disable_notification=True
            )
            context.user_data["reply_messages"].append(success_message.message_id)
            
            # 尝试从IMAP获取最新发送的邮件并发送到Telegram
            try:
                from app.email.imap_client import IMAPClient
                from app.bot.notifications import send_sent_email_notification
                from app.database.operations import save_email_metadata
                
                # 创建IMAP客户端
                imap_client = IMAPClient(account=account)
                
                # 获取最新发送的邮件
                latest_sent_email = await imap_client.get_latest_sent_email()
                
                # 断开IMAP连接
                imap_client.disconnect()
                
                if latest_sent_email:
                    # 检查收件人是否匹配，确保获取的是刚刚发送的邮件
                    sent_recipients = set(r.lower().strip() for r in latest_sent_email.get('recipients', []))
                    current_recipients = set(r.lower().strip() for r in recipients)
                    
                    if sent_recipients and current_recipients and sent_recipients.intersection(current_recipients):
                        logger.info(f"找到匹配的已发送回复邮件，将发送到 Telegram")
                        
                        # 获取原始邮件的Telegram消息ID作为回复的目标
                        telegram_message_id = None
                        if original_email and hasattr(original_email, 'telegram_message_id') and original_email.telegram_message_id:
                            telegram_message_id = original_email.telegram_message_id
                            logger.info(f"找到原始邮件的Telegram消息ID: {telegram_message_id}")
                        
                        # 保存邮件元数据到数据库
                        email_id = save_email_metadata(account.id, latest_sent_email)
                        if email_id:
                            # 发送无声通知到Telegram
                            await send_sent_email_notification(
                                context, 
                                account.id, 
                                latest_sent_email, 
                                email_id,
                                telegram_message_id
                            )
                            logger.info(f"已回复邮件通知已发送到Telegram，ID: {email_id}")
                        else:
                            logger.error("保存已发送回复邮件元数据失败")
                    else:
                        logger.warning(f"最新已发送邮件的收件人与当前发送不匹配，跳过通知")
                else:
                    logger.warning("未找到最新发送的回复邮件，无法发送通知")
            except Exception as e:
                logger.error(f"获取和发送已回复邮件通知时出错: {e}")
                logger.error(traceback.format_exc())
        else:
            # 发送失败消息
            await send_message.edit_text(
                f"⚠️ 发送失败：SMTP服务器连接或发送出错",
                reply_markup=ReplyKeyboardMarkup(
                    [["🔄 重试", "❌ 取消"]],
                    resize_keyboard=True
                )
            )
            return REPLY_ADD_ATTACHMENTS
    
    except Exception as e:
        logger.error(f"回复邮件时出错: {str(e)}")
        logger.error(traceback.format_exc())
        
        # 发送失败消息
        await send_message.edit_text(
            f"⚠️ 发送失败：{str(e)}",
            reply_markup=ReplyKeyboardMarkup(
                [["🔄 重试", "❌ 取消"]],
                resize_keyboard=True
            )
        )
        return REPLY_ADD_ATTACHMENTS
    finally:
        # 设置延迟清理任务（3秒后）
        asyncio.create_task(
            delayed_clean_reply_messages(context, chat_id, 3)
        )
    
    # 清理会话数据
    cleanup_reply_data(context)
    
    return ConversationHandler.END

async def cancel_reply(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """取消回复邮件"""
    chat_id = update.effective_chat.id
    
    # 记录当前消息以便后续清理
    if "reply_messages" in context.user_data:
        context.user_data["reply_messages"].append(update.message.message_id)
    
    # 发送取消确认消息
    cancel_msg = await update.message.reply_text(
        "❌ 已取消回复邮件。",
        reply_markup=ReplyKeyboardRemove(),
        disable_notification=True
    )
    
    if "reply_messages" in context.user_data:
        context.user_data["reply_messages"].append(cancel_msg.message_id)
    
    # 设置延迟清理任务（3秒后）
    asyncio.create_task(
        delayed_clean_reply_messages(context, chat_id, 3)
    )
    
    # 清理会话数据
    cleanup_reply_data(context)
    
    return ConversationHandler.END

def cleanup_reply_data(context):
    """清理回复邮件的会话数据"""
    # 清理会话数据（但保留消息ID列表，延迟清理后会删除）
    keys_to_remove = [
        "reply_email_id", "reply_account_id", "reply_account_email",
        "reply_subject", "reply_recipients", "reply_cc", "reply_bcc",
        "reply_body", "reply_attachments", "reply_recipients_state", "reply_candidates",
        "reply_default_recipient", "reply_original_message_id"
    ]
    
    for key in keys_to_remove:
        if key in context.user_data:
            del context.user_data[key]

async def clean_reply_messages(context, chat_id):
    """清理回复邮件会话中的历史消息"""
    if "reply_messages" in context.user_data and context.user_data["reply_messages"]:
        try:
            # 使用delete_messages批量删除消息
            await context.bot.delete_messages(
                chat_id=chat_id,
                message_ids=context.user_data["reply_messages"]
            )
        except Exception as e:
            # 如果批量删除失败，回退到逐个删除
            logger.error(f"批量删除消息失败: {e}，尝试逐个删除")
            for msg_id in context.user_data["reply_messages"]:
                try:
                    await context.bot.delete_message(chat_id=chat_id, message_id=msg_id)
                except Exception as inner_e:
                    # 忽略无法删除的消息错误
                    logger.debug(f"无法删除消息 {msg_id}: {inner_e}")
        
        # 清空消息ID列表
        context.user_data["reply_messages"] = []

async def delayed_clean_reply_messages(context, chat_id, delay_seconds):
    """延迟清理回复邮件会话中的历史消息"""
    await asyncio.sleep(delay_seconds)
    await clean_reply_messages(context, chat_id)

async def delayed_delete_message(context, chat_id, message_id, delay_seconds):
    """延迟删除单个消息"""
    await asyncio.sleep(delay_seconds)
    try:
        await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
    except Exception as e:
        logger.debug(f"无法删除消息 {message_id}: {e}")

def handle_reply_conversation():
    """创建和配置回复邮件会话处理器"""
    return ConversationHandler(
        entry_points=[
            CallbackQueryHandler(
                lambda u, c: handle_reply_email(u, c, int(u.callback_query.data.split("_")[2])), 
                pattern="^reply_email_"
            ),
        ],
        states={
            REPLY_ENTER_RECIPIENTS: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_reply_recipients)],
            REPLY_ENTER_CC: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_reply_cc)],
            REPLY_ENTER_BCC: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_reply_bcc)],
            REPLY_ENTER_BODY: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_reply_body)],
            REPLY_ADD_ATTACHMENTS: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_reply_attachments),
                MessageHandler(filters.Document.ALL, handle_reply_attachments),
                MessageHandler(filters.PHOTO, handle_reply_attachments),
            ],
        },
        fallbacks=[CommandHandler("cancel", cancel_reply)],
        name="reply_conversation",
        persistent=False
    )