"""
Callback handlers for TelegramMail Bot.
"""
import logging
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply, InputMediaPhoto
from telegram.ext import ContextTypes
import html  # å¯¼å…¥htmlæ¨¡å—ä»¥ä½¿ç”¨escapeå‡½æ•°
import traceback
from typing import Dict, Any, List, Optional, Tuple, Union
import json
from datetime import datetime, timedelta
import asyncio  # å¯¼å…¥asyncioæ¨¡å—ç”¨äºå¼‚æ­¥å»¶è¿Ÿ
import ssl
import re
import os

from app.database.operations import (
    get_user_settings, update_user_settings,
    link_account_to_chat_id, get_all_active_accounts, 
    get_email_by_id, mark_email_as_read, delete_email, 
    AccountOperations, get_email_account_by_id, 
    MessageOperations, get_attachment_telegram_ids, add_reply_to_email
)
from app.email.imap_client import IMAPClient
from app.email.smtp_client import SMTPClient
from app.utils.config import config
from app.email.operations import EmailOperations

# é…ç½®æ—¥å¿—
logger = logging.getLogger(__name__)

async def handle_settings_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    å¤„ç†è®¾ç½®èœå•çš„å›è°ƒæŸ¥è¯¢
    """
    query = update.callback_query
    await query.answer()
    
    callback_data = query.data
    
    if callback_data == "settings_notifications":
        await handle_notification_settings(update, context)
    elif callback_data == "settings_accounts":
        await handle_account_settings(update, context)
    elif callback_data == "settings_display":
        await handle_display_settings(update, context)
    elif callback_data == "settings_privacy":
        await handle_privacy_settings(update, context)
    elif callback_data.startswith("back_to_settings"):
        await back_to_settings_menu(update, context)
    elif callback_data.startswith("delete_account_"):
        # å¤„ç†åˆ é™¤è´¦æˆ·è¯·æ±‚
        account_id = int(callback_data.split("_")[-1])
        await handle_delete_account(update, context, account_id)
    elif callback_data.startswith("confirm_delete_account_"):
        # å¤„ç†ç¡®è®¤åˆ é™¤è´¦æˆ·
        account_id = int(callback_data.split("_")[-1])
        await handle_confirm_delete_account(update, context, account_id)
    elif callback_data == "cancel_delete_account":
        # å¤„ç†å–æ¶ˆåˆ é™¤è´¦æˆ·
        await handle_cancel_delete_account(update, context)
    else:
        logger.warning(f"æœªçŸ¥è®¾ç½®å›è°ƒæ•°æ®: {callback_data}")
        await query.edit_message_text(
            "æŠ±æ­‰ï¼Œå‘ç”Ÿäº†æœªçŸ¥é”™è¯¯ã€‚è¯·ä½¿ç”¨ /settings é‡æ–°æ‰“å¼€è®¾ç½®èœå•ã€‚"
        )

async def handle_notification_settings(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """å¤„ç†é€šçŸ¥è®¾ç½®"""
    query = update.callback_query
    
    # è¿™é‡Œåº”è¯¥ä»æ•°æ®åº“è·å–ç”¨æˆ·å½“å‰çš„é€šçŸ¥è®¾ç½®
    # ä¸ºäº†æ¼”ç¤ºï¼Œæˆ‘ä»¬å‡è®¾é»˜è®¤å€¼
    receive_all_emails = True
    receive_important_only = False
    silent_mode = False
    
    keyboard = [
        [
            InlineKeyboardButton(
                f"{'âœ…' if receive_all_emails else 'âŒ'} æ¥æ”¶æ‰€æœ‰é‚®ä»¶", 
                callback_data="toggle_all_emails"
            ),
        ],
        [
            InlineKeyboardButton(
                f"{'âœ…' if receive_important_only else 'âŒ'} ä»…é‡è¦é‚®ä»¶", 
                callback_data="toggle_important_emails"
            ),
        ],
        [
            InlineKeyboardButton(
                f"{'âœ…' if silent_mode else 'âŒ'} é™éŸ³æ¨¡å¼", 
                callback_data="toggle_silent_mode"
            ),
        ],
        [
            InlineKeyboardButton("Â« è¿”å›", callback_data="back_to_settings"),
        ],
    ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text(
        "ğŸ”” <b>é€šçŸ¥è®¾ç½®</b>\n\n"
        "é…ç½®æ‚¨å¸Œæœ›å¦‚ä½•æ¥æ”¶é‚®ä»¶é€šçŸ¥ã€‚",
        reply_markup=reply_markup,
        parse_mode="HTML"
    )

async def handle_account_settings(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """å¤„ç†è´¦æˆ·è®¾ç½®"""
    query = update.callback_query
    
    # è¿™é‡Œåº”è¯¥ä»æ•°æ®åº“è·å–ç”¨æˆ·çš„é‚®ä»¶è´¦æˆ·
    # ä¸ºäº†æ¼”ç¤ºï¼Œæˆ‘ä»¬å‡è®¾æœ‰ä¸€äº›è´¦æˆ·
    accounts = [
        {"name": "å·¥ä½œé‚®ç®±", "email": "work@example.com", "active": True},
        {"name": "ä¸ªäººé‚®ç®±", "email": "personal@example.com", "active": False},
    ]
    
    keyboard = []
    for account in accounts:
        status = "âœ… å·²å¯ç”¨" if account["active"] else "âŒ å·²ç¦ç”¨"
        keyboard.append([
            InlineKeyboardButton(
                f"{account['name']} ({status})",
                callback_data=f"account_{account['email']}"
            )
        ])
    
    keyboard.append([InlineKeyboardButton("+ æ·»åŠ æ–°è´¦æˆ·", callback_data="add_account")])
    keyboard.append([InlineKeyboardButton("Â« è¿”å›", callback_data="back_to_settings")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text(
        "ğŸ“§ <b>è´¦æˆ·ç®¡ç†</b>\n\n"
        "ç®¡ç†æ‚¨çš„é‚®ä»¶è´¦æˆ·ã€‚",
        reply_markup=reply_markup,
        parse_mode="HTML"
    )

async def handle_display_settings(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """å¤„ç†æ˜¾ç¤ºè®¾ç½®"""
    query = update.callback_query
    
    # è¿™é‡Œåº”è¯¥ä»æ•°æ®åº“è·å–ç”¨æˆ·çš„æ˜¾ç¤ºè®¾ç½®
    # ä¸ºäº†æ¼”ç¤ºï¼Œæˆ‘ä»¬å‡è®¾é»˜è®¤å€¼
    show_previews = True
    compact_mode = False
    render_html = True
    
    keyboard = [
        [
            InlineKeyboardButton(
                f"{'âœ…' if show_previews else 'âŒ'} æ˜¾ç¤ºé‚®ä»¶é¢„è§ˆ", 
                callback_data="toggle_previews"
            ),
        ],
        [
            InlineKeyboardButton(
                f"{'âœ…' if compact_mode else 'âŒ'} ç´§å‡‘æ¨¡å¼", 
                callback_data="toggle_compact_mode"
            ),
        ],
        [
            InlineKeyboardButton(
                f"{'âœ…' if render_html else 'âŒ'} æ¸²æŸ“HTML", 
                callback_data="toggle_render_html"
            ),
        ],
        [
            InlineKeyboardButton("Â« è¿”å›", callback_data="back_to_settings"),
        ],
    ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text(
        "ğŸ–¥ï¸ <b>æ˜¾ç¤ºè®¾ç½®</b>\n\n"
        "é…ç½®é‚®ä»¶å¦‚ä½•æ˜¾ç¤ºã€‚",
        reply_markup=reply_markup,
        parse_mode="HTML"
    )

async def handle_privacy_settings(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """å¤„ç†éšç§è®¾ç½®"""
    query = update.callback_query
    
    # è¿™é‡Œåº”è¯¥ä»æ•°æ®åº“è·å–ç”¨æˆ·çš„éšç§è®¾ç½®
    # ä¸ºäº†æ¼”ç¤ºï¼Œæˆ‘ä»¬å‡è®¾é»˜è®¤å€¼
    cache_emails = True
    auto_delete = False
    
    keyboard = [
        [
            InlineKeyboardButton(
                f"{'âœ…' if cache_emails else 'âŒ'} ç¼“å­˜é‚®ä»¶å†…å®¹", 
                callback_data="toggle_cache"
            ),
        ],
        [
            InlineKeyboardButton(
                f"{'âœ…' if auto_delete else 'âŒ'} è‡ªåŠ¨åˆ é™¤æ—§é‚®ä»¶", 
                callback_data="toggle_auto_delete"
            ),
        ],
        [
            InlineKeyboardButton("ğŸ—‘ï¸ æ¸…é™¤æ‰€æœ‰æ•°æ®", callback_data="clear_all_data"),
        ],
        [
            InlineKeyboardButton("Â« è¿”å›", callback_data="back_to_settings"),
        ],
    ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text(
        "ğŸ”’ <b>éšç§è®¾ç½®</b>\n\n"
        "ç®¡ç†æ‚¨çš„æ•°æ®å’Œéšç§é€‰é¡¹ã€‚",
        reply_markup=reply_markup,
        parse_mode="HTML"
    )

async def back_to_settings_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """è¿”å›ä¸»è®¾ç½®èœå•"""
    query = update.callback_query
    
    keyboard = [
        [
            InlineKeyboardButton("é€šçŸ¥è®¾ç½®", callback_data="settings_notifications"),
            InlineKeyboardButton("è´¦æˆ·ç®¡ç†", callback_data="settings_accounts"),
        ],
        [
            InlineKeyboardButton("æ˜¾ç¤ºé€‰é¡¹", callback_data="settings_display"),
            InlineKeyboardButton("éšç§è®¾ç½®", callback_data="settings_privacy"),
        ],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text("âš™ï¸ è¯·é€‰æ‹©è¦ç®¡ç†çš„è®¾ç½®ç±»åˆ«ï¼š", reply_markup=reply_markup)

async def handle_email_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    å¤„ç†é‚®ä»¶ç›¸å…³çš„å›è°ƒæŸ¥è¯¢
    """
    query = update.callback_query
    await query.answer()
    
    callback_data = query.data
    
    if callback_data.startswith("view_email_"):
        email_id = int(callback_data.split("_")[2])
        await handle_view_email(update, context, email_id)
    elif callback_data.startswith("mark_read_"):
        email_id = int(callback_data.split("_")[2])
        await handle_mark_email_read(update, context, email_id)
    elif callback_data.startswith("reply_email_"):
        email_id = int(callback_data.split("_")[2])
        await handle_reply_email(update, context, email_id)
    elif callback_data.startswith("forward_email_"):
        email_id = int(callback_data.split("_")[2])
        await handle_forward_email(update, context, email_id)
    elif callback_data.startswith("delete_email_"):
        email_id = int(callback_data.split("_")[2])
        await handle_delete_email(update, context, email_id)
    elif callback_data.startswith("download_attachments_"):
        email_id = int(callback_data.split("_")[2])
        await handle_download_attachments(update, context, email_id)
    else:
        logger.warning(f"æœªçŸ¥é‚®ä»¶å›è°ƒæ•°æ®: {callback_data}")
        await query.edit_message_text(
            "æŠ±æ­‰ï¼Œå‘ç”Ÿäº†æœªçŸ¥é”™è¯¯ã€‚è¯·é‡æ–°å°è¯•æ“ä½œã€‚"
        )

async def handle_view_email(update: Update, context: ContextTypes.DEFAULT_TYPE, email_id: int) -> None:
    """
    å¤„ç†æŸ¥çœ‹é‚®ä»¶è¯¦æƒ…
    """
    query = update.callback_query
    
    # ä»æ•°æ®åº“è·å–é‚®ä»¶
    email = get_email_by_id(email_id)
    if not email:
        await query.edit_message_text("æŠ±æ­‰ï¼Œæ‰¾ä¸åˆ°è¯¥é‚®ä»¶æˆ–å·²è¢«åˆ é™¤ã€‚")
        return
    
    # å‡†å¤‡é‚®ä»¶è¯¦æƒ…æ¶ˆæ¯
    message_text = (
        f"ğŸ“§ <b>{html.escape(email.subject)}</b>\n\n"
        f"<b>å‘ä»¶äºº:</b> {html.escape(email.sender)}\n"
        f"<b>æ”¶ä»¶äºº:</b> {html.escape(email.recipients)}\n"
        f"<b>æ—¥æœŸ:</b> {email.date.strftime('%Y-%m-%d %H:%M')}\n\n"
    )
    
    # æ·»åŠ æ­£æ–‡æç¤ºä¿¡æ¯ - ä¸å†ä»æ•°æ®åº“è·å–æ­£æ–‡
    message_text += "<i>ğŸ“ é‚®ä»¶å†…å®¹å·²é€šè¿‡å•ç‹¬æ¶ˆæ¯å‘é€ï¼Œè¯·åœ¨èŠå¤©å†å²ä¸­æŸ¥æ‰¾ã€‚</i>\n"
    message_text += "<i>å¦‚éœ€é‡æ–°æŸ¥çœ‹é‚®ä»¶å†…å®¹ï¼Œå¯ä½¿ç”¨ /check å‘½ä»¤æ£€æŸ¥æ–°é‚®ä»¶ã€‚</i>\n"
    
    # æ£€æŸ¥æ˜¯å¦æœ‰é™„ä»¶
    if email.has_attachments:
        message_text += f"\n\nğŸ“ <b>é™„ä»¶:</b> {email.attachment_count}ä¸ª"
    
    # åˆ›å»ºæ“ä½œæŒ‰é’® - ç§»é™¤"æ ‡è®°ä¸ºå·²è¯»"æŒ‰é’®
    keyboard = [
        [
            InlineKeyboardButton("ğŸ“¤ ä¸‹è½½é™„ä»¶", callback_data=f"download_attachments_{email_id}"),
        ],
        [
            InlineKeyboardButton("â†©ï¸ å›å¤", callback_data=f"reply_email_{email_id}"),
            InlineKeyboardButton("ğŸ”„ è½¬å‘", callback_data=f"forward_email_{email_id}"),
            InlineKeyboardButton("ğŸ—‘ï¸ åˆ é™¤", callback_data=f"delete_email_{email_id}"),
        ],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    # å‘é€æ¶ˆæ¯
    await query.edit_message_text(
        message_text,
        reply_markup=reply_markup,
        parse_mode="HTML",
        disable_web_page_preview=True
    )

async def handle_mark_email_read(update: Update, context: ContextTypes.DEFAULT_TYPE, email_id: int) -> None:
    """
    å¤„ç†æ ‡è®°é‚®ä»¶ä¸ºå·²è¯»
    """
    query = update.callback_query
    
    # ä»æ•°æ®åº“è·å–é‚®ä»¶
    email = get_email_by_id(email_id)
    if not email:
        await query.edit_message_text("æŠ±æ­‰ï¼Œæ‰¾ä¸åˆ°è¯¥é‚®ä»¶æˆ–å·²è¢«åˆ é™¤ã€‚")
        return
    
    # æ ‡è®°é‚®ä»¶ä¸ºå·²è¯»
    success = mark_email_as_read(email_id)
    
    if success:
        await query.edit_message_text(
            f"âœ… é‚®ä»¶ \"{html.escape(email.subject)}\" å·²æ ‡è®°ä¸ºå·²è¯»ã€‚",
            parse_mode="HTML"
        )
    else:
        await query.edit_message_text(
            f"âŒ æ ‡è®°é‚®ä»¶ä¸ºå·²è¯»æ—¶å‘ç”Ÿé”™è¯¯ã€‚è¯·é‡è¯•ã€‚",
            parse_mode="HTML"
        )

async def handle_reply_email(update: Update, context: ContextTypes.DEFAULT_TYPE, email_id: int) -> None:
    """
    å¤„ç†å›å¤é‚®ä»¶ - å¯åŠ¨å›å¤é‚®ä»¶ä¼šè¯
    """
    query = update.callback_query
    
    # ä»æ•°æ®åº“è·å–é‚®ä»¶
    email = get_email_by_id(email_id)
    if not email:
        await query.edit_message_text("æŠ±æ­‰ï¼Œæ‰¾ä¸åˆ°è¯¥é‚®ä»¶æˆ–å·²è¢«åˆ é™¤ã€‚")
        return
    
    # è·å–è´¦æˆ·ä¿¡æ¯
    account = get_email_account_by_id(email.account_id)
    if not account:
        await query.edit_message_text("æŠ±æ­‰ï¼Œæ‰¾ä¸åˆ°å¯¹åº”çš„é‚®ç®±è´¦æˆ·ã€‚")
        return
    
    # å­˜å‚¨é‚®ä»¶å’Œè´¦æˆ·ä¿¡æ¯åˆ°ç”¨æˆ·æ•°æ®
    context.user_data["reply_email_id"] = email_id
    context.user_data["reply_account_id"] = email.account_id
    context.user_data["reply_account_email"] = account.email
    
    # å¤„ç†å›å¤é‚®ä»¶çš„ä¸»é¢˜ï¼ˆæ·»åŠ Re:å‰ç¼€ï¼‰
    subject = email.subject
    if not subject.lower().startswith("re:"):
        subject = f"Re: {subject}"
    context.user_data["reply_subject"] = subject
    
    # å­˜å‚¨åŸå§‹æ¶ˆæ¯IDä»¥ä¾¿å›å¤æ—¶å¼•ç”¨
    if hasattr(query.message, 'message_id'):
        context.user_data["reply_original_message_id"] = query.message.message_id
    
    # åˆå§‹åŒ–æ¶ˆæ¯IDåˆ—è¡¨ä»¥ä¾¿åç»­æ¸…ç†
    context.user_data["reply_messages"] = []
    if hasattr(update, 'message') and update.message:
        context.user_data["reply_messages"].append(update.message.message_id)
    
    # å‡†å¤‡æ”¶ä»¶äººå€™é€‰åˆ—è¡¨ï¼ˆä»åŸé‚®ä»¶çš„å‘ä»¶äººã€æ”¶ä»¶äººã€æŠ„é€å’Œå¯†é€åˆ—è¡¨ä¸­æå–ï¼‰
    # åŸé‚®ä»¶çš„å‘ä»¶äººä½œä¸ºé»˜è®¤æ”¶ä»¶äºº
    context.user_data["reply_default_recipient"] = email.sender
    
    # æ ¹æ®jsonæ ¼å¼è§£æåŸé‚®ä»¶çš„æ”¶ä»¶äººåˆ—è¡¨
    import json
    recipients_list = []
    cc_list = []
    bcc_list = []
    
    # å°è¯•è§£æåŸé‚®ä»¶çš„æ”¶ä»¶äººåˆ—è¡¨
    try:
        if email.recipients:
            if email.recipients.startswith('[') and email.recipients.endswith(']'):
                recipients_list = json.loads(email.recipients)
            else:
                recipients_list = [email.recipients]
    except json.JSONDecodeError:
        recipients_list = [email.recipients]
    
    # å°è¯•è§£æåŸé‚®ä»¶çš„æŠ„é€åˆ—è¡¨
    try:
        if email.cc:
            if email.cc.startswith('[') and email.cc.endswith(']'):
                cc_list = json.loads(email.cc)
            else:
                cc_list = [email.cc]
    except json.JSONDecodeError:
        if email.cc:
            cc_list = [email.cc]
    
    # å°è¯•è§£æåŸé‚®ä»¶çš„å¯†é€åˆ—è¡¨
    try:
        if email.bcc:
            if email.bcc.startswith('[') and email.bcc.endswith(']'):
                bcc_list = json.loads(email.bcc)
            else:
                bcc_list = [email.bcc]
    except json.JSONDecodeError:
        if email.bcc:
            bcc_list = [email.bcc]
    
    # å­˜å‚¨å€™é€‰äººåˆ—è¡¨ï¼Œç”¨äºåç»­é€‰æ‹©
    context.user_data["reply_candidates"] = {
        "recipients": recipients_list,
        "cc": cc_list,
        "bcc": bcc_list
    }
    
    # åˆå§‹åŒ–å›å¤é‚®ä»¶çš„æ”¶ä»¶äººã€æŠ„é€å’Œå¯†é€åˆ—è¡¨
    context.user_data["reply_recipients"] = [email.sender]  # é»˜è®¤å›å¤ç»™åŸé‚®ä»¶çš„å‘ä»¶äºº
    context.user_data["reply_cc"] = []
    context.user_data["reply_bcc"] = []
    
    # åˆ›å»ºé”®ç›˜å¸ƒå±€ï¼Œå¸®åŠ©ç”¨æˆ·ä»å€™é€‰äººä¸­é€‰æ‹©æˆ–æ‰‹åŠ¨æ·»åŠ 
    keyboard = [
        ["ğŸ“¤ ä½¿ç”¨é»˜è®¤æ”¶ä»¶äººï¼ˆåŸå‘ä»¶äººï¼‰"],
        ["ğŸ‘¥ ç®¡ç†æ”¶ä»¶äººåˆ—è¡¨"],
        ["ğŸ“‹ ç®¡ç†æŠ„é€åˆ—è¡¨"],
        ["ğŸ•¶ ç®¡ç†å¯†é€åˆ—è¡¨"],
        ["âœ… ç»§ç»­ç¼–å†™æ­£æ–‡", "âŒ å–æ¶ˆ"]
    ]
    
    reply_markup = ReplyKeyboardMarkup(
        keyboard,
        one_time_keyboard=True,
        resize_keyboard=True,
        input_field_placeholder="é€‰æ‹©æ“ä½œæˆ–è¾“å…¥å›å¤å†…å®¹"
    )
    
    # å‘é€å›å¤é‚®ä»¶çš„åˆå§‹æç¤º
    message = await query.message.reply_text(
        f"ğŸ“¤ <b>å›å¤é‚®ä»¶</b>\n\n"
        f"<b>è´¦å·:</b> {html.escape(account.email)}\n"
        f"<b>ä¸»é¢˜:</b> {html.escape(subject)}\n"
        f"<b>æ”¶ä»¶äºº:</b> {html.escape(email.sender)}\n\n"
        f"è¯·é€‰æ‹©æ“ä½œä»¥ç»§ç»­é‚®ä»¶å›å¤æµç¨‹ï¼š\n"
        f"â€¢ ä½¿ç”¨é»˜è®¤æ”¶ä»¶äºº - ç›´æ¥å›å¤ç»™åŸé‚®ä»¶å‘ä»¶äºº\n"
        f"â€¢ ç®¡ç†æ”¶ä»¶äºº/æŠ„é€/å¯†é€åˆ—è¡¨ - è‡ªå®šä¹‰æ¥æ”¶è€…\n"
        f"â€¢ ç»§ç»­ç¼–å†™æ­£æ–‡ - è¿›å…¥é‚®ä»¶æ­£æ–‡ç¼–å†™\n"
        f"â€¢ å–æ¶ˆ - æ”¾å¼ƒå½“å‰å›å¤æ“ä½œ",
        parse_mode="HTML",
        reply_markup=reply_markup,
        disable_notification=True
    )
    
    # è®°å½•æ¶ˆæ¯IDä»¥ä¾¿åç»­æ¸…ç†
    context.user_data["reply_messages"].append(message.message_id)
    
    # æ›´æ–°ä¼šè¯çŠ¶æ€
    return REPLY_ENTER_RECIPIENTS

async def handle_forward_email(update: Update, context: ContextTypes.DEFAULT_TYPE, email_id: int) -> None:
    """
    å¤„ç†è½¬å‘é‚®ä»¶
    """
    query = update.callback_query
    
    # ä»æ•°æ®åº“è·å–é‚®ä»¶
    email = get_email_by_id(email_id)
    if not email:
        await query.edit_message_text("æŠ±æ­‰ï¼Œæ‰¾ä¸åˆ°è¯¥é‚®ä»¶æˆ–å·²è¢«åˆ é™¤ã€‚")
        return
    
    # å°†é‚®ä»¶IDå­˜å‚¨åœ¨ç”¨æˆ·æ•°æ®ä¸­ï¼Œä»¥ä¾¿åç»­å¤„ç†
    context.user_data["forward_email_id"] = email_id
    
    # æç¤ºç”¨æˆ·è¾“å…¥æ”¶ä»¶äºº
    await query.edit_message_text(
        f"ğŸ”„ <b>è½¬å‘é‚®ä»¶</b>\n\n"
        f"<b>ä¸»é¢˜:</b> Fwd: {html.escape(email.subject)}\n\n"
        f"è¯·è¾“å…¥æ”¶ä»¶äººé‚®ç®±åœ°å€ï¼Œä½¿ç”¨é€—å·åˆ†éš”å¤šä¸ªåœ°å€ï¼Œæˆ–ä½¿ç”¨ /cancel å–æ¶ˆæ“ä½œã€‚",
        parse_mode="HTML"
    )
    
    # è®¾ç½®ä¼šè¯çŠ¶æ€
    context.user_data["state"] = "awaiting_forward_recipients"

async def handle_delete_email(update: Update, context: ContextTypes.DEFAULT_TYPE, email_id: int) -> None:
    """
    å¤„ç†åˆ é™¤é‚®ä»¶
    """
    query = update.callback_query
    
    # ä»æ•°æ®åº“è·å–é‚®ä»¶
    email = get_email_by_id(email_id)
    if not email:
        await query.answer("æŠ±æ­‰ï¼Œæ‰¾ä¸åˆ°è¯¥é‚®ä»¶æˆ–å·²è¢«åˆ é™¤ã€‚", show_alert=True)
        return
    
    # ä½¿ç”¨ReplyKeyboardMarkupè¯¢é—®ç”¨æˆ·æ˜¯å¦ç¡®å®šåˆ é™¤
    keyboard = ReplyKeyboardMarkup(
        [
            ["âœ… ç¡®è®¤åˆ é™¤"],
            ["âŒ å–æ¶ˆåˆ é™¤"]
        ],
        one_time_keyboard=True,
        resize_keyboard=True
    )
    
    # ä¿å­˜æ­£åœ¨åˆ é™¤çš„é‚®ä»¶IDåˆ°ä¸Šä¸‹æ–‡ä¸­
    context.user_data["delete_email_id"] = email_id
    # ä¿å­˜åŸå§‹æ¶ˆæ¯IDï¼ˆç”¨äºç¨ååˆ é™¤ï¼‰
    context.user_data["delete_origin_message_id"] = query.message.message_id
    
    # å‘é€ç¡®è®¤æ¶ˆæ¯
    await query.answer()
    confirmation_message = await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text=f"ğŸ—‘ï¸ <b>åˆ é™¤é‚®ä»¶ç¡®è®¤</b>\n\n"
             f"æ‚¨ç¡®å®šè¦åˆ é™¤ä¸»é¢˜ä¸º <b>\"{html.escape(email.subject)}\"</b> çš„é‚®ä»¶å—ï¼Ÿ\n"
             f"æ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚",
        parse_mode="HTML",
        reply_markup=keyboard,
        disable_notification=True
    )
    
    # ä¿å­˜ç¡®è®¤æ¶ˆæ¯IDï¼Œä»¥ä¾¿åœ¨æ“ä½œååˆ é™¤
    context.user_data["delete_confirm_message_id"] = confirmation_message.message_id

async def handle_confirm_delete_email(update: Update, context: ContextTypes.DEFAULT_TYPE, email_id: int) -> None:
    """
    å¤„ç†ç¡®è®¤åˆ é™¤é‚®ä»¶
    """
    query = update.callback_query
    await query.answer()
    
    # ä»æ•°æ®åº“è·å–é‚®ä»¶
    email = get_email_by_id(email_id)
    if not email:
        # ä½¿ç”¨answerå›è°ƒè€Œä¸æ˜¯ç¼–è¾‘æ¶ˆæ¯
        await query.answer("æŠ±æ­‰ï¼Œæ‰¾ä¸åˆ°è¯¥é‚®ä»¶æˆ–å·²è¢«åˆ é™¤ã€‚", show_alert=True)
        return
    
    # è·å–é‚®ä»¶è´¦æˆ·
    account = get_email_account_by_id(email.account_id)
    if not account:
        await query.answer("æŠ±æ­‰ï¼Œæ‰¾ä¸åˆ°è¯¥é‚®ä»¶çš„é‚®ç®±è´¦æˆ·ã€‚", show_alert=True)
        return
    
    # å°è¯•åˆ›å»ºä¸´æ—¶çŠ¶æ€æ¶ˆæ¯ - ä½†ä¸ä¸­æ–­æµç¨‹
    delete_in_progress_message = None
    try:
        # åˆ¤æ–­æ¶ˆæ¯ç±»å‹ï¼Œé’ˆå¯¹ä¸åŒç±»å‹ä½¿ç”¨ä¸åŒçš„ç¼–è¾‘æ–¹æ³•
        if query.message and not query.message.document and not query.message.photo and query.message.text:
            # å¦‚æœæ˜¯æ–‡æœ¬æ¶ˆæ¯
            delete_in_progress_message = await query.edit_message_text("â³ æ­£åœ¨åˆ é™¤é‚®ä»¶...", parse_mode="HTML")
        elif query.message and query.message.caption is not None:
            # å¦‚æœæ˜¯å¸¦captionçš„æ¶ˆæ¯ï¼ˆå›¾ç‰‡æˆ–æ–‡æ¡£ï¼‰
            delete_in_progress_message = await query.edit_message_caption(
                caption="â³ æ­£åœ¨åˆ é™¤é‚®ä»¶...", 
                parse_mode="HTML"
            )
        else:
            # å¦‚æœæ— æ³•ç¼–è¾‘ï¼Œä½¿ç”¨å›è°ƒé€šçŸ¥
            await query.answer("æ­£åœ¨åˆ é™¤é‚®ä»¶...", show_alert=False)
    except Exception as e:
        logger.error(f"ç¼–è¾‘æ¶ˆæ¯å¤±è´¥: {e}")
        # è¿™é‡Œä¸è¿”å›ï¼Œç»§ç»­æ‰§è¡Œåˆ é™¤é€»è¾‘
    
    imap_delete_success = False
    
    # è¿æ¥åˆ°IMAPæœåŠ¡å™¨å¹¶åˆ é™¤é‚®ä»¶
    client = IMAPClient(account=account)
    if await client.connect():
        try:
            # æ˜¯å¦ä¸ºå·²å‘é€é‚®ä»¶ï¼ˆæ£€æŸ¥æ¶ˆæ¯IDä¸­æ˜¯å¦åŒ…å«sentæ ‡è¯†æˆ–å…¶ä»–å±æ€§ï¼‰
            mailbox = None
            # å°è¯•å…ˆåœ¨æ”¶ä»¶ç®±ä¸­æŸ¥æ‰¾
            if await client.select_mailbox():
                message_nums = await client.search_by_message_id(email.message_id)
                if message_nums:
                    # åˆ é™¤é‚®ä»¶
                    imap_delete_success = await client.delete_message(message_nums[0])
                else:
                    # å¦‚æœåœ¨æ”¶ä»¶ç®±ä¸­æ‰¾ä¸åˆ°ï¼Œå°è¯•åœ¨å·²å‘é€æ–‡ä»¶å¤¹ä¸­æŸ¥æ‰¾
                    if await client.select_mailbox('sent'):
                        message_nums = await client.search_by_message_id(email.message_id)
                        if message_nums:
                            # åˆ é™¤å·²å‘é€é‚®ä»¶
                            imap_delete_success = await client.delete_message(message_nums[0])
        except Exception as e:
            logger.error(f"IMAPåˆ é™¤é‚®ä»¶æ—¶å‘ç”Ÿé”™è¯¯: {e}")
        finally:
            client.disconnect()
    
    # æ— è®ºIMAPæ“ä½œæ˜¯å¦æˆåŠŸï¼Œéƒ½åœ¨æ•°æ®åº“ä¸­æ ‡è®°ä¸ºå·²åˆ é™¤
    success = delete_email(email_id)
    
    if success:
        try:
            # åˆ é™¤åŸå§‹Telegramæ¶ˆæ¯
            await query.message.delete()
            
            # å‘é€ä¸€æ¡æç¤ºæ¶ˆæ¯ï¼Œ3ç§’åè‡ªåŠ¨åˆ é™¤
            sent_message = await context.bot.send_message(
                chat_id=query.message.chat_id,
                text=f"âœ… é‚®ä»¶ \"{html.escape(email.subject)}\" å·²æˆåŠŸåˆ é™¤ã€‚",
                parse_mode="HTML"
            )
            
            # è®¾ç½®3ç§’ååˆ é™¤æ¶ˆæ¯çš„ä»»åŠ¡
            context.job_queue.run_once(
                lambda job_context: delete_message(job_context, update.effective_chat.id, success_message.message_id),
                3,  # 3ç§’ååˆ é™¤
                name=f"delete_success_msg_{sent_message.message_id}"
            )
        except Exception as e:
            logger.error(f"å¤„ç†Telegramæ¶ˆæ¯æ—¶å‘ç”Ÿé”™è¯¯: {e}")
            await query.answer("âœ… é‚®ä»¶å·²æˆåŠŸåˆ é™¤", show_alert=True)
    else:
        try:
            # å°è¯•é€šçŸ¥åˆ é™¤å¤±è´¥
            if query.message and not query.message.document and not query.message.photo and query.message.text:
                await query.edit_message_text(
                    f"âŒ åˆ é™¤é‚®ä»¶æ—¶å‘ç”Ÿé”™è¯¯ã€‚è¯·é‡è¯•ã€‚",
                    parse_mode="HTML"
                )
            elif query.message and query.message.caption is not None:
                await query.edit_message_caption(
                    caption=f"âŒ åˆ é™¤é‚®ä»¶æ—¶å‘ç”Ÿé”™è¯¯ã€‚è¯·é‡è¯•ã€‚",
                    parse_mode="HTML"
                )
            else:
                await query.answer("âŒ åˆ é™¤é‚®ä»¶æ—¶å‘ç”Ÿé”™è¯¯ã€‚è¯·é‡è¯•ã€‚", show_alert=True)
        except Exception as e:
            logger.error(f"ç¼–è¾‘æ¶ˆæ¯å¤±è´¥: {e}")
            await query.answer("âŒ åˆ é™¤é‚®ä»¶æ—¶å‘ç”Ÿé”™è¯¯ã€‚è¯·é‡è¯•ã€‚", show_alert=True)

async def handle_cancel_delete_email(update: Update, context: ContextTypes.DEFAULT_TYPE, email_id: int = None) -> None:
    """å¤„ç†å–æ¶ˆåˆ é™¤é‚®ä»¶çš„å›è°ƒ"""
    query = update.callback_query
    await query.answer()
    
    # å¦‚æœæ²¡æœ‰ä¼ å…¥email_idå‚æ•°ï¼Œåˆ™ä»å›è°ƒæ•°æ®ä¸­æå–
    if email_id is None:
        email_id = int(query.data.split("_")[2])
    
    # è·å–é‚®ä»¶ä¿¡æ¯
    email = get_email_by_id(email_id)
    if not email:
        await query.answer("æ— æ³•æ‰¾åˆ°é‚®ä»¶ä¿¡æ¯ã€‚", show_alert=True)
        return
    
    try:
        # å°è¯•ä½¿ç”¨handle_view_emailæ¢å¤åŸå§‹è§†å›¾
        await handle_view_email(update, context, email_id)
    except Exception as e:
        logger.error(f"æ¢å¤é‚®ä»¶è§†å›¾å¤±è´¥: {e}")
        await query.answer("å·²å–æ¶ˆåˆ é™¤æ“ä½œ", show_alert=True)

# è´¦æˆ·æ·»åŠ å¯¹è¯å¤„ç†ç›¸å…³å‡½æ•°
from telegram import ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import ConversationHandler, CommandHandler, MessageHandler, filters, CallbackQueryHandler
import asyncio

# å®šä¹‰å¯¹è¯çŠ¶æ€
ENTER_EMAIL = "ENTER_EMAIL"
ENTER_NAME = "ENTER_NAME"
ENTER_USERNAME = "ENTER_USERNAME"
ENTER_PASSWORD = "ENTER_PASSWORD"

# å¸¸è§é‚®ç®±æœåŠ¡å•†çš„é…ç½®ä¿¡æ¯
EMAIL_PROVIDERS = {
    "gmail.com": {
        "imap_server": "imap.gmail.com",
        "imap_port": 993,
        "imap_use_ssl": True,
        "smtp_server": "smtp.gmail.com",
        "smtp_port": 587,
        "smtp_use_ssl": True,
        "name": "Gmail"
    },
    "163.com": {
        "imap_server": "imap.163.com",
        "imap_port": 993,
        "imap_use_ssl": True,
        "smtp_server": "smtp.163.com",
        "smtp_port": 465,
        "smtp_use_ssl": True,
        "name": "ç½‘æ˜“163é‚®ç®±"
    },
    "126.com": {
        "imap_server": "imap.126.com",
        "imap_port": 993,
        "imap_use_ssl": True,
        "smtp_server": "smtp.126.com",
        "smtp_port": 465,
        "smtp_use_ssl": True,
        "name": "ç½‘æ˜“126é‚®ç®±"
    },
    "qq.com": {
        "imap_server": "imap.qq.com",
        "imap_port": 993,
        "imap_use_ssl": True,
        "smtp_server": "smtp.qq.com",
        "smtp_port": 465,
        "smtp_use_ssl": True,
        "name": "QQé‚®ç®±"
    },
    "outlook.com": {
        "imap_server": "outlook.office365.com",
        "imap_port": 993,
        "imap_use_ssl": True,
        "smtp_server": "smtp.office365.com",
        "smtp_port": 587,
        "smtp_use_ssl": True,
        "name": "Outlook"
    },
    "hotmail.com": {
        "imap_server": "outlook.office365.com",
        "imap_port": 993,
        "imap_use_ssl": True,
        "smtp_server": "smtp.office365.com",
        "smtp_port": 587,
        "smtp_use_ssl": True,
        "name": "Hotmail"
    },
    "live.com": {
        "imap_server": "outlook.office365.com",
        "imap_port": 993,
        "imap_use_ssl": True,
        "smtp_server": "smtp.office365.com",
        "smtp_port": 587,
        "smtp_use_ssl": True,
        "name": "Live"
    },
    "yahoo.com": {
        "imap_server": "imap.mail.yahoo.com",
        "imap_port": 993,
        "imap_use_ssl": True,
        "smtp_server": "smtp.mail.yahoo.com",
        "smtp_port": 587,
        "smtp_use_ssl": True,
        "name": "Yahoo"
    },
    "foxmail.com": {
        "imap_server": "imap.qq.com",
        "imap_port": 993,
        "imap_use_ssl": True,
        "smtp_server": "smtp.qq.com",
        "smtp_port": 465,
        "smtp_use_ssl": True,
        "name": "Foxmail"
    }
}

async def handle_add_account_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> str:
    """å¤„ç†æ·»åŠ è´¦æˆ·æŒ‰é’®å›è°ƒ"""
    query = update.callback_query
    await query.answer()
    
    # å‘é€å¼•å¯¼ä¿¡æ¯
    message = await query.message.reply_text(
        "ğŸ“¬ <b>æ·»åŠ æ–°é‚®ç®±è´¦æˆ·</b>\n\n"
        "è¯·è¾“å…¥æ‚¨çš„é‚®ç®±åœ°å€ï¼ˆä¾‹å¦‚ï¼šexample@gmail.comï¼‰\n\n"
        "æ‚¨å¯ä»¥éšæ—¶è¾“å…¥ /cancel å–æ¶ˆæ“ä½œã€‚",
        parse_mode="HTML",
        disable_notification=True
    )
    
    # ä¿å­˜æ­¤æ¶ˆæ¯IDï¼Œä»¥ä¾¿åç»­åˆ é™¤
    context.user_data["guide_message_id"] = message.message_id
    context.user_data["last_step_message_ids"] = []
    
    return ENTER_EMAIL

async def handle_enter_email(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """å¤„ç†è¾“å…¥é‚®ç®±åœ°å€"""
    # è®°å½•è¿™ä¸€æ­¥çš„æ¶ˆæ¯ID
    if "last_step_message_ids" not in context.user_data:
        context.user_data["last_step_message_ids"] = []
    context.user_data["last_step_message_ids"].append(update.message.message_id)
    
    email = update.message.text.strip()
    
    # æ£€æŸ¥æ˜¯å¦å–æ¶ˆæ“ä½œ
    if email.lower() == "/cancel":
        return await handle_cancel_account(update, context)
    
    # ç®€å•éªŒè¯é‚®ç®±æ ¼å¼
    if "@" not in email or "." not in email:
        message = await update.message.reply_text(
            "âŒ é‚®ç®±æ ¼å¼ä¸æ­£ç¡®ï¼Œè¯·é‡æ–°è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„é‚®ç®±åœ°å€ã€‚",
            disable_notification=True
        )
        context.user_data["last_step_message_ids"].append(message.message_id)
        return ENTER_EMAIL
    
    # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨è¯¥é‚®ç®±è´¦æˆ·
    existing_account = AccountOperations.get_account_by_email(email)
    if existing_account:
        message = await update.message.reply_text(
            f"âŒ é‚®ç®± {email} å·²ç»æ·»åŠ è¿‡äº†ï¼Œè¯·ä½¿ç”¨å…¶ä»–é‚®ç®±ã€‚",
            disable_notification=True
        )
        context.user_data["last_step_message_ids"].append(message.message_id)
        return ENTER_EMAIL
    
    # ä¿å­˜é‚®ç®±åˆ°ä¸Šä¸‹æ–‡
    context.user_data["new_account"] = {"email": email}
    
    # å°è¯•è‡ªåŠ¨é…ç½®é‚®ç®±æœåŠ¡å™¨ä¿¡æ¯
    email_domain = email.split("@")[1].lower()
    
    # æ£€æŸ¥æ˜¯å¦æ˜¯å¸¸è§é‚®ç®±æä¾›å•†
    if email_domain in EMAIL_PROVIDERS:
        provider = EMAIL_PROVIDERS[email_domain]
        provider_name = provider["name"]
        context.user_data["new_account"].update({
            "imap_server": provider["imap_server"],
            "imap_port": provider["imap_port"],
            "imap_use_ssl": provider["imap_use_ssl"],
            "smtp_server": provider["smtp_server"],
            "smtp_port": provider["smtp_port"],
            "smtp_use_ssl": provider["smtp_use_ssl"]
        })
        
        # åˆ é™¤å‰ä¸€æ­¥çš„æ¶ˆæ¯
        await delete_last_step_messages(context, update.effective_chat.id)
        
        # å‘é€é…ç½®æˆåŠŸæ¶ˆæ¯
        message = await update.message.reply_text(
            f"ğŸ“§ å·²è‡ªåŠ¨é…ç½®{provider_name}æœåŠ¡å™¨ä¿¡æ¯ã€‚\n\n"
            f"è¯·ä¸ºæ­¤è´¦æˆ·è®¾ç½®ä¸€ä¸ªåç§° (ä¾‹å¦‚: å·¥ä½œé‚®ç®±, ä¸ªäººé‚®ç®±)ï¼Œ\n"
            f"æˆ–ç›´æ¥å‘é€ /skip è·³è¿‡ã€‚",
            disable_notification=True
        )
        context.user_data["last_step_message_ids"] = [message.message_id]
    else:
        # å¯¹äºä¸å¸¸è§çš„é‚®ç®±ï¼Œæˆ‘ä»¬ç›´æ¥è·³è¿‡æœåŠ¡å™¨é…ç½®ï¼Œåé¢ä¼šæç¤ºç”¨æˆ·æ‰‹åŠ¨è¾“å…¥
        # è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨é»˜è®¤çš„é€šç”¨é…ç½®ï¼Œä½†è¦åœ¨åé¢éªŒè¯è¿æ¥æ—¶ç¡®è®¤
        context.user_data["new_account"].update({
            "imap_server": f"imap.{email_domain}",
            "imap_port": 993,
            "imap_use_ssl": True,
            "smtp_server": f"smtp.{email_domain}",
            "smtp_port": 587,
            "smtp_use_ssl": True
        })
        
        # åˆ é™¤å‰ä¸€æ­¥çš„æ¶ˆæ¯
        await delete_last_step_messages(context, update.effective_chat.id)
        
        # å‘é€ä¸‹ä¸€æ­¥æŒ‡å¼•
        message = await update.message.reply_text(
            f"ğŸ“§ ä¸º{email}è®¾ç½®ä¸€ä¸ªåç§° (ä¾‹å¦‚: å·¥ä½œé‚®ç®±, ä¸ªäººé‚®ç®±)ï¼Œ\n"
            f"æˆ–ç›´æ¥å‘é€ /skip è·³è¿‡ã€‚\n\n"
            f"æ³¨æ„ï¼šç³»ç»Ÿå°†å°è¯•ä½¿ç”¨è‡ªåŠ¨ç”Ÿæˆçš„æœåŠ¡å™¨é…ç½®ï¼Œå¦‚æœè¿æ¥å¤±è´¥ï¼Œå°†æç¤ºæ‚¨æ‰‹åŠ¨è¾“å…¥ã€‚",
            disable_notification=True
        )
        context.user_data["last_step_message_ids"] = [message.message_id]
    
    return ENTER_NAME

async def handle_enter_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """å¤„ç†è¾“å…¥è´¦æˆ·åç§°"""
    # è®°å½•è¿™ä¸€æ­¥çš„æ¶ˆæ¯ID
    context.user_data["last_step_message_ids"].append(update.message.message_id)
    
    text = update.message.text.strip()
    
    # æ£€æŸ¥æ˜¯å¦å–æ¶ˆæ“ä½œ
    if text.lower() == "/cancel":
        return await handle_cancel_account(update, context)
    
    if text == "/skip":
        context.user_data["new_account"]["name"] = None
    else:
        context.user_data["new_account"]["name"] = text
    
    # åˆ é™¤å‰ä¸€æ­¥çš„æ¶ˆæ¯
    await delete_last_step_messages(context, update.effective_chat.id)
    
    # æç¤ºè¾“å…¥ç”¨æˆ·å
    message = await update.message.reply_text(
        f"è¯·è¾“å…¥æ‚¨çš„é‚®ç®±ç”¨æˆ·å (é€šå¸¸å°±æ˜¯å®Œæ•´çš„é‚®ç®±åœ°å€)ã€‚\n\n"
        f"ä¾‹å¦‚: {context.user_data['new_account']['email']}",
        disable_notification=True
    )
    context.user_data["last_step_message_ids"] = [message.message_id]
    
    return ENTER_USERNAME

async def handle_enter_username(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """å¤„ç†è¾“å…¥ç”¨æˆ·å"""
    # è®°å½•è¿™ä¸€æ­¥çš„æ¶ˆæ¯ID
    context.user_data["last_step_message_ids"].append(update.message.message_id)
    
    username = update.message.text.strip()
    
    # æ£€æŸ¥æ˜¯å¦å–æ¶ˆæ“ä½œ
    if username.lower() == "/cancel":
        return await handle_cancel_account(update, context)
    
    context.user_data["new_account"]["username"] = username
    
    # åˆ é™¤å‰ä¸€æ­¥çš„æ¶ˆæ¯
    await delete_last_step_messages(context, update.effective_chat.id)
    
    # æç¤ºè¾“å…¥å¯†ç 
    message = await update.message.reply_text(
        "è¯·è¾“å…¥æ‚¨çš„é‚®ç®±å¯†ç æˆ–åº”ç”¨ä¸“ç”¨å¯†ç ã€‚\n\n"
        "ğŸ‘€ <b>æ³¨æ„</b>ï¼šå¦‚æœæ‚¨çš„é‚®ç®±å¯ç”¨äº†ä¸¤æ­¥éªŒè¯ï¼Œè¯·ä½¿ç”¨åº”ç”¨ä¸“ç”¨å¯†ç è€Œéç™»å½•å¯†ç ã€‚\n\n"
        "<i>æ‚¨çš„å¯†ç å°†è¢«å®‰å…¨åŠ å¯†å­˜å‚¨ï¼Œä¸”åªä¼šç”¨äºé‚®ä»¶æ”¶å‘ã€‚</i>",
        parse_mode="HTML",
        disable_notification=True
    )
    context.user_data["last_step_message_ids"] = [message.message_id]
    
    return ENTER_PASSWORD

async def handle_enter_password(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """å¤„ç†è¾“å…¥å¯†ç """
    # è®°å½•è¿™ä¸€æ­¥çš„æ¶ˆæ¯ID
    context.user_data["last_step_message_ids"].append(update.message.message_id)
    
    password = update.message.text.strip()
    
    # æ£€æŸ¥æ˜¯å¦å–æ¶ˆæ“ä½œ
    if password.lower() == "/cancel":
        return await handle_cancel_account(update, context)
    
    # åˆ é™¤å¯†ç æ¶ˆæ¯ä»¥ä¿æŠ¤éšç§
    try:
        await update.message.delete()
    except Exception:
        pass
    
    # åˆ é™¤å‰ä¸€æ­¥çš„æç¤ºæ¶ˆæ¯
    await delete_last_step_messages(context, update.effective_chat.id, exclude_last=True)
    
    # ä¿å­˜å¯†ç åˆ°ä¸Šä¸‹æ–‡
    context.user_data["new_account"]["password"] = password
    
    # å‘é€æµ‹è¯•è¿æ¥çš„æç¤º
    message = await update.message.reply_text("ğŸ”„ æ­£åœ¨æµ‹è¯•é‚®ç®±è¿æ¥ï¼Œè¯·ç¨å€™...", disable_notification=True)
    context.user_data["testing_message_id"] = message.message_id
    
    # å¼€å§‹è¿›è¡Œè¿æ¥æµ‹è¯•
    return await test_account_connection(update, context)

async def delete_last_step_messages(context, chat_id, exclude_last=False):
    """åˆ é™¤ä¸Šä¸€æ­¥çš„é—®ç­”æ¶ˆæ¯"""
    if "last_step_message_ids" in context.user_data:
        message_ids = context.user_data["last_step_message_ids"]
        # å¦‚æœéœ€è¦æ’é™¤æœ€åä¸€æ¡æ¶ˆæ¯
        if exclude_last and message_ids:
            message_ids = message_ids[:-1]
            
        for msg_id in message_ids:
            try:
                await context.bot.delete_message(chat_id=chat_id, message_id=msg_id)
            except Exception:
                pass
        
        if exclude_last and context.user_data["last_step_message_ids"]:
            context.user_data["last_step_message_ids"] = [context.user_data["last_step_message_ids"][-1]]
        else:
            context.user_data["last_step_message_ids"] = []

async def test_account_connection(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """æµ‹è¯•é‚®ç®±è¿æ¥"""
    account = context.user_data["new_account"]
    
    # åˆ›å»ºIMAPå®¢æˆ·ç«¯è¿›è¡Œæµ‹è¯•
    from app.email.imap_client import IMAPClient
    from app.email.smtp_client import SMTPClient
    
    imap_client = IMAPClient(
        server=account["imap_server"],
        port=account["imap_port"],
        username=account["username"],
        password=account["password"],
        use_ssl=account.get("imap_use_ssl", True)
    )
    
    # æµ‹è¯•IMAPè¿æ¥
    imap_success = await imap_client.test_connection()
    
    # å¦‚æœIMAPè¿æ¥æˆåŠŸï¼Œä½¿ç”¨æ£€æµ‹åˆ°çš„é…ç½®è¦†ç›–åŸæœ‰è®¾ç½®
    if imap_success:
        # æ›´æ–°å½“å‰çš„IMAPé…ç½®ä»¥ä½¿ç”¨æ£€æµ‹åˆ°çš„ç«¯å£å’ŒSSLè®¾ç½®
        account["imap_port"] = imap_client.port
        account["imap_use_ssl"] = imap_client.use_ssl
        
        # æµ‹è¯•SMTPè¿æ¥
        smtp_client = SMTPClient(
            server=account["smtp_server"],
            port=account["smtp_port"],
            username=account["username"],
            password=account["password"],
            use_ssl=account.get("smtp_use_ssl", True)
        )
        
        smtp_success = await smtp_client.test_connection()
        
        # å¦‚æœSMTPè¿æ¥æˆåŠŸï¼Œä½¿ç”¨æ£€æµ‹åˆ°çš„é…ç½®è¦†ç›–åŸæœ‰è®¾ç½®
        if smtp_success:
            account["smtp_port"] = smtp_client.port
            account["smtp_use_ssl"] = smtp_client.use_ssl
    else:
        smtp_success = False
    
    # å°è¯•åˆ é™¤æµ‹è¯•è¿æ¥çš„æç¤ºæ¶ˆæ¯
    if "testing_message_id" in context.user_data:
        try:
            await context.bot.delete_message(
                chat_id=update.effective_chat.id,
                message_id=context.user_data["testing_message_id"]
            )
        except Exception:
            pass
    
    # å¦‚æœè¿æ¥æµ‹è¯•æˆåŠŸ
    if imap_success and smtp_success:
        # å°†è´¦æˆ·ä¿å­˜åˆ°æ•°æ®åº“
        added_account = AccountOperations.add_account(
            email=account["email"],
            name=account.get("name") or "",
            imap_server=account["imap_server"],
            imap_port=account["imap_port"],
            imap_use_ssl=account["imap_use_ssl"],
            smtp_server=account["smtp_server"],
            smtp_port=account["smtp_port"],
            smtp_use_ssl=account["smtp_use_ssl"],
            username=account["username"],
            password=account["password"]
        )
        
        if added_account:
            # å‘é€æˆåŠŸæ¶ˆæ¯å¹¶è®¾ç½®3ç§’åè‡ªåŠ¨åˆ é™¤
            success_message = await update.message.reply_text(
                "âœ… è´¦æˆ·æ·»åŠ æˆåŠŸï¼\n\n"
                f"é‚®ç®±: {account['email']}\n"
                f"åç§°: {account.get('name') or 'æœªè®¾ç½®'}\n\n"
                "æ‚¨ç°åœ¨å¯ä»¥ä½¿ç”¨æ­¤è´¦æˆ·å‘é€å’Œæ¥æ”¶é‚®ä»¶ã€‚\n"
                "å¯ä»¥ä½¿ç”¨ /accounts å‘½ä»¤æŸ¥çœ‹æ‚¨çš„æ‰€æœ‰è´¦æˆ·ã€‚\n\n"
                "<i>æ­¤æ¶ˆæ¯å°†åœ¨3ç§’åè‡ªåŠ¨åˆ é™¤</i>",
                parse_mode="HTML",
                disable_notification=True
            )
            
            # è®¾ç½®3ç§’ååˆ é™¤æˆåŠŸæ¶ˆæ¯
            context.job_queue.run_once(
                lambda ctx: delete_message(ctx, update.effective_chat.id, success_message.message_id),
                3
            )
            
            # è‡ªåŠ¨è§¦å‘æ£€æŸ¥æ–°é‚®ä»¶
            try:
                from app.email.email_monitor import get_email_monitor
                monitor = get_email_monitor()
                
                if monitor:
                    # å‘é€æ­£åœ¨æ£€æŸ¥çš„æ¶ˆæ¯
                    checking_message = await update.message.reply_text(
                        "ğŸ” æ­£åœ¨æ£€æŸ¥æ–°è´¦æˆ·çš„é‚®ä»¶...",
                        disable_notification=True
                    )
                    
                    # æ£€æŸ¥æ–°é‚®ä»¶
                    new_email_count = await monitor.check_emails(context)
                    
                    # æ›´æ–°æ¶ˆæ¯ä¸ºæ£€æŸ¥å®Œæˆ
                    if new_email_count > 0:
                        await checking_message.edit_text(
                            f"âœ… é‚®ä»¶æ£€æŸ¥å®Œæˆï¼å‘ç° {new_email_count} å°æ–°é‚®ä»¶ã€‚"
                        )
                        # è®¾ç½®3ç§’ååˆ é™¤æ£€æŸ¥æ¶ˆæ¯
                        context.job_queue.run_once(
                            lambda ctx: delete_message(ctx, update.effective_chat.id, checking_message.message_id),
                            3
                        )
                    else:
                        await checking_message.edit_text(
                            "âœ… é‚®ä»¶æ£€æŸ¥å®Œæˆï¼æ²¡æœ‰æ–°é‚®ä»¶ã€‚"
                        )
                        # è®¾ç½®3ç§’ååˆ é™¤æ£€æŸ¥æ¶ˆæ¯
                        context.job_queue.run_once(
                            lambda ctx: delete_message(ctx, update.effective_chat.id, checking_message.message_id),
                            3
                        )
            except Exception as e:
                logger.error(f"è‡ªåŠ¨æ£€æŸ¥æ–°é‚®ä»¶æ—¶å‡ºé”™: {e}")
            
            # æ¸…ç†ä¸Šä¸‹æ–‡æ•°æ®
            context.user_data.clear()
            
            # ç»“æŸå¯¹è¯
            return ConversationHandler.END
        else:
            # ä¿å­˜æ•°æ®åº“å¤±è´¥
            error_message = await update.message.reply_text(
                "âŒ è¿æ¥æµ‹è¯•æˆåŠŸï¼Œä½†ä¿å­˜è´¦æˆ·æ—¶å‡ºé”™ã€‚\n"
                "è¯·ç¨åå†è¯•æˆ–è”ç³»ç®¡ç†å‘˜ã€‚",
                disable_notification=True
            )
            
            # æ¸…ç†ä¸Šä¸‹æ–‡æ•°æ®
            context.user_data.clear()
            
            # ç»“æŸå¯¹è¯
            return ConversationHandler.END
    else:
        # è¿æ¥æµ‹è¯•å¤±è´¥
        if not imap_success:
            error_type = "IMAPè¿æ¥"
        else:
            error_type = "SMTPè¿æ¥" 
            
        # æç¤ºè¿æ¥æµ‹è¯•å¤±è´¥ï¼Œéœ€è¦é‡æ–°å¼€å§‹
        await update.message.reply_text(
            f"âŒ {error_type}æµ‹è¯•å¤±è´¥ï¼\n\n"
            f"è¯·æ£€æŸ¥æ‚¨çš„é‚®ç®±åœ°å€ã€ç”¨æˆ·åå’Œå¯†ç æ˜¯å¦æ­£ç¡®ã€‚\n"
            f"å¯¹äºGmailç­‰éœ€è¦ä¸¤æ­¥éªŒè¯çš„é‚®ç®±ï¼Œè¯·ç¡®ä¿ä½¿ç”¨äº†åº”ç”¨ä¸“ç”¨å¯†ç ã€‚\n\n"
            f"è¯·ä½¿ç”¨ /addaccount é‡æ–°å¼€å§‹æ·»åŠ æµç¨‹ã€‚",
            disable_notification=True
        )
        
        # æ¸…ç†ä¸Šä¸‹æ–‡æ•°æ®
        context.user_data.clear()
        
        # ç»“æŸå¯¹è¯
        return ConversationHandler.END

async def handle_cancel_account(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """å¤„ç†å–æ¶ˆè´¦æˆ·æ·»åŠ """
    # åˆ é™¤æ‰€æœ‰å·²äº§ç”Ÿçš„æ¶ˆæ¯
    if "last_step_message_ids" in context.user_data:
        for msg_id in context.user_data["last_step_message_ids"]:
            try:
                await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=msg_id)
            except Exception:
                pass
    
    # åˆ é™¤æŒ‡å—æ¶ˆæ¯
    if "guide_message_id" in context.user_data:
        try:
            await context.bot.delete_message(
                chat_id=update.effective_chat.id,
                message_id=context.user_data["guide_message_id"]
            )
        except Exception:
            pass
    
    # å‘é€å–æ¶ˆæ¶ˆæ¯å¹¶è®¾ç½®3ç§’åè‡ªåŠ¨åˆ é™¤
    cancel_message = await update.message.reply_text(
        "âŒ å·²å–æ¶ˆæ·»åŠ è´¦æˆ·ã€‚\n\n"
        "æ‚¨å¯ä»¥ä½¿ç”¨ /addaccount å‘½ä»¤é‡æ–°å¼€å§‹ã€‚\n\n"
        "<i>æ­¤æ¶ˆæ¯å°†åœ¨3ç§’åè‡ªåŠ¨åˆ é™¤</i>",
        parse_mode="HTML",
        disable_notification=True
    )
    
    # è®¾ç½®3ç§’ååˆ é™¤å–æ¶ˆæ¶ˆæ¯
    context.job_queue.run_once(
        lambda ctx: delete_message(ctx, update.effective_chat.id, cancel_message.message_id),
        3
    )
    
    # åˆ é™¤ç”¨æˆ·å‘é€çš„å–æ¶ˆå‘½ä»¤
    try:
        await update.message.delete()
    except Exception:
        pass
    
    # æ¸…ç†ä¸Šä¸‹æ–‡æ•°æ®
    context.user_data.clear()
    
    # ç»“æŸå¯¹è¯
    return ConversationHandler.END

async def delete_message(context, chat_id, message_id):
    """åˆ é™¤æŒ‡å®šæ¶ˆæ¯çš„è¾…åŠ©å‡½æ•°"""
    try:
        await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
    except Exception:
        pass

# å¯¹è¯å¤„ç†å‡½æ•°å­—å…¸
addaccount_conversation = {
    ENTER_EMAIL: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_enter_email)],
    ENTER_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_enter_name)],
    ENTER_USERNAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_enter_username)],
    ENTER_PASSWORD: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_enter_password)],
}

# Account conversation handler
def handle_account_conversation():
    """Return a ConversationHandler for account management"""
    return ConversationHandler(
        entry_points=[
            CommandHandler("addaccount", addaccount_command),
            CallbackQueryHandler(handle_add_account_callback, pattern="^add_account$")
        ],
        states=addaccount_conversation,
        fallbacks=[CommandHandler("cancel", handle_cancel_account)],
        name="account_conversation",
        persistent=False
    )

async def handle_delete_account(update: Update, context: ContextTypes.DEFAULT_TYPE, account_id: int) -> None:
    """å¤„ç†åˆ é™¤è´¦æˆ·è¯·æ±‚"""
    query = update.callback_query
    
    # è·å–è´¦æˆ·ä¿¡æ¯
    account = AccountOperations.get_account(account_id)
    
    if not account:
        await query.edit_message_text("âŒ è´¦æˆ·ä¸å­˜åœ¨æˆ–å·²è¢«åˆ é™¤ã€‚")
        return
    
    # æ„å»ºç¡®è®¤åˆ é™¤çš„é”®ç›˜
    keyboard = [
        [
            InlineKeyboardButton("âœ… ç¡®è®¤åˆ é™¤", callback_data=f"confirm_delete_account_{account_id}"),
            InlineKeyboardButton("âŒ å–æ¶ˆ", callback_data="cancel_delete_account"),
        ]
    ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    # å‘é€ç¡®è®¤æ¶ˆæ¯
    await query.edit_message_text(
        f"âš ï¸ <b>åˆ é™¤è´¦æˆ·ç¡®è®¤</b>\n\n"
        f"æ‚¨ç¡®å®šè¦åˆ é™¤ä»¥ä¸‹è´¦æˆ·å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚\n\n"
        f"è´¦æˆ·: <b>{account.email}</b>\n"
        f"åç§°: {account.name or 'æœªè®¾ç½®'}\n",
        reply_markup=reply_markup,
        parse_mode="HTML"
    )

async def handle_confirm_delete_account(update: Update, context: ContextTypes.DEFAULT_TYPE, account_id: int) -> None:
    """å¤„ç†ç¡®è®¤åˆ é™¤è´¦æˆ·"""
    query = update.callback_query
    
    # è·å–è´¦æˆ·ä¿¡æ¯
    account = AccountOperations.get_account(account_id)
    
    if not account:
        await query.edit_message_text("âŒ è´¦æˆ·ä¸å­˜åœ¨æˆ–å·²è¢«åˆ é™¤ã€‚")
        return
    
    # ä¿å­˜è´¦æˆ·é‚®ç®±ä»¥ä¾¿åœ¨åˆ é™¤åæ˜¾ç¤º
    email = account.email
    name = account.name or "æœªè®¾ç½®"
    
    # æ‰§è¡Œåˆ é™¤æ“ä½œ
    success = AccountOperations.delete_account(account_id)
    
    if success:
        await query.edit_message_text(
            f"âœ… è´¦æˆ·åˆ é™¤æˆåŠŸ\n\n"
            f"é‚®ç®±: <b>{email}</b>\n"
            f"åç§°: {name}\n\n"
            f"æ­¤è´¦æˆ·å·²ä»ç³»ç»Ÿä¸­æ°¸ä¹…åˆ é™¤ã€‚",
            parse_mode="HTML"
        )
    else:
        await query.edit_message_text(
            f"âŒ åˆ é™¤è´¦æˆ·æ—¶å‡ºé”™\n\n"
            f"é‚®ç®±: <b>{email}</b>\n"
            f"è¯·ç¨åå†è¯•æˆ–è”ç³»ç®¡ç†å‘˜ã€‚",
            parse_mode="HTML"
        )

async def handle_cancel_delete_account(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """å¤„ç†å–æ¶ˆåˆ é™¤è´¦æˆ·"""
    query = update.callback_query
    
    # é‡æ–°è·å–æ‰€æœ‰è´¦æˆ·å¹¶æ˜¾ç¤ºåˆ—è¡¨
    accounts = AccountOperations.get_all_active_accounts()
    
    if not accounts:
        await query.edit_message_text(
            "ğŸ“­ æ‚¨å·²æ²¡æœ‰ä»»ä½•é‚®ç®±è´¦æˆ·ã€‚\n"
            "ä½¿ç”¨ /addaccount å‘½ä»¤æ·»åŠ æ–°è´¦æˆ·ã€‚"
        )
        return
    
    # æ„å»ºè´¦æˆ·åˆ—è¡¨æ¶ˆæ¯
    accounts_text = "ğŸ“§ <b>å·²æ·»åŠ çš„é‚®ç®±è´¦æˆ·</b>\n\n"
    
    for i, account in enumerate(accounts):
        accounts_text += (
            f"{i+1}. <b>{account.email}</b>\n"
            f"   åç§°: {account.name or 'æœªè®¾ç½®'}\n"
            f"   IMAP: {account.imap_server}:{account.imap_port}\n"
            f"   SMTP: {account.smtp_server}:{account.smtp_port}\n\n"
        )
    
    # æ·»åŠ ç®¡ç†æŒ‰é’®
    keyboard = []
    
    # ä¸ºæ¯ä¸ªè´¦æˆ·æ·»åŠ åˆ é™¤æŒ‰é’®
    for account in accounts:
        keyboard.append([
            InlineKeyboardButton(f"åˆ é™¤ {account.email}", callback_data=f"delete_account_{account.id}")
        ])
    
    # æ·»åŠ "æ·»åŠ æ–°è´¦æˆ·"æŒ‰é’®
    keyboard.append([
        InlineKeyboardButton("æ·»åŠ æ–°è´¦æˆ·", callback_data="add_account")
    ])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text(
        accounts_text,
        reply_markup=reply_markup,
        parse_mode="HTML"
    )

async def reply_command_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    å¤„ç†ç”¨æˆ·å›å¤æ¶ˆæ¯ä¸­çš„ /reply å‘½ä»¤
    
    å½“ç”¨æˆ·å›å¤æŸæ¡é‚®ä»¶é€šçŸ¥å¹¶å‘é€ /reply å‘½ä»¤æ—¶ï¼Œè§¦å‘é‚®ä»¶å›å¤æµç¨‹
    """
    message = update.message
    
    # æ£€æŸ¥æ˜¯å¦æ˜¯å›å¤æŸæ¡æ¶ˆæ¯
    if not message.reply_to_message:
        await message.reply_text("âŒ è¯·å›å¤ä¸€æ¡é‚®ä»¶é€šçŸ¥æ¶ˆæ¯å¹¶ä½¿ç”¨ /reply å‘½ä»¤", disable_notification=True)
        return
    
    # è·å–åŸå§‹æ¶ˆæ¯ID
    original_message_id = message.reply_to_message.message_id
    
    # æ ¹æ®æ¶ˆæ¯IDæŸ¥æ‰¾å¯¹åº”çš„é‚®ä»¶ID
    email_id = MessageOperations.get_email_id_by_telegram_message_id(str(original_message_id))
    
    if not email_id:
        await message.reply_text("âŒ æŠ±æ­‰ï¼Œæ‰¾ä¸åˆ°ä¸æ­¤æ¶ˆæ¯å…³è”çš„é‚®ä»¶", disable_notification=True)
        return
    
    # åˆ é™¤å‘½ä»¤æ¶ˆæ¯ï¼Œä¿æŒèŠå¤©æ•´æ´
    try:
        await message.delete()
    except Exception as e:
        logger.warning(f"æ— æ³•åˆ é™¤å‘½ä»¤æ¶ˆæ¯: {e}")
    
    # åˆ›å»ºå›è°ƒæ•°æ®
    callback_data = f"reply_email_{email_id}"
    
    # åˆ›å»ºä¸€ä¸ªæ¨¡æ‹Ÿçš„å›è°ƒæŸ¥è¯¢å¯¹è±¡æ¥è§¦å‘å›å¤é‚®ä»¶ä¼šè¯
    class MockCallbackQuery:
        def __init__(self, message_obj, data):
            self.message = message_obj
            self.data = data
        
        async def answer(self):
            pass
    
    # åˆ›å»ºæ¨¡æ‹Ÿçš„å›è°ƒæŸ¥è¯¢
    mock_query = MockCallbackQuery(message.reply_to_message, callback_data)
    
    # æ›´æ–°updateå¯¹è±¡ç”¨äºä¼ é€’ç»™handle_reply_email
    update.callback_query = mock_query
    
    # è°ƒç”¨handle_reply_emailå‡½æ•°å¯åŠ¨å›å¤é‚®ä»¶ä¼šè¯
    await handle_reply_email(update, context, email_id)

async def forward_command_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    å¤„ç†ç”¨æˆ·å›å¤æ¶ˆæ¯ä¸­çš„ /forward å‘½ä»¤
    
    å½“ç”¨æˆ·å›å¤æŸæ¡é‚®ä»¶é€šçŸ¥å¹¶å‘é€ /forward å‘½ä»¤æ—¶ï¼Œè§¦å‘é‚®ä»¶è½¬å‘æµç¨‹
    """
    message = update.message
    
    # æ£€æŸ¥æ˜¯å¦æ˜¯å›å¤æŸæ¡æ¶ˆæ¯
    if not message.reply_to_message:
        await message.reply_text("âŒ è¯·å›å¤ä¸€æ¡é‚®ä»¶é€šçŸ¥æ¶ˆæ¯å¹¶ä½¿ç”¨ /forward å‘½ä»¤", disable_notification=True)
        return
    
    # è·å–åŸå§‹æ¶ˆæ¯ID
    original_message_id = message.reply_to_message.message_id
    
    # æ ¹æ®æ¶ˆæ¯IDæŸ¥æ‰¾å¯¹åº”çš„é‚®ä»¶ID
    email_id = MessageOperations.get_email_id_by_telegram_message_id(str(original_message_id))
    
    if not email_id:
        await message.reply_text("âŒ æŠ±æ­‰ï¼Œæ‰¾ä¸åˆ°ä¸æ­¤æ¶ˆæ¯å…³è”çš„é‚®ä»¶", disable_notification=True)
        return
    
    # åˆ é™¤å‘½ä»¤æ¶ˆæ¯ï¼Œä¿æŒèŠå¤©æ•´æ´
    try:
        await message.delete()
    except Exception as e:
        logger.warning(f"æ— æ³•åˆ é™¤å‘½ä»¤æ¶ˆæ¯: {e}")
    
    # ä½¿ç”¨ç°æœ‰çš„è½¬å‘é‚®ä»¶å¤„ç†å™¨
    # åˆ›å»ºä¸€ä¸ªæ¨¡æ‹Ÿçš„å›è°ƒæŸ¥è¯¢å¯¹è±¡
    class MockCallbackQuery:
        def __init__(self, message_id):
            self.message = message.reply_to_message
            self.data = f"forward_email_{email_id}"
        
        async def answer(self):
            pass
        
        async def edit_message_text(self, text, parse_mode=None):
            return await message.reply_to_message.reply_text(text, parse_mode=parse_mode)
    
    # åˆ›å»ºæ¨¡æ‹Ÿçš„å›è°ƒæŸ¥è¯¢
    mock_query = MockCallbackQuery(original_message_id)
    
    # æ›´æ–°updateå¯¹è±¡ç”¨äºä¼ é€’ç»™handle_forward_email
    update.callback_query = mock_query
    
    # ä½¿ç”¨ç°æœ‰çš„è½¬å‘é‚®ä»¶å¤„ç†å™¨
    await handle_forward_email(update, context, email_id)

# åŸºæœ¬å‘½ä»¤å¤„ç†å‡½æ•°

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """å¤„ç†/startå‘½ä»¤"""
    user = update.effective_user
    
    # è·å–ç”¨æˆ·çš„é‚®ç®±è´¦æˆ·
    accounts = AccountOperations.get_all_active_accounts()
    
    if not accounts:
        # ç”¨æˆ·æ²¡æœ‰æ·»åŠ é‚®ç®±è´¦æˆ·ï¼Œå¼•å¯¼æ·»åŠ ç¬¬ä¸€ä¸ªè´¦æˆ·
        keyboard = [
            [InlineKeyboardButton("æ·»åŠ é‚®ç®±è´¦æˆ·", callback_data="add_account")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_html(
            f"ä½ å¥½ï¼Œ{user.mention_html()}ï¼ğŸ‘‹\n\n"
            f"æ¬¢è¿ä½¿ç”¨TelegramMail - ä½ çš„Telegramé‚®ä»¶åŠ©æ‰‹ã€‚\n\n"
            f"çœ‹èµ·æ¥ä½ è¿˜æ²¡æœ‰æ·»åŠ ä»»ä½•é‚®ç®±è´¦æˆ·ã€‚è¦å¼€å§‹ä½¿ç”¨ï¼Œè¯·å…ˆæ·»åŠ ä¸€ä¸ªé‚®ç®±è´¦æˆ·ã€‚\n\n"
            f"ä½ å¯ä»¥ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®æˆ–ä½¿ç”¨ /addaccount å‘½ä»¤æ·»åŠ è´¦æˆ·ã€‚",
            reply_markup=reply_markup
        )
    else:
        # ç”¨æˆ·å·²æœ‰é‚®ç®±è´¦æˆ·ï¼Œæ˜¾ç¤ºæ­£å¸¸æ¬¢è¿æ¶ˆæ¯
        await update.message.reply_html(
            f"ä½ å¥½ï¼Œ{user.mention_html()}ï¼ğŸ‘‹\n\n"
            f"æ¬¢è¿ä½¿ç”¨TelegramMail - ä½ çš„Telegramé‚®ä»¶åŠ©æ‰‹ã€‚\n\n"
            f"ä½¿ç”¨ /help æŸ¥çœ‹å¯ç”¨å‘½ä»¤ã€‚"
        )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """å¤„ç†/helpå‘½ä»¤"""
    help_text = (
        "ğŸ“¬ <b>TelegramMailå¸®åŠ©</b> ğŸ“¬\n\n"
        "<b>åŸºæœ¬å‘½ä»¤ï¼š</b>\n"
        "/start - å¯åŠ¨æœºå™¨äºº\n"
        "/help - æ˜¾ç¤ºæ­¤å¸®åŠ©ä¿¡æ¯\n"
        "/accounts - æŸ¥çœ‹å·²æ·»åŠ çš„é‚®ç®±è´¦æˆ·\n"
        "/addaccount - æ·»åŠ æ–°é‚®ç®±è´¦æˆ·\n"
        "/check - æ‰‹åŠ¨æ£€æŸ¥æ–°é‚®ä»¶\n\n"
        "<b>å›å¤å‘½ä»¤ï¼š</b>\n"
        "å›å¤æŸæ¡é‚®ä»¶é€šçŸ¥å¹¶å‘é€ /reply - å›å¤è¯¥é‚®ä»¶\n"
        "å›å¤æŸæ¡é‚®ä»¶é€šçŸ¥å¹¶å‘é€ /forward - è½¬å‘è¯¥é‚®ä»¶\n\n"
        "<b>æ¥æ”¶é€šçŸ¥ï¼š</b>\n"
        "å½“ä½ æ”¶åˆ°æ–°é‚®ä»¶æ—¶ï¼Œæœºå™¨äººä¼šè‡ªåŠ¨é€šçŸ¥ä½ ã€‚\n"
        "åˆ é™¤Telegramæ¶ˆæ¯å°†è‡ªåŠ¨åˆ é™¤å¯¹åº”çš„é‚®ä»¶ã€‚"
    )
    await update.message.reply_html(help_text)

async def accounts_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """å¤„ç†/accountså‘½ä»¤ï¼Œåˆ—å‡ºå·²æ·»åŠ çš„é‚®ç®±è´¦æˆ·"""
    accounts = AccountOperations.get_all_active_accounts()
    
    if not accounts:
        await update.message.reply_text(
            "ğŸ“­ æ‚¨è¿˜æ²¡æœ‰æ·»åŠ ä»»ä½•é‚®ç®±è´¦æˆ·ã€‚\n"
            "ä½¿ç”¨ /addaccount å‘½ä»¤æ·»åŠ æ–°è´¦æˆ·ã€‚",
            disable_notification=True
        )
        return
    
    # æ„å»ºè´¦æˆ·åˆ—è¡¨æ¶ˆæ¯
    accounts_text = "ğŸ“§ <b>å·²æ·»åŠ çš„é‚®ç®±è´¦æˆ·</b>\n\n"
    
    for i, account in enumerate(accounts):
        accounts_text += (
            f"{i+1}. <b>{account.email}</b>\n"
            f"   åç§°: {account.name or 'æœªè®¾ç½®'}\n"
            f"   IMAP: {account.imap_server}:{account.imap_port}\n"
            f"   SMTP: {account.smtp_server}:{account.smtp_port}\n\n"
        )
    
    # æ·»åŠ ç®¡ç†æŒ‰é’®
    keyboard = []
    
    # ä¸ºæ¯ä¸ªè´¦æˆ·æ·»åŠ åˆ é™¤æŒ‰é’®
    for account in accounts:
        keyboard.append([
            InlineKeyboardButton(f"åˆ é™¤ {account.email}", callback_data=f"delete_account_{account.id}")
        ])
    
    # æ·»åŠ "æ·»åŠ æ–°è´¦æˆ·"æŒ‰é’®
    keyboard.append([
        InlineKeyboardButton("æ·»åŠ æ–°è´¦æˆ·", callback_data="add_account")
    ])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_html(accounts_text, reply_markup=reply_markup)

async def check_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """å¤„ç†/checkå‘½ä»¤ï¼Œæ‰‹åŠ¨æ£€æŸ¥æ–°é‚®ä»¶"""
    # è·å–é‚®ä»¶ç›‘å¬å™¨å®ä¾‹
    from app.email.email_monitor import get_email_monitor
    monitor = get_email_monitor()
    
    if not monitor:
        await update.message.reply_text(
            "âŒ é‚®ä»¶ç›‘å¬å™¨æœªå¯åŠ¨ï¼Œæ— æ³•æ£€æŸ¥æ–°é‚®ä»¶ã€‚",
            disable_notification=True
        )
        return
    
    # å‘é€æ­£åœ¨æ£€æŸ¥çš„æ¶ˆæ¯
    checking_message = await update.message.reply_text(
        "ğŸ” æ­£åœ¨æ£€æŸ¥æ–°é‚®ä»¶...",
        disable_notification=True
    )
    
    try:
        # æ‰§è¡Œé‚®ä»¶æ£€æŸ¥ï¼Œä¼ å…¥ä¸Šä¸‹æ–‡ç”¨äºå‘é€é€šçŸ¥
        new_email_count = await monitor.check_emails(context)
        
        # æ›´æ–°æ¶ˆæ¯ä¸ºæ£€æŸ¥å®Œæˆ
        if new_email_count > 0:
            await checking_message.edit_text(
                f"âœ… é‚®ä»¶æ£€æŸ¥å®Œæˆï¼å‘ç° {new_email_count} å°æ–°é‚®ä»¶ã€‚",
                disable_notification=True
            )
        else:
            await checking_message.edit_text(
                "âœ… é‚®ä»¶æ£€æŸ¥å®Œæˆï¼æ²¡æœ‰æ–°é‚®ä»¶ã€‚",
                disable_notification=True
            )
    except Exception as e:
        logger.error(f"æ£€æŸ¥é‚®ä»¶æ—¶å‡ºé”™: {e}")
        logger.error(traceback.format_exc())
        await checking_message.edit_text(
            f"âŒ æ£€æŸ¥é‚®ä»¶æ—¶å‡ºé”™: {str(e)}",
            disable_notification=True
        )

async def settings_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """å¤„ç†è®¾ç½®ç›¸å…³çš„å›è°ƒæŸ¥è¯¢"""
    query = update.callback_query
    await query.answer()
    
    callback_data = query.data
    
    if callback_data.startswith("delete_account_"):
        account_id = int(callback_data.split("_")[2])
        await handle_delete_account(update, context, account_id)
    elif callback_data.startswith("confirm_delete_account_"):
        account_id = int(callback_data.split("_")[3])
        await handle_confirm_delete_account(update, context, account_id)
    elif callback_data == "cancel_delete_account":
        await handle_cancel_delete_account(update, context)
    elif callback_data == "add_account":
        # é‡å®šå‘åˆ° addaccount å‘½ä»¤
        await query.message.reply_text(
            "è¯·ä½¿ç”¨ /addaccount å‘½ä»¤æ·»åŠ æ–°é‚®ç®±è´¦æˆ·ã€‚",
            disable_notification=True
        )
    else:
        await query.edit_message_text(
            "æŠ±æ­‰ï¼Œæ— æ³•è¯†åˆ«çš„æ“ä½œã€‚",
            disable_notification=True
        )

# å¯¹è¯çŠ¶æ€å®šä¹‰
# EMAIL, NAME, IMAP_SERVER, IMAP_PORT, SMTP_SERVER, SMTP_PORT, USERNAME, PASSWORD, CONFIRM = range(9)

# å¯¹è¯å¤„ç†å‡½æ•°å­—å…¸
addaccount_conversation = {
    ENTER_EMAIL: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_enter_email)],
    ENTER_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_enter_name)],
    ENTER_USERNAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_enter_username)],
    ENTER_PASSWORD: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_enter_password)],
}

# Account conversation handler (stub for now)
def handle_account_conversation():
    """Return a ConversationHandler for account management"""
    return ConversationHandler(
        entry_points=[
            CommandHandler("addaccount", addaccount_command),
            CallbackQueryHandler(handle_add_account_callback, pattern="^add_account$")
        ],
        states=addaccount_conversation,
        fallbacks=[CommandHandler("cancel", handle_cancel_account)],
        name="account_conversation",
        persistent=False
    )

async def addaccount_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> str:
    """å¤„ç†/addaccountå‘½ä»¤ï¼Œå¼€å§‹æ·»åŠ æ–°é‚®ç®±è´¦æˆ·çš„äº¤äº’è¿‡ç¨‹"""
    # åˆå§‹åŒ–å¯¹è¯çŠ¶æ€çš„å­˜å‚¨
    if "new_account" in context.user_data:
        context.user_data.clear()  # æ¸…é™¤ä»»ä½•æ—§çš„æ•°æ®
    
    # å‘é€å¼•å¯¼ä¿¡æ¯
    message = await update.message.reply_text(
        "ğŸ“¬ <b>æ·»åŠ æ–°é‚®ç®±è´¦æˆ·</b>\n\n"
        "è¯·è¾“å…¥æ‚¨çš„é‚®ç®±åœ°å€ã€‚\n\n"
        "ä¾‹å¦‚: example@gmail.com\n\n"
        "å‘é€ /cancel éšæ—¶å–æ¶ˆæ“ä½œã€‚",
        parse_mode="HTML",
        disable_notification=True
    )
    
    # ä¿å­˜æ­¤æ¶ˆæ¯IDï¼Œä»¥ä¾¿åç»­åˆ é™¤
    context.user_data["guide_message_id"] = message.message_id
    context.user_data["last_step_message_ids"] = []
    
    # è¿”å›ç›¸å…³çŠ¶æ€ï¼Œäº¤ç”±å¯¹è¯å¤„ç†å™¨å¤„ç†
    return ENTER_EMAIL 

async def handle_delete_cancellation(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """å¤„ç†ç”¨æˆ·å–æ¶ˆåˆ é™¤é‚®ä»¶"""
    # è·å–ä¹‹å‰ä¿å­˜çš„æ¶ˆæ¯IDå¹¶åˆ é™¤ç¡®è®¤æ¶ˆæ¯
    if "delete_confirm_message_id" in context.user_data:
        try:
            await context.bot.delete_message(
                chat_id=update.effective_chat.id,
                message_id=context.user_data["delete_confirm_message_id"]
            )
        except Exception as e:
            logger.error(f"åˆ é™¤ç¡®è®¤æ¶ˆæ¯å¤±è´¥: {e}")
    
    # åˆ é™¤ç”¨æˆ·çš„å›å¤æ¶ˆæ¯
    try:
        await update.message.delete()
    except Exception as e:
        logger.error(f"åˆ é™¤ç”¨æˆ·å›å¤æ¶ˆæ¯å¤±è´¥: {e}")
    
    # æ¢å¤æ­£å¸¸é”®ç›˜
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text="å·²å–æ¶ˆåˆ é™¤æ“ä½œã€‚",
        reply_markup=ReplyKeyboardRemove(),
        disable_notification=True
    )
    
    # æ¸…ç†ä¸Šä¸‹æ–‡æ•°æ®
    if "delete_email_id" in context.user_data:
        del context.user_data["delete_email_id"]
    if "delete_origin_message_id" in context.user_data:
        del context.user_data["delete_origin_message_id"]
    if "delete_confirm_message_id" in context.user_data:
        del context.user_data["delete_confirm_message_id"]

async def handle_delete_confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """å¤„ç†ç”¨æˆ·ç¡®è®¤åˆ é™¤é‚®ä»¶"""
    # è·å–è¦åˆ é™¤çš„é‚®ä»¶ID
    if "delete_email_id" not in context.user_data:
        await update.message.reply_text(
            "æ— æ³•å®Œæˆåˆ é™¤æ“ä½œï¼Œé‚®ä»¶IDä¸¢å¤±ã€‚è¯·é‡è¯•ã€‚",
            reply_markup=ReplyKeyboardRemove(),
            disable_notification=True
        )
        return
    
    email_id = context.user_data["delete_email_id"]
    
    # åˆ é™¤ç¡®è®¤æ¶ˆæ¯
    if "delete_confirm_message_id" in context.user_data:
        try:
            await context.bot.delete_message(
                chat_id=update.effective_chat.id,
                message_id=context.user_data["delete_confirm_message_id"]
            )
        except Exception as e:
            logger.error(f"åˆ é™¤ç¡®è®¤æ¶ˆæ¯å¤±è´¥: {e}")
    
    # åˆ é™¤ç”¨æˆ·çš„å›å¤æ¶ˆæ¯
    try:
        await update.message.delete()
    except Exception as e:
        logger.error(f"åˆ é™¤ç”¨æˆ·å›å¤æ¶ˆæ¯å¤±è´¥: {e}")
    
    # ä»æ•°æ®åº“è·å–é‚®ä»¶
    email = get_email_by_id(email_id)
    if not email:
        # é‚®ä»¶ä¸å­˜åœ¨ï¼Œæ˜¾ç¤ºç®€çŸ­é”™è¯¯
        error_message = await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="æŠ±æ­‰ï¼Œæ‰¾ä¸åˆ°è¯¥é‚®ä»¶æˆ–å·²è¢«åˆ é™¤ã€‚",
            reply_markup=ReplyKeyboardRemove(),
            disable_notification=True
        )
        # 3ç§’åè‡ªåŠ¨åˆ é™¤é”™è¯¯æ¶ˆæ¯
        context.job_queue.run_once(
            lambda job_context: delete_message(job_context, update.effective_chat.id, error_message.message_id),
            3
        )
        # æ¸…ç†ä¸Šä¸‹æ–‡æ•°æ®
        _clear_delete_context(context)
        return
    
    # è·å–é‚®ä»¶è´¦æˆ·
    account = get_email_account_by_id(email.account_id)
    if not account:
        # é‚®ç®±è´¦æˆ·ä¸å­˜åœ¨ï¼Œæ˜¾ç¤ºç®€çŸ­é”™è¯¯
        error_message = await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="æŠ±æ­‰ï¼Œæ‰¾ä¸åˆ°è¯¥é‚®ä»¶çš„é‚®ç®±è´¦æˆ·ã€‚",
            reply_markup=ReplyKeyboardRemove(),
            disable_notification=True
        )
        # 3ç§’åè‡ªåŠ¨åˆ é™¤é”™è¯¯æ¶ˆæ¯
        context.job_queue.run_once(
            lambda job_context: delete_message(job_context, update.effective_chat.id, error_message.message_id),
            3
        )
        # æ¸…ç†ä¸Šä¸‹æ–‡æ•°æ®
        _clear_delete_context(context)
        return
    
    # è·å–åŸå§‹é‚®ä»¶æ¶ˆæ¯ID
    origin_message_id = None
    if "delete_origin_message_id" in context.user_data:
        origin_message_id = context.user_data["delete_origin_message_id"]
    
    # è·å–é™„ä»¶æ¶ˆæ¯IDåˆ—è¡¨
    attachment_message_ids = get_attachment_telegram_ids(email_id)
    
    # è¿æ¥åˆ°IMAPæœåŠ¡å™¨å¹¶åˆ é™¤é‚®ä»¶
    imap_delete_success = False
    client = IMAPClient(account=account)
    if await client.connect():
        try:
            # å°è¯•å…ˆåœ¨æ”¶ä»¶ç®±ä¸­æŸ¥æ‰¾
            if await client.select_mailbox():
                message_nums = await client.search_by_message_id(email.message_id)
                if message_nums:
                    # åˆ é™¤é‚®ä»¶
                    imap_delete_success = await client.delete_message(message_nums[0])
                else:
                    # å¦‚æœåœ¨æ”¶ä»¶ç®±ä¸­æ‰¾ä¸åˆ°ï¼Œå°è¯•åœ¨å·²å‘é€æ–‡ä»¶å¤¹ä¸­æŸ¥æ‰¾
                    if await client.select_mailbox('sent'):
                        message_nums = await client.search_by_message_id(email.message_id)
                        if message_nums:
                            # åˆ é™¤å·²å‘é€é‚®ä»¶
                            imap_delete_success = await client.delete_message(message_nums[0])
        except Exception as e:
            logger.error(f"IMAPåˆ é™¤é‚®ä»¶æ—¶å‘ç”Ÿé”™è¯¯: {e}")
        finally:
            client.disconnect()
    
    # æ— è®ºIMAPæ“ä½œæ˜¯å¦æˆåŠŸï¼Œéƒ½åœ¨æ•°æ®åº“ä¸­æ ‡è®°ä¸ºå·²åˆ é™¤
    success = delete_email(email_id)
    
    if success:
        # åˆ é™¤åŸå§‹Telegramæ¶ˆæ¯ï¼ˆä¸æ˜¾ç¤ºä»»ä½•æç¤ºï¼Œç›´æ¥åˆ é™¤ï¼‰
        if origin_message_id:
            try:
                await context.bot.delete_message(
                    chat_id=update.effective_chat.id,
                    message_id=origin_message_id
                )
            except Exception as e:
                logger.error(f"åˆ é™¤åŸå§‹æ¶ˆæ¯å¤±è´¥: {e}")
        
        # åˆ é™¤é™„ä»¶æ¶ˆæ¯
        for msg_id in attachment_message_ids:
            try:
                await context.bot.delete_message(
                    chat_id=update.effective_chat.id,
                    message_id=int(msg_id)
                )
            except Exception as e:
                logger.error(f"åˆ é™¤é™„ä»¶æ¶ˆæ¯å¤±è´¥ (ID: {msg_id}): {e}")
        
        # æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
        success_message = await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"âœ… é‚®ä»¶ \"{html.escape(email.subject)}\" å·²æˆåŠŸåˆ é™¤ã€‚",
            reply_markup=ReplyKeyboardRemove(),
            disable_notification=True
        )
        # 3ç§’åè‡ªåŠ¨åˆ é™¤æˆåŠŸæ¶ˆæ¯
        context.job_queue.run_once(
            lambda job_context: delete_message(job_context, update.effective_chat.id, success_message.message_id),
            3
        )
    else:
        # åªæœ‰åœ¨å‡ºé”™æ—¶æ‰æ˜¾ç¤ºæ¶ˆæ¯
        error_message = await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="âŒ åˆ é™¤é‚®ä»¶æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·é‡è¯•ã€‚",
            reply_markup=ReplyKeyboardRemove(),
            disable_notification=True
        )
        # 3ç§’åè‡ªåŠ¨åˆ é™¤é”™è¯¯æ¶ˆæ¯
        context.job_queue.run_once(
            lambda job_context: delete_message(job_context, update.effective_chat.id, error_message.message_id),
            3
        )
    
    # æ¸…ç†ä¸Šä¸‹æ–‡æ•°æ®
    _clear_delete_context(context)

def _clear_delete_context(context: ContextTypes.DEFAULT_TYPE):
    """æ¸…ç†åˆ é™¤é‚®ä»¶ç›¸å…³çš„ä¸Šä¸‹æ–‡æ•°æ®"""
    if "delete_email_id" in context.user_data:
        del context.user_data["delete_email_id"]
    if "delete_origin_message_id" in context.user_data:
        del context.user_data["delete_origin_message_id"]
    if "delete_confirm_message_id" in context.user_data:
        del context.user_data["delete_confirm_message_id"] 

# åˆ›å»ºæ–°é‚®ä»¶çš„ä¼šè¯çŠ¶æ€
SELECTING_ACCOUNT, ENTER_SUBJECT, ENTER_RECIPIENTS, ENTER_CC, ENTER_BCC, ENTER_BODY, ADD_ATTACHMENTS = range(7)

# å›å¤é‚®ä»¶çš„ä¼šè¯çŠ¶æ€
REPLY_ENTER_RECIPIENTS, REPLY_ENTER_CC, REPLY_ENTER_BCC, REPLY_ENTER_BODY, REPLY_ADD_ATTACHMENTS = range(7, 12)

async def compose_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    å¤„ç† /compose å‘½ä»¤ - å¯åŠ¨æ–°é‚®ä»¶åˆ›å»ºå¯¹è¯
    """
    user_id = update.effective_chat.id
    
    # è·å–ç”¨æˆ·çš„æ‰€æœ‰é‚®ç®±è´¦æˆ·
    accounts = AccountOperations.get_all_active_accounts()
    
    if not accounts:
        await update.message.reply_text(
            "âš ï¸ æ‚¨è¿˜æ²¡æœ‰æ·»åŠ ä»»ä½•é‚®ç®±è´¦æˆ·ã€‚è¯·å…ˆä½¿ç”¨ /addaccount å‘½ä»¤æ·»åŠ ä¸€ä¸ªé‚®ç®±è´¦æˆ·ã€‚",
            disable_notification=True
        )
        return ConversationHandler.END
    
    # åˆ›å»ºä¼˜åŒ–åçš„ReplyKeyboardMarkupè®©ç”¨æˆ·é€‰æ‹©ä¸€ä¸ªè´¦æˆ·
    keyboard = []
    # æ¯è¡Œæ”¾ç½®ä¸¤ä¸ªè´¦æˆ·ï¼Œæé«˜å¸ƒå±€ç¾è§‚åº¦
    for i in range(0, len(accounts), 2):
        row = []
        row.append(accounts[i].email)
        if i + 1 < len(accounts):
            row.append(accounts[i + 1].email)
        keyboard.append(row)
    
    # å•ç‹¬ä¸€è¡Œæ”¾ç½®å–æ¶ˆæŒ‰é’®
    keyboard.append(["âŒ å–æ¶ˆ"])
    
    reply_markup = ReplyKeyboardMarkup(
        keyboard, 
        one_time_keyboard=True,
        resize_keyboard=True,
        input_field_placeholder="é€‰æ‹©ä¸€ä¸ªé‚®ç®±è´¦æˆ·"
    )
    
    # å­˜å‚¨å½“å‰ä¼šè¯çš„æ¶ˆæ¯IDï¼Œä»¥ä¾¿åç»­æ¸…ç†
    context.user_data["compose_messages"] = []
    
    # å‘é€é€‰æ‹©è´¦å·çš„æ¶ˆæ¯
    message = await update.message.reply_text(
        "ğŸ“§ è¯·é€‰æ‹©è¦ä½¿ç”¨çš„å‘é€é‚®ç®±ï¼š",
        reply_markup=reply_markup,
        disable_notification=True
    )
    
    # è®°å½•æ¶ˆæ¯IDä»¥ä¾¿åç»­æ¸…ç†
    context.user_data["compose_messages"].append(message.message_id)
    context.user_data["compose_messages"].append(update.message.message_id)  # è®°å½•ç”¨æˆ·çš„å‘½ä»¤æ¶ˆæ¯
    
    return SELECTING_ACCOUNT

async def select_account(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """å¤„ç†ç”¨æˆ·é€‰æ‹©çš„é‚®ç®±è´¦æˆ·"""
    user_input = update.message.text
    chat_id = update.effective_chat.id
    
    # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å–æ¶ˆæ“ä½œ
    if user_input.lower() == "/cancel" or user_input == "âŒ å–æ¶ˆ":
        await cancel_compose(update, context)
        return ConversationHandler.END
    
    # ä¿å­˜ç”¨æˆ·æ¶ˆæ¯IDä»¥ä¾¿åç»­æ¸…ç†
    context.user_data["compose_messages"].append(update.message.message_id)
    
    # éªŒè¯é€‰æ‹©çš„é‚®ç®±æ˜¯å¦å­˜åœ¨
    account = AccountOperations.get_account_by_email(user_input)
    if not account:
        message = await update.message.reply_text(
            "âš ï¸ æœªæ‰¾åˆ°æ­¤é‚®ç®±è´¦æˆ·ï¼Œè¯·é‡æ–°é€‰æ‹©æˆ–ä½¿ç”¨ /cancel å–æ¶ˆæ“ä½œã€‚",
            reply_markup=ForceReply(selective=True),
            disable_notification=True
        )
        context.user_data["compose_messages"].append(message.message_id)
        return SELECTING_ACCOUNT
    
    # å­˜å‚¨é€‰å®šçš„è´¦æˆ·ä¿¡æ¯
    context.user_data["compose_account_id"] = account.id
    context.user_data["compose_account_email"] = account.email
    
    # æç¤ºç”¨æˆ·è¾“å…¥é‚®ä»¶ä¸»é¢˜
    message = await update.message.reply_text(
        "âœï¸ è¯·è¾“å…¥é‚®ä»¶ä¸»é¢˜ï¼š\n(ä½¿ç”¨ /cancel å–æ¶ˆæ“ä½œ)",
        reply_markup=ForceReply(selective=True),
        disable_notification=True
    )
    context.user_data["compose_messages"].append(message.message_id)
    
    return ENTER_SUBJECT

async def enter_subject(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """å¤„ç†ç”¨æˆ·è¾“å…¥çš„é‚®ä»¶ä¸»é¢˜"""
    user_input = update.message.text
    chat_id = update.effective_chat.id
    
    # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å–æ¶ˆæ“ä½œ
    if user_input.lower() == "/cancel":
        # å–æ¶ˆæ—¶ä¸€æ¬¡æ€§æ¸…ç†æ‰€æœ‰æ¶ˆæ¯
        await cancel_compose(update, context)
        return ConversationHandler.END
    
    # ä¿å­˜ç”¨æˆ·æ¶ˆæ¯IDä»¥ä¾¿åç»­æ¸…ç†
    context.user_data["compose_messages"].append(update.message.message_id)
    
    # å­˜å‚¨é‚®ä»¶ä¸»é¢˜
    context.user_data["compose_subject"] = user_input
    
    # æç¤ºç”¨æˆ·è¾“å…¥æ”¶ä»¶äºº
    message = await update.message.reply_text(
        "ğŸ‘¥ è¯·è¾“å…¥æ”¶ä»¶äººé‚®ç®±åœ°å€ï¼š\n"
        "- å¤šä¸ªæ”¶ä»¶äººè¯·ç”¨é€—å·åˆ†éš”\n"
        "- ä½¿ç”¨ /cancel å–æ¶ˆæ“ä½œ",
        reply_markup=ForceReply(selective=True),
        disable_notification=True
    )
    context.user_data["compose_messages"].append(message.message_id)
    
    return ENTER_RECIPIENTS

async def enter_recipients(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """å¤„ç†ç”¨æˆ·è¾“å…¥çš„æ”¶ä»¶äºº"""
    user_input = update.message.text
    chat_id = update.effective_chat.id
    
    # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å–æ¶ˆæ“ä½œ
    if user_input.lower() == "/cancel":
        # å–æ¶ˆæ—¶ä¸€æ¬¡æ€§æ¸…ç†æ‰€æœ‰æ¶ˆæ¯
        await cancel_compose(update, context)
        return ConversationHandler.END
    
    # ä¿å­˜ç”¨æˆ·æ¶ˆæ¯IDä»¥ä¾¿åç»­æ¸…ç†
    context.user_data["compose_messages"].append(update.message.message_id)
    
    # å¤„ç†æ”¶ä»¶äººåˆ—è¡¨
    recipients = [email.strip() for email in user_input.split(",") if email.strip()]
    
    # éªŒè¯é‚®ç®±æ ¼å¼
    invalid_emails = []
    for email in recipients:
        # ç®€å•éªŒè¯é‚®ç®±æ ¼å¼
        if "@" not in email or "." not in email.split("@")[1]:
            invalid_emails.append(email)
    
    if invalid_emails:
        message = await update.message.reply_text(
            f"âš ï¸ ä»¥ä¸‹é‚®ç®±æ ¼å¼æ— æ•ˆï¼Œè¯·é‡æ–°è¾“å…¥ï¼š\n"
            f"{', '.join(invalid_emails)}\n\n"
            f"è¯·é‡æ–°è¾“å…¥æ‰€æœ‰æ”¶ä»¶äººï¼š",
            reply_markup=ForceReply(selective=True),
            disable_notification=True
        )
        context.user_data["compose_messages"].append(message.message_id)
        return ENTER_RECIPIENTS
    
    # å­˜å‚¨æ”¶ä»¶äººåˆ—è¡¨
    context.user_data["compose_recipients"] = recipients
    
    # æç¤ºç”¨æˆ·è¾“å…¥æŠ„é€(CC)åˆ—è¡¨
    message = await update.message.reply_text(
        "ğŸ“‹ è¯·è¾“å…¥æŠ„é€(CC)åˆ—è¡¨ï¼š\n"
        "- å¤šä¸ªåœ°å€è¯·ç”¨é€—å·åˆ†éš”\n"
        "- å¦‚æœæ²¡æœ‰ï¼Œè¯·ç›´æ¥å›å¤ '-' æˆ– 'æ— '\n"
        "- ä½¿ç”¨ /cancel å–æ¶ˆæ“ä½œ",
        reply_markup=ForceReply(selective=True),
        disable_notification=True
    )
    context.user_data["compose_messages"].append(message.message_id)
    
    return ENTER_CC

async def enter_cc(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """å¤„ç†ç”¨æˆ·è¾“å…¥çš„æŠ„é€åˆ—è¡¨"""
    user_input = update.message.text
    chat_id = update.effective_chat.id
    
    # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å–æ¶ˆæ“ä½œ
    if user_input.lower() == "/cancel":
        # å–æ¶ˆæ—¶ä¸€æ¬¡æ€§æ¸…ç†æ‰€æœ‰æ¶ˆæ¯
        await cancel_compose(update, context)
        return ConversationHandler.END
    
    # ä¿å­˜ç”¨æˆ·æ¶ˆæ¯IDä»¥ä¾¿åç»­æ¸…ç†
    context.user_data["compose_messages"].append(update.message.message_id)
    
    cc_list = []
    
    # æ£€æŸ¥æ˜¯å¦ä¸ºç©º
    if user_input.strip() and user_input.strip() not in ["-", "æ— "]:
        # å¤„ç†æŠ„é€åˆ—è¡¨
        cc_list = [email.strip() for email in user_input.split(",") if email.strip()]
        
        # éªŒè¯é‚®ç®±æ ¼å¼
        invalid_emails = []
        for email in cc_list:
            # ç®€å•éªŒè¯é‚®ç®±æ ¼å¼
            if "@" not in email or "." not in email.split("@")[1]:
                invalid_emails.append(email)
        
        if invalid_emails:
            message = await update.message.reply_text(
                f"âš ï¸ ä»¥ä¸‹é‚®ç®±æ ¼å¼æ— æ•ˆï¼Œè¯·é‡æ–°è¾“å…¥ï¼š\n"
                f"{', '.join(invalid_emails)}\n\n"
                f"è¯·é‡æ–°è¾“å…¥æ‰€æœ‰æŠ„é€åœ°å€ï¼š",
                reply_markup=ForceReply(selective=True),
                disable_notification=True
            )
            context.user_data["compose_messages"].append(message.message_id)
            return ENTER_CC
    
    # å­˜å‚¨æŠ„é€åˆ—è¡¨
    context.user_data["compose_cc"] = cc_list
    
    # æç¤ºç”¨æˆ·è¾“å…¥å¯†é€(BCC)åˆ—è¡¨
    message = await update.message.reply_text(
        "ğŸ”’ è¯·è¾“å…¥å¯†é€(BCC)åˆ—è¡¨ï¼š\n"
        "- å¤šä¸ªåœ°å€è¯·ç”¨é€—å·åˆ†éš”\n"
        "- å¦‚æœæ²¡æœ‰ï¼Œè¯·ç›´æ¥å›å¤ '-' æˆ– 'æ— '\n"
        "- ä½¿ç”¨ /cancel å–æ¶ˆæ“ä½œ",
        reply_markup=ForceReply(selective=True),
        disable_notification=True
    )
    context.user_data["compose_messages"].append(message.message_id)
    
    return ENTER_BCC

async def enter_bcc(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """å¤„ç†ç”¨æˆ·è¾“å…¥çš„å¯†é€åˆ—è¡¨"""
    user_input = update.message.text
    chat_id = update.effective_chat.id
    
    # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å–æ¶ˆæ“ä½œ
    if user_input.lower() == "/cancel":
        # å–æ¶ˆæ—¶ä¸€æ¬¡æ€§æ¸…ç†æ‰€æœ‰æ¶ˆæ¯
        await cancel_compose(update, context)
        return ConversationHandler.END
    
    # ä¿å­˜ç”¨æˆ·æ¶ˆæ¯IDä»¥ä¾¿åç»­æ¸…ç†
    context.user_data["compose_messages"].append(update.message.message_id)
    
    bcc_list = []
    
    # æ£€æŸ¥æ˜¯å¦ä¸ºç©º
    if user_input.strip() and user_input.strip() not in ["-", "æ— "]:
        # å¤„ç†å¯†é€åˆ—è¡¨
        bcc_list = [email.strip() for email in user_input.split(",") if email.strip()]
        
        # éªŒè¯é‚®ç®±æ ¼å¼
        invalid_emails = []
        for email in bcc_list:
            # ç®€å•éªŒè¯é‚®ç®±æ ¼å¼
            if "@" not in email or "." not in email.split("@")[1]:
                invalid_emails.append(email)
        
        if invalid_emails:
            message = await update.message.reply_text(
                f"âš ï¸ ä»¥ä¸‹é‚®ç®±æ ¼å¼æ— æ•ˆï¼Œè¯·é‡æ–°è¾“å…¥ï¼š\n"
                f"{', '.join(invalid_emails)}\n\n"
                f"è¯·é‡æ–°è¾“å…¥æ‰€æœ‰å¯†é€åœ°å€ï¼š",
                reply_markup=ForceReply(selective=True),
                disable_notification=True
            )
            context.user_data["compose_messages"].append(message.message_id)
            return ENTER_BCC
    
    # å­˜å‚¨å¯†é€åˆ—è¡¨
    context.user_data["compose_bcc"] = bcc_list
    
    # æç¤ºç”¨æˆ·è¾“å…¥é‚®ä»¶æ­£æ–‡ï¼Œæ”¯æŒMarkdown
    keyboard = [["âŒ å–æ¶ˆ"]]
    reply_markup = ReplyKeyboardMarkup(
        keyboard, 
        one_time_keyboard=True,
        resize_keyboard=True
    )
    
    message = await update.message.reply_text(
        "âœï¸ è¯·è¾“å…¥é‚®ä»¶æ­£æ–‡ï¼š\n\n"
        "ğŸ“ æ”¯æŒMarkdownæ ¼å¼ï¼š\n"
        "â€¢ æ–œä½“ï¼š*æ–‡æœ¬*\n"
        "â€¢ é“¾æ¥ï¼š[æ–‡æœ¬](URL)\n"
        "â€¢ æ ‡é¢˜ï¼š# æ ‡é¢˜1, ## æ ‡é¢˜2\n"
        "â€¢ æœ‰åºåˆ—è¡¨ï¼š1. é¡¹ç›®1\n"
        "â€¢ æ— åºåˆ—è¡¨ï¼š- é¡¹ç›®æˆ–* é¡¹ç›®\n"
        "â€¢ å¼•ç”¨ï¼š> å¼•ç”¨æ–‡æœ¬\n\n"
        "âš ï¸ ç‰¹æ®Šæ ¼å¼æ ‡è®°ï¼ˆTelegramä¼šæ¸²æŸ“å¸¸è§„æ ‡è®°å¯¼è‡´æ ¼å¼ä¸¢å¤±ï¼‰ï¼š\n"
        "â€¢ åŠ ç²—ï¼š\\*\\*æ–‡æœ¬\\*\\*\n"
        "â€¢ å†…è”ä»£ç ï¼š\\`ä»£ç \\`\n"
        "â€¢ ä»£ç å—ï¼š\n\\`\\`\\`\nä»£ç å—\n\\`\\`\\`\n\n"
        "ğŸ’¡ æç¤ºï¼šä½¿ç”¨ä¸Šè¿°å¸¦è½¬ä¹‰ç¬¦å·çš„æ ¼å¼ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨å¤„ç†æˆæ­£ç¡®çš„æ ¼å¼å‘é€\n\n"
        "ğŸ“Œ ç¡®ä¿ç©ºè¡Œæ­£ç¡®ä»¥ä¿æŒæ®µè½æ ¼å¼",
        reply_markup=reply_markup,
        disable_notification=True
    )
    context.user_data["compose_messages"].append(message.message_id)
    
    return ENTER_BODY

async def enter_body(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """å¤„ç†ç”¨æˆ·è¾“å…¥çš„é‚®ä»¶æ­£æ–‡"""
    user_input = update.message.text
    chat_id = update.effective_chat.id
    
    # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å–æ¶ˆæ“ä½œ
    if user_input.lower() == "/cancel" or user_input == "âŒ å–æ¶ˆ":
        # å–æ¶ˆæ—¶ä¸€æ¬¡æ€§æ¸…ç†æ‰€æœ‰æ¶ˆæ¯
        await cancel_compose(update, context)
        return ConversationHandler.END
    
    # ä¿å­˜ç”¨æˆ·æ¶ˆæ¯IDä»¥ä¾¿åç»­æ¸…ç†
    context.user_data["compose_messages"].append(update.message.message_id)
    
    # å­˜å‚¨é‚®ä»¶æ­£æ–‡
    context.user_data["compose_body"] = user_input
    
    # æç¤ºç”¨æˆ·æ·»åŠ é™„ä»¶
    keyboard = [
        ["âœ… å‘é€é‚®ä»¶ï¼ˆæ— é™„ä»¶ï¼‰"],
        ["ğŸ“ æ·»åŠ é™„ä»¶"],
        ["âŒ å–æ¶ˆ"]
    ]
    reply_markup = ReplyKeyboardMarkup(
        keyboard, 
        one_time_keyboard=True,
        resize_keyboard=True
    )
    
    message = await update.message.reply_text(
        """ğŸ“© æ‚¨çš„é‚®ä»¶å·²å‡†å¤‡å°±ç»ª!

æ‚¨å¯ä»¥é€‰æ‹©ç›´æ¥å‘é€é‚®ä»¶ï¼Œæˆ–è€…æ·»åŠ é™„ä»¶åå‘é€ã€‚

ğŸ“ è‹¥è¦æ·»åŠ é™„ä»¶ï¼Œè¯·ç‚¹å‡»"æ·»åŠ é™„ä»¶"æŒ‰é’®ï¼Œç„¶åä¸Šä¼ æ–‡ä»¶ã€‚
âœ… è‹¥ä¸éœ€è¦é™„ä»¶ï¼Œè¯·ç‚¹å‡»"å‘é€é‚®ä»¶(æ— é™„ä»¶)"æŒ‰é’®ã€‚
âŒ è‹¥è¦å–æ¶ˆå‘é€ï¼Œè¯·ç‚¹å‡»"å–æ¶ˆ"æŒ‰é’®ã€‚""",
        reply_markup=reply_markup,
        disable_notification=True
    )
    context.user_data["compose_messages"].append(message.message_id)
    
    # åˆå§‹åŒ–é™„ä»¶åˆ—è¡¨
    if "compose_attachments" not in context.user_data:
        context.user_data["compose_attachments"] = []
    
    return ADD_ATTACHMENTS

async def handle_attachments(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """å¤„ç†ç”¨æˆ·é€‰æ‹©çš„é™„ä»¶æ“ä½œ"""
    chat_id = update.effective_chat.id
    
    # ä¿å­˜ç”¨æˆ·æ¶ˆæ¯IDä»¥ä¾¿åç»­æ¸…ç†
    context.user_data["compose_messages"].append(update.message.message_id)
    
    # åˆå§‹åŒ–é™„ä»¶åˆ—è¡¨ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
    if "compose_attachments" not in context.user_data:
        context.user_data["compose_attachments"] = []
    
    # åˆ¤æ–­æ˜¯å¦ä¸ºåª’ä½“æ¶ˆæ¯
    is_media = (update.message.document or update.message.photo or 
                hasattr(update.message, 'media_group_id') and update.message.media_group_id)
    
    # å¤„ç†åª’ä½“ï¼ˆæ–‡æ¡£ã€ç…§ç‰‡ç­‰ï¼‰
    if is_media:
        # æ£€æŸ¥æ˜¯å¦æ˜¯åª’ä½“ç»„ï¼ˆå¤šä¸ªæ–‡ä»¶ï¼‰
        is_media_group = hasattr(update.message, 'media_group_id') and update.message.media_group_id
        
        # æ˜¾ç¤ºå¤„ç†ä¸­çŠ¶æ€æ¶ˆæ¯
        processing_msg = None
        if is_media_group:
            processing_msg = await update.message.reply_text(
                "ğŸ“ æ­£åœ¨å¤„ç†å¤šä¸ªé™„ä»¶ï¼Œè¯·ç¨å€™...",
                disable_notification=True
            )
            context.user_data["compose_messages"].append(processing_msg.message_id)
        
        added_files = []
        
        # å¤„ç†æ–‡æ¡£
        if update.message.document:
            document = update.message.document
            file_name = document.file_name
            file_id = document.file_id
            mime_type = document.mime_type or "application/octet-stream"
            
            # ä¸‹è½½æ–‡ä»¶
            file = await context.bot.get_file(file_id)
            file_bytes = await file.download_as_bytearray()
            
            # å°†é™„ä»¶æ·»åŠ åˆ°åˆ—è¡¨
            attachment = {
                'filename': file_name,
                'content': file_bytes,
                'content_type': mime_type
            }
            
            context.user_data["compose_attachments"].append(attachment)
            added_files.append(file_name)
        
        # å¤„ç†ç…§ç‰‡
        elif update.message.photo:
            # è·å–æœ€å¤§å°ºå¯¸çš„ç…§ç‰‡
            photo = update.message.photo[-1]
            file_id = photo.file_id
            
            # ç”Ÿæˆæ–‡ä»¶å (ç…§ç‰‡æ²¡æœ‰åŸå§‹æ–‡ä»¶å)
            current_time = datetime.now().strftime("%Y%m%d_%H%M%S")
            file_name = f"photo_{current_time}.jpg"
            
            # ä¸‹è½½æ–‡ä»¶
            file = await context.bot.get_file(file_id)
            file_bytes = await file.download_as_bytearray()
            
            # å°†é™„ä»¶æ·»åŠ åˆ°åˆ—è¡¨
            attachment = {
                'filename': file_name,
                'content': file_bytes,
                'content_type': 'image/jpeg'
            }
            
            context.user_data["compose_attachments"].append(attachment)
            added_files.append(file_name)
        
        # å¦‚æœæ˜¯åª’ä½“ç»„ï¼Œéœ€è¦ç­‰å¾…æ‰€æœ‰æ–‡ä»¶éƒ½å¤„ç†å®Œå†å“åº”
        # è¿™é‡Œæˆ‘ä»¬é€šè¿‡æ£€æŸ¥åª’ä½“ç»„IDæ¥ç¡®å®šæ˜¯å¦æ˜¯åª’ä½“ç»„çš„æœ€åä¸€ä¸ªæ–‡ä»¶
        if is_media_group:
            # å­˜å‚¨å½“å‰åª’ä½“ç»„IDåˆ°ä¸Šä¸‹æ–‡
            media_group_id = update.message.media_group_id
            
            # å¦‚æœç¬¬ä¸€æ¬¡é‡åˆ°è¿™ä¸ªåª’ä½“ç»„ï¼Œåˆå§‹åŒ–è®¡æ•°å™¨å’Œå®šæ—¶å™¨
            if "current_media_group" not in context.user_data:
                context.user_data["current_media_group"] = {
                    "id": media_group_id,
                    "processed_count": 1,
                    "files": [file_name],  # è®°å½•å·²å¤„ç†çš„æ–‡ä»¶
                    "last_update_time": datetime.now(),  # è®°å½•æœ€åæ›´æ–°æ—¶é—´
                    "completion_task": None  # å®Œæˆæ£€æµ‹ä»»åŠ¡
                }
                
                # åˆ›å»ºå®šæ—¶ä»»åŠ¡æ¥æ£€æµ‹å¤„ç†å®Œæˆ
                completion_task = asyncio.create_task(
                    _check_media_group_completion(update, context, chat_id, media_group_id, processing_msg)
                )
                context.user_data["current_media_group"]["completion_task"] = completion_task
                
            elif context.user_data["current_media_group"]["id"] == media_group_id:
                # å¢åŠ å·²å¤„ç†è®¡æ•°å¹¶è®°å½•æ–‡ä»¶
                context.user_data["current_media_group"]["processed_count"] += 1
                context.user_data["current_media_group"]["files"].append(file_name)
                context.user_data["current_media_group"]["last_update_time"] = datetime.now()
                
                # æ›´æ–°å¤„ç†çŠ¶æ€æ¶ˆæ¯
                if processing_msg:
                    try:
                        await processing_msg.edit_text(
                            f"ğŸ“ å·²å¤„ç† {context.user_data['current_media_group']['processed_count']} ä¸ªé™„ä»¶ï¼Œè¯·ç¨å€™..."
                        )
                    except Exception as e:
                        logger.error(f"æ›´æ–°å¤„ç†çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")
            else:
                # å¦‚æœæ˜¯æ–°çš„åª’ä½“ç»„ï¼Œå–æ¶ˆæ—§çš„å®Œæˆæ£€æµ‹ä»»åŠ¡
                old_task = context.user_data["current_media_group"].get("completion_task")
                if old_task and not old_task.done():
                    old_task.cancel()
                    
                # é‡ç½®ä¸ºæ–°çš„åª’ä½“ç»„
                context.user_data["current_media_group"] = {
                    "id": media_group_id,
                    "processed_count": 1,
                    "files": [file_name],
                    "last_update_time": datetime.now(),
                    "completion_task": None
                }
                
                # åˆ›å»ºæ–°çš„å®Œæˆæ£€æµ‹ä»»åŠ¡
                completion_task = asyncio.create_task(
                    _check_media_group_completion(update, context, chat_id, media_group_id, processing_msg)
                )
                context.user_data["current_media_group"]["completion_task"] = completion_task
            
            # ç»§ç»­å¤„ç†å…¶ä»–é™„ä»¶ï¼Œä¸ç«‹å³æ˜¾ç¤ºé€‰é¡¹
            return ADD_ATTACHMENTS
        
        # æ˜¾ç¤ºå½“å‰é™„ä»¶åˆ—è¡¨
        attachment_names = [att['filename'] for att in context.user_data["compose_attachments"]]
        attachment_list = "\n".join([f"- {name}" for name in attachment_names])
        
        # åˆ›å»ºé”®ç›˜æä¾›ç»§ç»­é€‰é¡¹
        keyboard = [
            ["âœ… å‘é€é‚®ä»¶"],
            ["ğŸ“ æ·»åŠ æ›´å¤šé™„ä»¶"],
            ["âŒ å–æ¶ˆ"]
        ]
        reply_markup = ReplyKeyboardMarkup(
            keyboard, 
            one_time_keyboard=True,
            resize_keyboard=True
        )
        
        # æ˜¾ç¤ºæ¶ˆæ¯
        if len(added_files) == 1:
            message_text = f"""âœ… å·²æ·»åŠ é™„ä»¶ï¼š{added_files[0]}

å½“å‰é™„ä»¶åˆ—è¡¨({len(attachment_names)}ä¸ª)ï¼š
{attachment_list}

æ‚¨å¯ä»¥ï¼š
ğŸ“ ç»§ç»­æ·»åŠ æ›´å¤šé™„ä»¶
âœ… å‘é€å¸¦æœ‰å½“å‰é™„ä»¶çš„é‚®ä»¶
âŒ å–æ¶ˆå‘é€"""
        else:
            message_text = f"""âœ… å·²æ·»åŠ æ–°é™„ä»¶

å½“å‰é™„ä»¶åˆ—è¡¨({len(attachment_names)}ä¸ª)ï¼š
{attachment_list}

æ‚¨å¯ä»¥ï¼š
ğŸ“ ç»§ç»­æ·»åŠ æ›´å¤šé™„ä»¶
âœ… å‘é€å¸¦æœ‰å½“å‰é™„ä»¶çš„é‚®ä»¶
âŒ å–æ¶ˆå‘é€"""
        
        # å¦‚æœæœ‰å¤„ç†çŠ¶æ€æ¶ˆæ¯ï¼Œå…ˆåˆ é™¤å®ƒ
        if processing_msg:
            try:
                await context.bot.delete_message(chat_id=chat_id, message_id=processing_msg.message_id)
                # ä»è®°å½•åˆ—è¡¨ä¸­ç§»é™¤ï¼Œé¿å…åç»­é‡å¤åˆ é™¤
                if processing_msg.message_id in context.user_data["compose_messages"]:
                    context.user_data["compose_messages"].remove(processing_msg.message_id)
            except Exception as e:
                logger.error(f"åˆ é™¤å¤„ç†çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")
        
        message = await update.message.reply_text(
            message_text,
            reply_markup=reply_markup,
            disable_notification=True
        )
        context.user_data["compose_messages"].append(message.message_id)
        
        # æ¸…ç†åª’ä½“ç»„çŠ¶æ€
        if "current_media_group" in context.user_data:
            del context.user_data["current_media_group"]
        
        return ADD_ATTACHMENTS
    
    # å¤„ç†æ–‡æœ¬æ¶ˆæ¯
    if update.message.text:
        user_input = update.message.text
        
        # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å–æ¶ˆæ“ä½œ
        if user_input.lower() == "/cancel" or user_input == "âŒ å–æ¶ˆ":
            # å–æ¶ˆæ—¶ä¸€æ¬¡æ€§æ¸…ç†æ‰€æœ‰æ¶ˆæ¯
            await cancel_compose(update, context)
            return ConversationHandler.END
        
        # ç”¨æˆ·é€‰æ‹©å‘é€é‚®ä»¶ï¼ˆæ— é™„ä»¶ï¼‰
        if user_input == "âœ… å‘é€é‚®ä»¶ï¼ˆæ— é™„ä»¶ï¼‰":
            # å‘é€é‚®ä»¶
            await send_composed_email(update, context)
            return ConversationHandler.END
        
        # ç”¨æˆ·é€‰æ‹©æ·»åŠ é™„ä»¶
        if user_input == "ğŸ“ æ·»åŠ é™„ä»¶" or user_input == "ğŸ“ æ·»åŠ æ›´å¤šé™„ä»¶":
            keyboard = [["âŒ å–æ¶ˆ"]]
            reply_markup = ReplyKeyboardMarkup(
                keyboard, 
                one_time_keyboard=True,
                resize_keyboard=True
            )
            
            message = await update.message.reply_text(
                """ğŸ“ è¯·ä¸Šä¼ æ‚¨æƒ³è¦æ·»åŠ çš„é™„ä»¶æ–‡ä»¶ã€‚

âš ï¸ æ‚¨å¯ä»¥ä¸€æ¬¡ä¸Šä¼ å•ä¸ªæ–‡ä»¶æˆ–å¤šä¸ªæ–‡ä»¶ã€‚ä¸Šä¼ åï¼Œæ‚¨å¯ä»¥ç»§ç»­æ·»åŠ æ›´å¤šé™„ä»¶æˆ–å‘é€é‚®ä»¶ã€‚

æ”¯æŒçš„æ–‡ä»¶ç±»å‹ï¼šæ–‡æ¡£ã€å›¾ç‰‡ã€éŸ³é¢‘ã€è§†é¢‘ç­‰ã€‚
æœ€å¤§æ–‡ä»¶å¤§å°ï¼š50MBï¼ˆå—Telegramé™åˆ¶ï¼‰""",
                reply_markup=reply_markup,
                disable_notification=True
            )
            context.user_data["compose_messages"].append(message.message_id)
            
            # ä¿æŒåœ¨åŒä¸€çŠ¶æ€ï¼Œç­‰å¾…æ–‡ä»¶ä¸Šä¼ 
            return ADD_ATTACHMENTS
        
        # ç”¨æˆ·é€‰æ‹©å‘é€å¸¦é™„ä»¶çš„é‚®ä»¶
        if user_input == "âœ… å‘é€é‚®ä»¶":
            # å‘é€é‚®ä»¶
            await send_composed_email(update, context)
            return ConversationHandler.END
        
        # å¦‚æœæ˜¯å…¶ä»–æ¶ˆæ¯ï¼Œæç¤ºç”¨æˆ·ä¸Šä¼ æ–‡ä»¶
        message = await update.message.reply_text(
            "âš ï¸ è¯·ä¸Šä¼ æ–‡ä»¶ä½œä¸ºé™„ä»¶ï¼Œæˆ–ä»ä¸‹æ–¹é”®ç›˜é€‰æ‹©æ“ä½œã€‚",
            reply_markup=update.message.reply_markup,
            disable_notification=True
        )
        context.user_data["compose_messages"].append(message.message_id)
    
    return ADD_ATTACHMENTS

async def send_composed_email(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """å‘é€å·²åˆ›å»ºçš„é‚®ä»¶"""
    chat_id = update.effective_chat.id
    
    # è·å–è´¦æˆ·ä¿¡æ¯
    account_id = context.user_data.get("compose_account_id")
    account = get_email_account_by_id(account_id)
    
    if not account:
        await update.message.reply_text(
            "âš ï¸ å‘é€é‚®ä»¶æ—¶å‡ºç°é”™è¯¯ï¼šæ— æ³•è·å–é‚®ç®±è´¦æˆ·ä¿¡æ¯ã€‚",
            reply_markup=ReplyKeyboardRemove(),
            disable_notification=True
        )
        # æ¸…ç†æ‰€æœ‰æ¶ˆæ¯
        await clean_compose_messages(context, chat_id)
        return
    
    # è·å–é‚®ä»¶ä¿¡æ¯
    subject = context.user_data.get("compose_subject", "æ— ä¸»é¢˜")
    recipients = context.user_data.get("compose_recipients", [])
    cc_list = context.user_data.get("compose_cc", [])
    bcc_list = context.user_data.get("compose_bcc", [])
    body_markdown = context.user_data.get("compose_body", "")
    attachments = context.user_data.get("compose_attachments", [])
    
    # æ˜¾ç¤ºå‘é€çŠ¶æ€ - ä½¿ç”¨æ–°æ¶ˆæ¯è€Œä¸æ˜¯ç¼–è¾‘
    status_msg = await update.message.reply_text(
        "ğŸ“¤ æ­£åœ¨è¿æ¥åˆ°é‚®ä»¶æœåŠ¡å™¨...",
        reply_markup=ReplyKeyboardRemove(),
        disable_notification=True
    )
    # è®°å½•çŠ¶æ€æ¶ˆæ¯ä»¥ä¾¿åç»­æ¸…ç†
    context.user_data["compose_messages"].append(status_msg.message_id)
    
    # è½¬æ¢Markdownä¸ºHTMLï¼Œå¢å¼ºå¯¹Markdownçš„æ”¯æŒ
    try:
        import markdown
        from markdown.extensions.extra import ExtraExtension
        from markdown.extensions.nl2br import Nl2BrExtension
        from markdown.extensions.sane_lists import SaneListExtension
        from markdown.extensions.fenced_code import FencedCodeExtension
        from markdown.extensions.codehilite import CodeHiliteExtension
        
        # é¢„å¤„ç†Markdownå†…å®¹ï¼Œç¡®ä¿åŠ ç²—å’Œä»£ç å—æ­£ç¡®å¤„ç†
        # é¦–å…ˆç§»é™¤è½¬ä¹‰ç¬¦å·ï¼Œå°†ç”¨æˆ·è¾“å…¥çš„\*\*, \`, \`\`\`è½¬æ¢ä¸ºå®é™…çš„æ ¼å¼æ ‡è®°
        # å¤„ç†è½¬ä¹‰çš„åŠ ç²—æ ‡è®° \*\* -> **
        body_markdown = re.sub(r'\\\*\\\*', '**', body_markdown)
        # å¤„ç†è½¬ä¹‰çš„å†…è”ä»£ç æ ‡è®° \` -> `
        body_markdown = re.sub(r'\\`', '`', body_markdown)
        # å¤„ç†è½¬ä¹‰çš„ä»£ç å—æ ‡è®° \`\`\` -> ```
        body_markdown = re.sub(r'\\`\\`\\`', '```', body_markdown)
        
        html_body = markdown.markdown(
            body_markdown,
            extensions=[
                ExtraExtension(),          # æ”¯æŒè¡¨æ ¼ã€è„šæ³¨ç­‰
                Nl2BrExtension(),          # å°†æ¢è¡Œè½¬æ¢ä¸º<br>æ ‡ç­¾
                SaneListExtension(),        # æ›´å¥½åœ°å¤„ç†åˆ—è¡¨
                FencedCodeExtension(),      # æ”¯æŒä»£ç å—
                CodeHiliteExtension(       # ä»£ç é«˜äº®
                    noclasses=True,         # ä½¿ç”¨è¡Œå†…æ ·å¼è€ŒéCSSç±»
                    pygments_style='default' # ä½¿ç”¨é»˜è®¤é«˜äº®æ ·å¼
                )
            ]
        )
        
        # æ·»åŠ è‡ªå®šä¹‰CSSæ ·å¼ä½¿é‚®ä»¶æ›´ç¾è§‚
        styled_html = f"""
        <html>
        <head>
            <style>
                body {{ font-family: Arial, sans-serif; line-height: 1.6; color: #333; }}
                h1, h2, h3 {{ color: #2c3e50; }}
                a {{ color: #3498db; text-decoration: none; }}
                a:hover {{ text-decoration: underline; }}
                pre {{ background-color: #f8f8f8; padding: 10px; border-radius: 5px; margin: 15px 0; overflow: auto; }}
                code {{ background-color: #f8f8f8; padding: 2px 4px; border-radius: 3px; font-family: Consolas, Monaco, 'Andale Mono', monospace; }}
                strong {{ font-weight: bold; color: #000; }}
                blockquote {{ border-left: 4px solid #ccc; padding-left: 16px; margin-left: 0; color: #777; }}
                ul, ol {{ padding-left: 20px; }}
            </style>
        </head>
        <body>
            {html_body}
        </body>
        </html>
        """
    except ImportError as e:
        # è®°å½•é”™è¯¯ä¿¡æ¯
        logger.error(f"Markdownè½¬æ¢é”™è¯¯: {e}")
        # å¦‚æœæ²¡æœ‰å®‰è£…markdownæ‰©å±•ï¼Œä½¿ç”¨åŸºæœ¬çš„markdownæˆ–çº¯æ–‡æœ¬
        try:
            import markdown
            # æ³¨æ„ï¼šç§»é™¤å¯èƒ½ç ´åæ ¼å¼çš„å¤„ç†
            # body_markdown = re.sub(r'([^\s])\*\*', r'\1 **', body_markdown)
            # body_markdown = re.sub(r'\*\*([^\s])', r'** \1', body_markdown)
            html_body = markdown.markdown(body_markdown)
            
            # æ£€æŸ¥æ˜¯å¦æœ‰åŠ ç²—æ–‡æœ¬çš„æ ‡ç­¾
            has_bold_tags = '<strong>' in html_body
            logger.debug(f"å¤‡ç”¨å¤„ç† - HTMLæ˜¯å¦åŒ…å«åŠ ç²—æ ‡ç­¾: {has_bold_tags}")
            logger.debug(f"å¤‡ç”¨å¤„ç† - ç”Ÿæˆçš„HTMLå†…å®¹: {html_body}")
        except ImportError:
            html_body = body_markdown.replace("\n", "<br>").replace("<", "&lt;").replace(">", "&gt;")
        
        styled_html = f"<html><body>{html_body}</body></html>"
    
    # è°ƒè¯•ä¿¡æ¯
    logger.debug(f"å¤‡ç”¨å¤„ç† - é¢„å¤„ç†åMarkdown: {body_markdown}")
    
    # è®°å½•æœ€ç»ˆHTMLå†…å®¹
    logger.debug(f"å¤‡ç”¨å¤„ç† - æœ€ç»ˆHTMLå†…å®¹å‰500å­—ç¬¦: {styled_html[:500]}")
    
    # å‘é€é‚®ä»¶
    from app.email.smtp_client import SMTPClient
    import ssl
    
    smtp_client = SMTPClient(account=account)
    
    try:
        # å°è¯•è¿æ¥åˆ°SMTPæœåŠ¡å™¨
        connected = await smtp_client.connect()
        
        if not connected:
            final_msg = await update.message.reply_text(
                "âš ï¸ è¿æ¥åˆ°é‚®ä»¶æœåŠ¡å™¨å¤±è´¥ã€‚\n\n"
                "å¯èƒ½çš„åŸå› ï¼š\n"
                "1. æœåŠ¡å™¨åœ°å€æˆ–ç«¯å£é…ç½®é”™è¯¯\n"
                "2. ç½‘ç»œè¿æ¥é—®é¢˜\n"
                "3. é‚®ä»¶æœåŠ¡å™¨æš‚æ—¶ä¸å¯ç”¨\n\n"
                "è¯·ç¨åå†è¯•æˆ–æ£€æŸ¥é‚®ç®±è®¾ç½®ã€‚",
                disable_notification=True
            )
            context.user_data["compose_messages"].append(final_msg.message_id)
            
            # è®¾ç½®å»¶è¿Ÿæ¸…ç†ä»»åŠ¡ï¼ˆ3ç§’åï¼‰
            asyncio.create_task(
                delayed_clean_compose_messages(context, chat_id, 3)
            )
            return
        
        # å°è¯•å‘é€é‚®ä»¶
        sending_msg = await update.message.reply_text("ğŸ“¤ æ­£åœ¨å‘é€é‚®ä»¶å†…å®¹...", disable_notification=True)
        context.user_data["compose_messages"].append(sending_msg.message_id)
        
        # å¦‚æœæœ‰é™„ä»¶ï¼Œæ˜¾ç¤ºæ­£åœ¨å¤„ç†é™„ä»¶çš„æ¶ˆæ¯
        if attachments:
            attachment_msg = await update.message.reply_text(
                f"ğŸ“ æ­£åœ¨å¤„ç† {len(attachments)} ä¸ªé™„ä»¶...",
                disable_notification=True
            )
            context.user_data["compose_messages"].append(attachment_msg.message_id)
        
        # å®šä¹‰å‘é€å¤±è´¥æ—¶çš„é‡è¯•å›è°ƒ
        async def on_retry(retry_count, max_retries):
            # æ›´æ–°å‘é€æ¶ˆæ¯ï¼Œæ˜¾ç¤ºé‡è¯•è¿›åº¦
            await sending_msg.edit_text(f"ğŸ“¤ æ­£åœ¨å‘é€é‚®ä»¶å†…å®¹...\n\nğŸ”„ ç¬¬ {retry_count}/{max_retries} æ¬¡å°è¯•")
        
        # æœ€å¤šå°è¯•3æ¬¡å‘é€
        max_retries = 3
        sent = False
        last_error = None
        
        # æ‰§è¡Œå‘é€æ“ä½œï¼Œå¸¦é‡è¯•
        for retry_count in range(1, max_retries + 1):
            if retry_count > 1:
                # å¦‚æœæ˜¯é‡è¯•ï¼Œæ›´æ–°å‘é€çŠ¶æ€æ¶ˆæ¯
                await on_retry(retry_count, max_retries)
            
            try:
                # å°è¯•å‘é€é‚®ä»¶ - ä¸ä½¿ç”¨è¿›åº¦å›è°ƒ
                sent = await smtp_client.send_email(
                    from_addr=account.email,
                    to_addrs=recipients,
                    subject=subject,
                    text_body=body_markdown,
                    html_body=styled_html,
                    cc_addrs=cc_list if cc_list else None,
                    bcc_addrs=bcc_list if bcc_list else None,
                    attachments=attachments if attachments else None,
                    max_retries=1  # æ¯æ¬¡åªå°è¯•ä¸€æ¬¡ï¼Œå¤–å±‚å¾ªç¯æ§åˆ¶æ€»é‡è¯•æ¬¡æ•°
                )
                
                # å¦‚æœå‘é€æˆåŠŸï¼Œè·³å‡ºå¾ªç¯
                if sent:
                    break
            except ssl.SSLError as e:
                # è®°å½•æœ€åçš„é”™è¯¯
                last_error = e
                logger.error(f"SSLé”™è¯¯ (å°è¯• {retry_count}/{max_retries}): {e}")
                
                # å¦‚æœæ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œä¸å†ç»§ç»­
                if retry_count == max_retries:
                    break
                    
                # ç­‰å¾…çŸ­æš‚æ—¶é—´åé‡è¯•
                await asyncio.sleep(1)
            except ConnectionRefusedError as e:
                # è®°å½•æœ€åçš„é”™è¯¯
                last_error = e
                logger.error(f"è¿æ¥è¢«æ‹’ç» (å°è¯• {retry_count}/{max_retries}): {e}")
                
                # å¦‚æœæ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œä¸å†ç»§ç»­
                if retry_count == max_retries:
                    break
                    
                # ç­‰å¾…çŸ­æš‚æ—¶é—´åé‡è¯•
                await asyncio.sleep(1)
            except Exception as e:
                # è®°å½•æœ€åçš„é”™è¯¯
                last_error = e
                logger.error(f"å‘é€é‚®ä»¶æ—¶å‡ºç°å…¶ä»–é”™è¯¯ (å°è¯• {retry_count}/{max_retries}): {e}")
                
                # å¦‚æœæ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œä¸å†ç»§ç»­
                if retry_count == max_retries:
                    break
                    
                # ç­‰å¾…çŸ­æš‚æ—¶é—´åé‡è¯•
                await asyncio.sleep(1)
        
        if sent:
            # æˆåŠŸå‘é€
            success_msg_text = (
                f"âœ… é‚®ä»¶å·²æˆåŠŸå‘é€ï¼\n\n"
                f"ğŸ“§ ä»: {account.email}\n"
                f"ğŸ“‹ ä¸»é¢˜: {subject}\n"
                f"ğŸ‘¥ æ”¶ä»¶äºº: {', '.join(recipients)}"
            )
            
            if cc_list:
                success_msg_text += f"\nğŸ“ æŠ„é€: {', '.join(cc_list)}"
            
            if bcc_list:
                success_msg_text += f"\nğŸ”’ å¯†é€: {', '.join(bcc_list)}"
                
            if attachments:
                attachment_names = [att['filename'] for att in attachments]
                attachment_list = ", ".join(attachment_names)
                success_msg_text += f"\nğŸ“ é™„ä»¶: {attachment_list}"
            
            success_msg = await update.message.reply_text(success_msg_text, disable_notification=True)
            context.user_data["compose_messages"].append(success_msg.message_id)
            
            # å°è¯•ä»IMAPè·å–æœ€æ–°å‘é€çš„é‚®ä»¶å¹¶å‘é€åˆ°Telegram
            try:
                from app.email.imap_client import IMAPClient
                from app.bot.notifications import send_sent_email_notification
                from app.database.operations import save_email_metadata
                
                # åˆ›å»ºIMAPå®¢æˆ·ç«¯
                imap_client = IMAPClient(account=account)
                
                # è·å–æœ€æ–°å‘é€çš„é‚®ä»¶
                latest_sent_email = await imap_client.get_latest_sent_email()
                
                # æ–­å¼€IMAPè¿æ¥
                imap_client.disconnect()
                
                if latest_sent_email:
                    # æ£€æŸ¥æ”¶ä»¶äººæ˜¯å¦åŒ¹é…ï¼Œç¡®ä¿è·å–çš„æ˜¯åˆšåˆšå‘é€çš„é‚®ä»¶
                    sent_recipients = set(r.lower().strip() for r in latest_sent_email.get('recipients', []))
                    current_recipients = set(r.lower().strip() for r in recipients)
                    
                    if sent_recipients and current_recipients and sent_recipients.intersection(current_recipients):
                        logger.info(f"æ‰¾åˆ°åŒ¹é…çš„å·²å‘é€é‚®ä»¶ï¼Œå°†å‘é€åˆ° Telegram")
                        
                        # ä¿å­˜é‚®ä»¶å…ƒæ•°æ®åˆ°æ•°æ®åº“
                        email_id = save_email_metadata(account.id, latest_sent_email)
                        if email_id:
                            # å‘é€æ— å£°é€šçŸ¥åˆ°Telegram
                            await send_sent_email_notification(context, account.id, latest_sent_email, email_id)
                            logger.info(f"å·²å‘é€é‚®ä»¶é€šçŸ¥å·²å‘é€åˆ°Telegramï¼ŒID: {email_id}")
                        else:
                            logger.error("ä¿å­˜å·²å‘é€é‚®ä»¶å…ƒæ•°æ®å¤±è´¥")
                    else:
                        logger.warning(f"æœ€æ–°å·²å‘é€é‚®ä»¶çš„æ”¶ä»¶äººä¸å½“å‰å‘é€ä¸åŒ¹é…ï¼Œè·³è¿‡é€šçŸ¥")
                else:
                    logger.warning("æœªæ‰¾åˆ°æœ€æ–°å‘é€çš„é‚®ä»¶ï¼Œæ— æ³•å‘é€é€šçŸ¥")
            except Exception as e:
                logger.error(f"è·å–å’Œå‘é€å·²å‘é€é‚®ä»¶é€šçŸ¥æ—¶å‡ºé”™: {e}")
                logger.error(traceback.format_exc())
        else:
            # å‘é€å¤±è´¥ï¼Œä½†æ²¡æœ‰ç‰¹å®šå¼‚å¸¸
            fail_msg = await update.message.reply_text(
                f"âš ï¸ å‘é€é‚®ä»¶å¤±è´¥ (å·²å°è¯• {max_retries} æ¬¡)ã€‚\n\n"
                "å¯èƒ½çš„åŸå› ï¼š\n"
                "1. é‚®ä»¶æœåŠ¡å™¨æ‹’ç»å‘é€è¯·æ±‚\n"
                "2. è¿æ¥ä¸­æ–­\n"
                "3. æ”¶ä»¶äººåœ°å€æ— æ•ˆ\n\n"
                "è¯·ç¨åå†è¯•ã€‚",
                disable_notification=True
            )
            context.user_data["compose_messages"].append(fail_msg.message_id)
    except Exception as e:
        # å¤„ç†å…¶ä»–æœªæ•è·çš„å¼‚å¸¸
        logger.error(f"å‘é€é‚®ä»¶æ—¶å‡ºç°æœªå¤„ç†çš„å¼‚å¸¸: {e}")
        error_msg = await update.message.reply_text(f"âš ï¸ å‘é€é‚®ä»¶æ—¶å‡ºç°æ„å¤–é”™è¯¯ï¼š{str(e)}", disable_notification=True)
        context.user_data["compose_messages"].append(error_msg.message_id)
    finally:
        # æ–­å¼€SMTPè¿æ¥
        smtp_client.disconnect()
        
        # è®¾ç½®å»¶è¿Ÿæ¸…ç†ä»»åŠ¡ï¼ˆ3ç§’åï¼‰
        asyncio.create_task(
            delayed_clean_compose_messages(context, chat_id, 3)
        )
    
    # æ¸…ç†ä¼šè¯æ•°æ®
    if "compose_account_id" in context.user_data:
        del context.user_data["compose_account_id"]
    if "compose_account_email" in context.user_data:
        del context.user_data["compose_account_email"]
    if "compose_subject" in context.user_data:
        del context.user_data["compose_subject"]
    if "compose_recipients" in context.user_data:
        del context.user_data["compose_recipients"]
    if "compose_cc" in context.user_data:
        del context.user_data["compose_cc"]
    if "compose_bcc" in context.user_data:
        del context.user_data["compose_bcc"]
    if "compose_body" in context.user_data:
        del context.user_data["compose_body"]
    if "compose_attachments" in context.user_data:
        del context.user_data["compose_attachments"]

# è¾…åŠ©å‡½æ•°ï¼šå»¶è¿Ÿæ¸…ç†é‚®ä»¶åˆ›å»ºè¿‡ç¨‹ä¸­çš„æ‰€æœ‰æ¶ˆæ¯
async def delayed_clean_compose_messages(context, chat_id, delay=5):
    """å»¶è¿ŸæŒ‡å®šæ—¶é—´åæ¸…ç†æ‰€æœ‰é‚®ä»¶åˆ›å»ºè¿‡ç¨‹çš„æ¶ˆæ¯"""
    await asyncio.sleep(delay)  # ç­‰å¾…æŒ‡å®šçš„å»¶è¿Ÿæ—¶é—´
    await clean_compose_messages(context, chat_id)  # æ¸…ç†æ‰€æœ‰æ¶ˆæ¯

async def cancel_compose(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """å–æ¶ˆåˆ›å»ºé‚®ä»¶"""
    chat_id = update.effective_chat.id
    
    # è®°å½•å½“å‰æ¶ˆæ¯ä»¥ä¾¿åç»­æ¸…ç†
    context.user_data["compose_messages"].append(update.message.message_id)
    
    # å‘é€å–æ¶ˆç¡®è®¤æ¶ˆæ¯
    cancel_msg = await update.message.reply_text(
        "âŒ å·²å–æ¶ˆåˆ›å»ºæ–°é‚®ä»¶ã€‚",
        reply_markup=ReplyKeyboardRemove(),
        disable_notification=True
    )
    context.user_data["compose_messages"].append(cancel_msg.message_id)
    
    # è®¾ç½®å»¶è¿Ÿæ¸…ç†ä»»åŠ¡ï¼ˆ3ç§’åï¼‰
    asyncio.create_task(
        delayed_clean_compose_messages(context, chat_id, 3)
    )
    
    # æ¸…ç†ä¼šè¯æ•°æ®ï¼ˆä½†ä¿ç•™æ¶ˆæ¯IDåˆ—è¡¨ï¼Œå»¶è¿Ÿæ¸…ç†åä¼šåˆ é™¤ï¼‰
    if "compose_account_id" in context.user_data:
        del context.user_data["compose_account_id"]
    if "compose_account_email" in context.user_data:
        del context.user_data["compose_account_email"]
    if "compose_subject" in context.user_data:
        del context.user_data["compose_subject"]
    if "compose_recipients" in context.user_data:
        del context.user_data["compose_recipients"]
    if "compose_cc" in context.user_data:
        del context.user_data["compose_cc"]
    if "compose_bcc" in context.user_data:
        del context.user_data["compose_bcc"]
    if "compose_body" in context.user_data:
        del context.user_data["compose_body"]
    if "compose_attachments" in context.user_data:
        del context.user_data["compose_attachments"]
    
    return ConversationHandler.END

def handle_compose_conversation():
    """åˆ›å»ºå’Œé…ç½®æ–°é‚®ä»¶ä¼šè¯å¤„ç†å™¨"""
    return ConversationHandler(
        entry_points=[CommandHandler("compose", compose_command)],
        states={
            SELECTING_ACCOUNT: [MessageHandler(filters.TEXT & ~filters.COMMAND, select_account)],
            ENTER_SUBJECT: [MessageHandler(filters.TEXT & ~filters.COMMAND, enter_subject)],
            ENTER_RECIPIENTS: [MessageHandler(filters.TEXT & ~filters.COMMAND, enter_recipients)],
            ENTER_CC: [MessageHandler(filters.TEXT & ~filters.COMMAND, enter_cc)],
            ENTER_BCC: [MessageHandler(filters.TEXT & ~filters.COMMAND, enter_bcc)],
            ENTER_BODY: [MessageHandler(filters.TEXT & ~filters.COMMAND, enter_body)],
            ADD_ATTACHMENTS: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_attachments),
                MessageHandler(filters.Document.ALL, handle_attachments),
                MessageHandler(filters.PHOTO, handle_attachments),
            ],
        },
        fallbacks=[CommandHandler("cancel", cancel_compose)],
        name="compose_conversation",
        persistent=False
    )

async def clean_compose_messages(context, chat_id):
    """æ¸…ç†æ–°å»ºé‚®ä»¶ä¼šè¯ä¸­çš„å†å²æ¶ˆæ¯"""
    if "compose_messages" in context.user_data and context.user_data["compose_messages"]:
        try:
            # ä½¿ç”¨delete_messagesæ‰¹é‡åˆ é™¤æ¶ˆæ¯
            await context.bot.delete_messages(
                chat_id=chat_id,
                message_ids=context.user_data["compose_messages"]
            )
        except Exception as e:
            # å¦‚æœæ‰¹é‡åˆ é™¤å¤±è´¥ï¼Œå›é€€åˆ°é€ä¸ªåˆ é™¤
            logger.error(f"æ‰¹é‡åˆ é™¤æ¶ˆæ¯å¤±è´¥: {e}ï¼Œå°è¯•é€ä¸ªåˆ é™¤")
            for msg_id in context.user_data["compose_messages"]:
                try:
                    await context.bot.delete_message(chat_id=chat_id, message_id=msg_id)
                except Exception as inner_e:
                    # å¿½ç•¥æ— æ³•åˆ é™¤çš„æ¶ˆæ¯é”™è¯¯
                    logger.debug(f"æ— æ³•åˆ é™¤æ¶ˆæ¯ {msg_id}: {inner_e}")
        
        # æ¸…ç©ºæ¶ˆæ¯IDåˆ—è¡¨
        context.user_data["compose_messages"] = []

async def _check_media_group_completion(update, context, chat_id, media_group_id, processing_msg):
    """
    æ£€æŸ¥åª’ä½“ç»„æ˜¯å¦å·²å®Œæˆå¤„ç†å¹¶æ˜¾ç¤ºé€‰é¡¹é”®ç›˜
    
    é€šè¿‡ç­‰å¾…ä¸€æ®µæ—¶é—´å¹¶æ£€æŸ¥æ˜¯å¦æœ‰æ–°é™„ä»¶å¤„ç†æ¥åˆ¤æ–­æ˜¯å¦æ‰€æœ‰é™„ä»¶éƒ½å·²æ¥æ”¶
    """
    try:
        # ç­‰å¾…åˆå§‹å»¶è¿Ÿ
        await asyncio.sleep(2.0)
        
        # è®°å½•åˆå§‹è®¡æ•°
        initial_count = context.user_data["current_media_group"]["processed_count"]
        last_count = initial_count
        
        # æ£€æŸ¥å‘¨æœŸ
        max_checks = 5  # æœ€å¤šæ£€æŸ¥5æ¬¡
        for i in range(max_checks):
            # ç­‰å¾…ä¸€æ®µæ—¶é—´åæ£€æŸ¥è®¡æ•°æ˜¯å¦æœ‰å˜åŒ–
            await asyncio.sleep(1.0)
            
            # è·å–å½“å‰è®¡æ•°ï¼ˆå¦‚æœåª’ä½“ç»„ä¿¡æ¯å·²è¢«åˆ é™¤ï¼Œåˆ™è¯´æ˜å¤„ç†å·²å®Œæˆï¼‰
            if "current_media_group" not in context.user_data or context.user_data["current_media_group"]["id"] != media_group_id:
                return
                
            current_count = context.user_data["current_media_group"]["processed_count"]
            
            # å¦‚æœè®¡æ•°å¢åŠ ï¼Œè¡¨ç¤ºè¿˜åœ¨æ¥æ”¶é™„ä»¶
            if current_count > last_count:
                last_count = current_count
                continue
            
            # å¦‚æœè®¡æ•°æ²¡æœ‰å˜åŒ–ï¼Œä¸”å·²ç»æ£€æŸ¥äº†å¤šæ¬¡ï¼Œè®¤ä¸ºæ‰€æœ‰é™„ä»¶éƒ½å·²æ¥æ”¶
            if i >= 2:  # è‡³å°‘æ£€æŸ¥3æ¬¡æ‰èƒ½ç¡®å®š
                logger.info(f"åª’ä½“ç»„ {media_group_id} æ‰€æœ‰é™„ä»¶ä¼¼ä¹å·²æ¥æ”¶å®Œæ¯•ï¼ˆå…±{current_count}ä¸ªï¼‰")
                break
        
        # æ‰€æœ‰é™„ä»¶å¤„ç†å®Œæ¯•ï¼Œæ˜¾ç¤ºé€‰é¡¹é”®ç›˜
        # å‡†å¤‡é™„ä»¶åˆ—è¡¨
        attachment_names = [att['filename'] for att in context.user_data.get("compose_attachments", [])]
        attachment_list = "\n".join([f"- {name}" for name in attachment_names])
        
        # åˆ›å»ºé”®ç›˜
        keyboard = [
            ["âœ… å‘é€é‚®ä»¶"],
            ["ğŸ“ æ·»åŠ æ›´å¤šé™„ä»¶"],
            ["âŒ å–æ¶ˆ"]
        ]
        reply_markup = ReplyKeyboardMarkup(
            keyboard, 
            one_time_keyboard=True,
            resize_keyboard=True
        )
        
        # åˆ é™¤å¤„ç†çŠ¶æ€æ¶ˆæ¯
        if processing_msg:
            try:
                await context.bot.delete_message(chat_id=chat_id, message_id=processing_msg.message_id)
                # ä»è®°å½•åˆ—è¡¨ä¸­ç§»é™¤ï¼Œé¿å…åç»­é‡å¤åˆ é™¤
                if processing_msg.message_id in context.user_data.get("compose_messages", []):
                    context.user_data["compose_messages"].remove(processing_msg.message_id)
            except Exception as e:
                logger.error(f"åˆ é™¤å¤„ç†çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")
        
        # å‘é€å®Œæˆæ¶ˆæ¯å’Œé€‰é¡¹
        completion_message = await update.message.reply_text(
            f"""âœ… å·²æˆåŠŸæ·»åŠ åª’ä½“ç»„é™„ä»¶

å½“å‰é™„ä»¶åˆ—è¡¨({len(attachment_names)}ä¸ª)ï¼š
{attachment_list}

æ‚¨å¯ä»¥ï¼š
ğŸ“ ç»§ç»­æ·»åŠ æ›´å¤šé™„ä»¶
âœ… å‘é€å¸¦æœ‰å½“å‰é™„ä»¶çš„é‚®ä»¶
âŒ å–æ¶ˆå‘é€""",
            reply_markup=reply_markup,
            disable_notification=True
        )
        
        # è®°å½•å®Œæˆæ¶ˆæ¯ID
        if "compose_messages" in context.user_data:
            context.user_data["compose_messages"].append(completion_message.message_id)
        
        # æ¸…ç†åª’ä½“ç»„çŠ¶æ€
        if "current_media_group" in context.user_data and context.user_data["current_media_group"]["id"] == media_group_id:
            del context.user_data["current_media_group"]
            
    except asyncio.CancelledError:
        # ä»»åŠ¡è¢«å–æ¶ˆï¼Œä»€ä¹ˆéƒ½ä¸åš
        pass
    except Exception as e:
        logger.error(f"æ£€æŸ¥åª’ä½“ç»„å®Œæˆæ—¶å‡ºé”™: {e}")
        logger.error(traceback.format_exc())

async def handle_reply_recipients(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """å¤„ç†å›å¤é‚®ä»¶çš„æ”¶ä»¶äººé€‰æ‹©"""
    user_input = update.message.text
    chat_id = update.effective_chat.id
    
    # ä¿å­˜ç”¨æˆ·æ¶ˆæ¯IDä»¥ä¾¿åç»­æ¸…ç†
    context.user_data["reply_messages"].append(update.message.message_id)
    
    # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å–æ¶ˆæ“ä½œ
    if user_input.lower() == "/cancel" or user_input == "âŒ å–æ¶ˆ":
        return await cancel_reply(update, context)
    
    # ä½¿ç”¨é»˜è®¤æ”¶ä»¶äººï¼ˆåŸå‘ä»¶äººï¼‰
    if user_input == "ğŸ“¤ ä½¿ç”¨é»˜è®¤æ”¶ä»¶äººï¼ˆåŸå‘ä»¶äººï¼‰":
        # å·²ç»åœ¨åˆå§‹åŒ–æ—¶è®¾ç½®äº†é»˜è®¤æ”¶ä»¶äººï¼Œç›´æ¥ç»§ç»­
        message = await update.message.reply_text(
            "âœ… å·²è®¾ç½®é»˜è®¤æ”¶ä»¶äººã€‚è¯·é€‰æ‹©ä¸‹ä¸€æ­¥æ“ä½œï¼š",
            reply_markup=ReplyKeyboardMarkup(
                [
                    ["ğŸ‘¥ ç®¡ç†æ”¶ä»¶äººåˆ—è¡¨"],
                    ["ğŸ“‹ ç®¡ç†æŠ„é€åˆ—è¡¨"],
                    ["ğŸ•¶ ç®¡ç†å¯†é€åˆ—è¡¨"],
                    ["âœ… ç»§ç»­ç¼–å†™æ­£æ–‡", "âŒ å–æ¶ˆ"]
                ],
                resize_keyboard=True,
                one_time_keyboard=True
            ),
            disable_notification=True
        )
        context.user_data["reply_messages"].append(message.message_id)
        return REPLY_ENTER_RECIPIENTS
    
    # ç®¡ç†æ”¶ä»¶äººåˆ—è¡¨
    elif user_input == "ğŸ‘¥ ç®¡ç†æ”¶ä»¶äººåˆ—è¡¨":
        # å‡†å¤‡å€™é€‰æ”¶ä»¶äººé”®ç›˜
        keyboard = []
        recipients_candidates = context.user_data["reply_candidates"]["recipients"]
        
        # æ·»åŠ å·²é€‰æ‹©çš„æ”¶ä»¶äººï¼ˆå¦‚æœæœ‰ï¼‰
        current_recipients = context.user_data["reply_recipients"]
        if current_recipients:
            keyboard.append(["ğŸ‘¤ å½“å‰æ”¶ä»¶äºº:"])
            for recipient in current_recipients:
                keyboard.append([f"âŒ ç§»é™¤: {recipient}"])
        
        # æ·»åŠ å€™é€‰æ”¶ä»¶äºº
        if recipients_candidates:
            keyboard.append(["ğŸ‘¥ å€™é€‰æ”¶ä»¶äºº:"])
            for candidate in recipients_candidates:
                if candidate not in current_recipients:
                    keyboard.append([f"â• æ·»åŠ : {candidate}"])
        
        # æ·»åŠ æ“ä½œæŒ‰é’®
        keyboard.append(["â• æ‰‹åŠ¨æ·»åŠ æ”¶ä»¶äºº"])
        keyboard.append(["âœ… å®Œæˆ", "âŒ å–æ¶ˆ"])
        
        reply_markup = ReplyKeyboardMarkup(
            keyboard,
            resize_keyboard=True,
            one_time_keyboard=True
        )
        
        message = await update.message.reply_text(
            "ğŸ‘¥ <b>ç®¡ç†æ”¶ä»¶äººåˆ—è¡¨</b>\n\n"
            "â€¢ ç‚¹å‡»å€™é€‰äººå¯ä»¥å°†å…¶æ·»åŠ åˆ°æ”¶ä»¶äººåˆ—è¡¨\n"
            "â€¢ ç‚¹å‡»ç°æœ‰æ”¶ä»¶äººå¯ä»¥å°†å…¶ç§»é™¤\n"
            "â€¢ é€‰æ‹©ã€Œæ‰‹åŠ¨æ·»åŠ æ”¶ä»¶äººã€å¯ä»¥è¾“å…¥æ–°çš„é‚®ç®±åœ°å€\n"
            "â€¢ å®Œæˆåç‚¹å‡»ã€Œå®Œæˆã€ç»§ç»­",
            parse_mode="HTML",
            reply_markup=reply_markup,
            disable_notification=True
        )
        
        context.user_data["reply_messages"].append(message.message_id)
        context.user_data["reply_recipients_state"] = "managing"
        return REPLY_ENTER_RECIPIENTS
    
    # ç®¡ç†æŠ„é€åˆ—è¡¨
    elif user_input == "ğŸ“‹ ç®¡ç†æŠ„é€åˆ—è¡¨":
        # å‡†å¤‡å€™é€‰æŠ„é€äººé”®ç›˜
        keyboard = []
        cc_candidates = context.user_data["reply_candidates"]["cc"]
        
        # æ·»åŠ å·²é€‰æ‹©çš„æŠ„é€äººï¼ˆå¦‚æœæœ‰ï¼‰
        current_cc = context.user_data["reply_cc"]
        if current_cc:
            keyboard.append(["ğŸ‘¤ å½“å‰æŠ„é€:"])
            for cc in current_cc:
                keyboard.append([f"âŒ ç§»é™¤: {cc}"])
        
        # æ·»åŠ å€™é€‰æŠ„é€äºº
        if cc_candidates:
            keyboard.append(["ğŸ‘¥ å€™é€‰æŠ„é€:"])
            for candidate in cc_candidates:
                if candidate not in current_cc:
                    keyboard.append([f"â• æ·»åŠ : {candidate}"])
        
        # æ·»åŠ æ“ä½œæŒ‰é’®
        keyboard.append(["â• æ‰‹åŠ¨æ·»åŠ æŠ„é€"])
        keyboard.append(["âœ… å®Œæˆ", "âŒ å–æ¶ˆ"])
        
        reply_markup = ReplyKeyboardMarkup(
            keyboard,
            resize_keyboard=True,
            one_time_keyboard=True
        )
        
        message = await update.message.reply_text(
            "ğŸ“‹ <b>ç®¡ç†æŠ„é€åˆ—è¡¨</b>\n\n"
            "â€¢ ç‚¹å‡»å€™é€‰äººå¯ä»¥å°†å…¶æ·»åŠ åˆ°æŠ„é€åˆ—è¡¨\n"
            "â€¢ ç‚¹å‡»ç°æœ‰æŠ„é€äººå¯ä»¥å°†å…¶ç§»é™¤\n"
            "â€¢ é€‰æ‹©ã€Œæ‰‹åŠ¨æ·»åŠ æŠ„é€ã€å¯ä»¥è¾“å…¥æ–°çš„é‚®ç®±åœ°å€\n"
            "â€¢ å®Œæˆåç‚¹å‡»ã€Œå®Œæˆã€ç»§ç»­",
            parse_mode="HTML",
            reply_markup=reply_markup,
            disable_notification=True
        )
        
        context.user_data["reply_messages"].append(message.message_id)
        context.user_data["reply_recipients_state"] = "managing_cc"
        return REPLY_ENTER_CC
    
    # ç®¡ç†å¯†é€åˆ—è¡¨
    elif user_input == "ğŸ•¶ ç®¡ç†å¯†é€åˆ—è¡¨":
        # å‡†å¤‡å€™é€‰å¯†é€äººé”®ç›˜
        keyboard = []
        bcc_candidates = context.user_data["reply_candidates"]["bcc"]
        
        # æ·»åŠ å·²é€‰æ‹©çš„å¯†é€äººï¼ˆå¦‚æœæœ‰ï¼‰
        current_bcc = context.user_data["reply_bcc"]
        if current_bcc:
            keyboard.append(["ğŸ‘¤ å½“å‰å¯†é€:"])
            for bcc in current_bcc:
                keyboard.append([f"âŒ ç§»é™¤: {bcc}"])
        
        # æ·»åŠ å€™é€‰å¯†é€äºº
        if bcc_candidates:
            keyboard.append(["ğŸ‘¥ å€™é€‰å¯†é€:"])
            for candidate in bcc_candidates:
                if candidate not in current_bcc:
                    keyboard.append([f"â• æ·»åŠ : {candidate}"])
        
        # æ·»åŠ æ“ä½œæŒ‰é’®
        keyboard.append(["â• æ‰‹åŠ¨æ·»åŠ å¯†é€"])
        keyboard.append(["âœ… å®Œæˆ", "âŒ å–æ¶ˆ"])
        
        reply_markup = ReplyKeyboardMarkup(
            keyboard,
            resize_keyboard=True,
            one_time_keyboard=True
        )
        
        message = await update.message.reply_text(
            "ğŸ•¶ <b>ç®¡ç†å¯†é€åˆ—è¡¨</b>\n\n"
            "â€¢ ç‚¹å‡»å€™é€‰äººå¯ä»¥å°†å…¶æ·»åŠ åˆ°å¯†é€åˆ—è¡¨\n"
            "â€¢ ç‚¹å‡»ç°æœ‰å¯†é€äººå¯ä»¥å°†å…¶ç§»é™¤\n"
            "â€¢ é€‰æ‹©ã€Œæ‰‹åŠ¨æ·»åŠ å¯†é€ã€å¯ä»¥è¾“å…¥æ–°çš„é‚®ç®±åœ°å€\n"
            "â€¢ å®Œæˆåç‚¹å‡»ã€Œå®Œæˆã€ç»§ç»­",
            parse_mode="HTML",
            reply_markup=reply_markup,
            disable_notification=True
        )
        
        context.user_data["reply_messages"].append(message.message_id)
        context.user_data["reply_recipients_state"] = "managing_bcc"
        return REPLY_ENTER_BCC
    
    # ç»§ç»­ç¼–å†™æ­£æ–‡
    elif user_input == "âœ… ç»§ç»­ç¼–å†™æ­£æ–‡":
        # æ£€æŸ¥æ˜¯å¦è‡³å°‘æœ‰ä¸€ä¸ªæ”¶ä»¶äºº
        if not context.user_data["reply_recipients"]:
            message = await update.message.reply_text(
                "âš ï¸ è¯·è‡³å°‘æ·»åŠ ä¸€ä¸ªæ”¶ä»¶äººåå†ç»§ç»­ã€‚",
                reply_markup=ReplyKeyboardMarkup(
                    [["ğŸ‘¥ ç®¡ç†æ”¶ä»¶äººåˆ—è¡¨"], ["âŒ å–æ¶ˆ"]],
                    resize_keyboard=True,
                    one_time_keyboard=True
                ),
                disable_notification=True
            )
            context.user_data["reply_messages"].append(message.message_id)
            return REPLY_ENTER_RECIPIENTS
        
        # è¿›å…¥æ­£æ–‡ç¼–è¾‘é˜¶æ®µ
        return await prompt_reply_body(update, context)
    
    # å¤„ç†æ”¶ä»¶äººç®¡ç†çŠ¶æ€ä¸‹çš„è¾“å…¥
    elif context.user_data.get("reply_recipients_state") == "managing":
        # æ‰‹åŠ¨æ·»åŠ æ”¶ä»¶äºº
        if user_input == "â• æ‰‹åŠ¨æ·»åŠ æ”¶ä»¶äºº":
            message = await update.message.reply_text(
                "âœï¸ è¯·è¾“å…¥æ”¶ä»¶äººé‚®ç®±åœ°å€ï¼š\n"
                "- å¤šä¸ªæ”¶ä»¶äººè¯·ç”¨é€—å·åˆ†éš”\n"
                "- æˆ–è¾“å…¥ /cancel å–æ¶ˆæ“ä½œ",
                reply_markup=ForceReply(selective=True),
                disable_notification=True
            )
            context.user_data["reply_messages"].append(message.message_id)
            context.user_data["reply_recipients_state"] = "adding_manual"
            return REPLY_ENTER_RECIPIENTS
        
        # å®Œæˆæ”¶ä»¶äººç®¡ç†
        elif user_input == "âœ… å®Œæˆ":
            # è¿”å›ä¸»èœå•
            # ä½¿ç”¨html.escapeå¤„ç†æ˜¾ç¤ºçš„æ”¶ä»¶äººåˆ—è¡¨
            escaped_recipients = [html.escape(r) for r in context.user_data['reply_recipients']] if context.user_data['reply_recipients'] else []
            recipients_display = ", ".join(escaped_recipients)
            
            message = await update.message.reply_text(
                f"âœ… å·²è®¾ç½®æ”¶ä»¶äºº: {recipients_display}ã€‚\nè¯·é€‰æ‹©ä¸‹ä¸€æ­¥æ“ä½œï¼š",
                reply_markup=ReplyKeyboardMarkup(
                    [
                        ["ğŸ‘¥ ç®¡ç†æ”¶ä»¶äººåˆ—è¡¨"],
                        ["ğŸ“‹ ç®¡ç†æŠ„é€åˆ—è¡¨"],
                        ["ğŸ•¶ ç®¡ç†å¯†é€åˆ—è¡¨"],
                        ["âœ… ç»§ç»­ç¼–å†™æ­£æ–‡", "âŒ å–æ¶ˆ"]
                    ],
                    resize_keyboard=True,
                    one_time_keyboard=True
                ),
                parse_mode="HTML",
                disable_notification=True
            )
            context.user_data["reply_messages"].append(message.message_id)
            context.user_data["reply_recipients_state"] = None
            return REPLY_ENTER_RECIPIENTS
        
        # å¤„ç†æ·»åŠ å€™é€‰æ”¶ä»¶äºº
        elif user_input.startswith("â• æ·»åŠ :"):
            recipient = user_input[len("â• æ·»åŠ : "):]
            if recipient not in context.user_data["reply_recipients"]:
                context.user_data["reply_recipients"].append(recipient)
            
            # åˆ·æ–°æ”¶ä»¶äººç®¡ç†é”®ç›˜
            return await refresh_reply_recipients_keyboard(update, context)
        
        # å¤„ç†ç§»é™¤ç°æœ‰æ”¶ä»¶äºº
        elif user_input.startswith("âŒ ç§»é™¤:"):
            recipient = user_input[len("âŒ ç§»é™¤: "):]
            if recipient in context.user_data["reply_recipients"]:
                context.user_data["reply_recipients"].remove(recipient)
            
            # åˆ·æ–°æ”¶ä»¶äººç®¡ç†é”®ç›˜
            return await refresh_reply_recipients_keyboard(update, context)
    
    # å¤„ç†æ‰‹åŠ¨æ·»åŠ æ”¶ä»¶äººçŠ¶æ€ä¸‹çš„è¾“å…¥
    elif context.user_data.get("reply_recipients_state") == "adding_manual":
        # è§£æç”¨æˆ·è¾“å…¥çš„æ”¶ä»¶äºº
        recipients = [r.strip() for r in user_input.split(",") if r.strip()]
        # æ·»åŠ åˆ°æ”¶ä»¶äººåˆ—è¡¨
        for recipient in recipients:
            if recipient not in context.user_data["reply_recipients"]:
                context.user_data["reply_recipients"].append(recipient)
        
        # è¿”å›æ”¶ä»¶äººç®¡ç†ç•Œé¢
        context.user_data["reply_recipients_state"] = "managing"
        return await refresh_reply_recipients_keyboard(update, context)
    
    # å…¶ä»–æƒ…å†µè¿”å›ä¸»èœå•
    message = await update.message.reply_text(
        "âš ï¸ æœªè¯†åˆ«çš„é€‰é¡¹ã€‚è¯·ä»ä¸‹æ–¹é€‰æ‹©æ“ä½œï¼š",
        reply_markup=ReplyKeyboardMarkup(
            [
                ["ğŸ‘¥ ç®¡ç†æ”¶ä»¶äººåˆ—è¡¨"],
                ["ğŸ“‹ ç®¡ç†æŠ„é€åˆ—è¡¨"],
                ["ğŸ•¶ ç®¡ç†å¯†é€åˆ—è¡¨"],
                ["âœ… ç»§ç»­ç¼–å†™æ­£æ–‡", "âŒ å–æ¶ˆ"]
            ],
            resize_keyboard=True,
            one_time_keyboard=True
        ),
        disable_notification=True
    )
    context.user_data["reply_messages"].append(message.message_id)
    return REPLY_ENTER_RECIPIENTS

async def refresh_reply_recipients_keyboard(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """åˆ·æ–°å›å¤é‚®ä»¶æ”¶ä»¶äººç®¡ç†çš„é”®ç›˜"""
    # å‡†å¤‡æ”¶ä»¶äººé”®ç›˜
    keyboard = []
    recipients_candidates = context.user_data["reply_candidates"]["recipients"]
    
    # æ·»åŠ å·²é€‰æ‹©çš„æ”¶ä»¶äººï¼ˆå¦‚æœæœ‰ï¼‰
    current_recipients = context.user_data["reply_recipients"]
    if current_recipients:
        keyboard.append(["ğŸ‘¤ å½“å‰æ”¶ä»¶äºº:"])
        for recipient in current_recipients:
            keyboard.append([f"âŒ ç§»é™¤: {recipient}"])
    
    # æ·»åŠ å€™é€‰æ”¶ä»¶äºº
    if recipients_candidates:
        keyboard.append(["ğŸ‘¥ å€™é€‰æ”¶ä»¶äºº:"])
        for candidate in recipients_candidates:
            if candidate not in current_recipients:
                keyboard.append([f"â• æ·»åŠ : {candidate}"])
    
    # æ·»åŠ æ“ä½œæŒ‰é’®
    keyboard.append(["â• æ‰‹åŠ¨æ·»åŠ æ”¶ä»¶äºº"])
    keyboard.append(["âœ… å®Œæˆ", "âŒ å–æ¶ˆ"])
    
    reply_markup = ReplyKeyboardMarkup(
        keyboard,
        resize_keyboard=True,
        one_time_keyboard=True
    )
    
    # ä½¿ç”¨html.escapeå¤„ç†æ˜¾ç¤ºçš„æ”¶ä»¶äººåˆ—è¡¨
    escaped_recipients = [html.escape(r) for r in current_recipients] if current_recipients else []
    recipients_display = ", ".join(escaped_recipients) if escaped_recipients else "æ— "
    
    message = await update.message.reply_text(
        f"ğŸ‘¥ <b>æ”¶ä»¶äººåˆ—è¡¨å·²æ›´æ–°</b>\n\nå½“å‰æ”¶ä»¶äºº: {recipients_display}\n\n"
        "â€¢ ç‚¹å‡»å€™é€‰äººå¯ä»¥å°†å…¶æ·»åŠ åˆ°æ”¶ä»¶äººåˆ—è¡¨\n"
        "â€¢ ç‚¹å‡»ç°æœ‰æ”¶ä»¶äººå¯ä»¥å°†å…¶ç§»é™¤\n"
        "â€¢ é€‰æ‹©ã€Œæ‰‹åŠ¨æ·»åŠ æ”¶ä»¶äººã€å¯ä»¥è¾“å…¥æ–°çš„é‚®ç®±åœ°å€\n"
        "â€¢ å®Œæˆåç‚¹å‡»ã€Œå®Œæˆã€ç»§ç»­",
        parse_mode="HTML",
        reply_markup=reply_markup,
        disable_notification=True
    )
    
    context.user_data["reply_messages"].append(message.message_id)
    return REPLY_ENTER_RECIPIENTS

async def handle_reply_cc(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """å¤„ç†å›å¤é‚®ä»¶çš„æŠ„é€åˆ—è¡¨"""
    user_input = update.message.text
    
    # ä¿å­˜ç”¨æˆ·æ¶ˆæ¯IDä»¥ä¾¿åç»­æ¸…ç†
    context.user_data["reply_messages"].append(update.message.message_id)
    
    # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å–æ¶ˆæ“ä½œ
    if user_input.lower() == "/cancel" or user_input == "âŒ å–æ¶ˆ":
        return await cancel_reply(update, context)
    
    # å®ŒæˆæŠ„é€ç®¡ç†
    if user_input == "âœ… å®Œæˆ":
        # è¿”å›ä¸»èœå•
        # ä½¿ç”¨html.escapeå¤„ç†æ˜¾ç¤ºçš„æŠ„é€åˆ—è¡¨
        escaped_cc = [html.escape(cc) for cc in context.user_data['reply_cc']] if context.user_data['reply_cc'] else []
        cc_display = ", ".join(escaped_cc) if escaped_cc else 'æ— '
        
        message = await update.message.reply_text(
            f"âœ… å·²è®¾ç½®æŠ„é€: {cc_display}ã€‚\nè¯·é€‰æ‹©ä¸‹ä¸€æ­¥æ“ä½œï¼š",
            reply_markup=ReplyKeyboardMarkup(
                [
                    ["ğŸ‘¥ ç®¡ç†æ”¶ä»¶äººåˆ—è¡¨"],
                    ["ğŸ“‹ ç®¡ç†æŠ„é€åˆ—è¡¨"],
                    ["ğŸ•¶ ç®¡ç†å¯†é€åˆ—è¡¨"],
                    ["âœ… ç»§ç»­ç¼–å†™æ­£æ–‡", "âŒ å–æ¶ˆ"]
                ],
                resize_keyboard=True,
                one_time_keyboard=True
            ),
            parse_mode="HTML",
            disable_notification=True
        )
        context.user_data["reply_messages"].append(message.message_id)
        context.user_data["reply_recipients_state"] = None
        return REPLY_ENTER_RECIPIENTS
    
    # æ‰‹åŠ¨æ·»åŠ æŠ„é€
    elif user_input == "â• æ‰‹åŠ¨æ·»åŠ æŠ„é€":
        message = await update.message.reply_text(
            "âœï¸ è¯·è¾“å…¥æŠ„é€é‚®ç®±åœ°å€ï¼š\n"
            "- å¤šä¸ªæŠ„é€åœ°å€è¯·ç”¨é€—å·åˆ†éš”\n"
            "- æˆ–è¾“å…¥ /cancel å–æ¶ˆæ“ä½œ",
            reply_markup=ForceReply(selective=True),
            disable_notification=True
        )
        context.user_data["reply_messages"].append(message.message_id)
        context.user_data["reply_recipients_state"] = "adding_manual_cc"
        return REPLY_ENTER_CC
    
    # å¤„ç†æ·»åŠ å€™é€‰æŠ„é€äºº
    elif user_input.startswith("â• æ·»åŠ :"):
        cc = user_input[len("â• æ·»åŠ : "):]
        if cc not in context.user_data["reply_cc"]:
            context.user_data["reply_cc"].append(cc)
        
        # åˆ·æ–°æŠ„é€ç®¡ç†é”®ç›˜
        return await refresh_reply_cc_keyboard(update, context)
    
    # å¤„ç†ç§»é™¤ç°æœ‰æŠ„é€äºº
    elif user_input.startswith("âŒ ç§»é™¤:"):
        cc = user_input[len("âŒ ç§»é™¤: "):]
        if cc in context.user_data["reply_cc"]:
            context.user_data["reply_cc"].remove(cc)
        
        # åˆ·æ–°æŠ„é€ç®¡ç†é”®ç›˜
        return await refresh_reply_cc_keyboard(update, context)
    
    # å¤„ç†æ‰‹åŠ¨æ·»åŠ æŠ„é€çŠ¶æ€ä¸‹çš„è¾“å…¥
    elif context.user_data.get("reply_recipients_state") == "adding_manual_cc":
        # è§£æç”¨æˆ·è¾“å…¥çš„æŠ„é€äºº
        cc_list = [cc.strip() for cc in user_input.split(",") if cc.strip()]
        # æ·»åŠ åˆ°æŠ„é€äººåˆ—è¡¨
        for cc in cc_list:
            if cc not in context.user_data["reply_cc"]:
                context.user_data["reply_cc"].append(cc)
        
        # è¿”å›æŠ„é€ç®¡ç†ç•Œé¢
        context.user_data["reply_recipients_state"] = "managing_cc"
        return await refresh_reply_cc_keyboard(update, context)
    
    # å…¶ä»–æƒ…å†µç»§ç»­æ˜¾ç¤ºæŠ„é€ç®¡ç†é”®ç›˜
    return await refresh_reply_cc_keyboard(update, context)

async def refresh_reply_cc_keyboard(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """åˆ·æ–°å›å¤é‚®ä»¶æŠ„é€åˆ—è¡¨ç®¡ç†çš„é”®ç›˜"""
    # å‡†å¤‡æŠ„é€é”®ç›˜
    keyboard = []
    cc_candidates = context.user_data["reply_candidates"]["cc"]
    
    # æ·»åŠ å·²é€‰æ‹©çš„æŠ„é€äººï¼ˆå¦‚æœæœ‰ï¼‰
    current_cc = context.user_data["reply_cc"]
    if current_cc:
        keyboard.append(["ğŸ‘¤ å½“å‰æŠ„é€:"])
        for cc in current_cc:
            keyboard.append([f"âŒ ç§»é™¤: {cc}"])
    
    # æ·»åŠ å€™é€‰æŠ„é€äºº
    if cc_candidates:
        keyboard.append(["ğŸ‘¥ å€™é€‰æŠ„é€:"])
        for candidate in cc_candidates:
            if candidate not in current_cc:
                keyboard.append([f"â• æ·»åŠ : {candidate}"])
    
    # æ·»åŠ æ“ä½œæŒ‰é’®
    keyboard.append(["â• æ‰‹åŠ¨æ·»åŠ æŠ„é€"])
    keyboard.append(["âœ… å®Œæˆ", "âŒ å–æ¶ˆ"])
    
    reply_markup = ReplyKeyboardMarkup(
        keyboard,
        resize_keyboard=True,
        one_time_keyboard=True
    )
    
    # ä½¿ç”¨html.escapeå¤„ç†æ˜¾ç¤ºçš„æŠ„é€åˆ—è¡¨
    escaped_cc = [html.escape(cc) for cc in current_cc] if current_cc else []
    cc_display = ", ".join(escaped_cc) if escaped_cc else "æ— "
    
    message = await update.message.reply_text(
        f"ğŸ“‹ <b>æŠ„é€åˆ—è¡¨å·²æ›´æ–°</b>\n\nå½“å‰æŠ„é€: {cc_display}\n\n"
        "â€¢ ç‚¹å‡»å€™é€‰äººå¯ä»¥å°†å…¶æ·»åŠ åˆ°æŠ„é€åˆ—è¡¨\n"
        "â€¢ ç‚¹å‡»ç°æœ‰æŠ„é€äººå¯ä»¥å°†å…¶ç§»é™¤\n"
        "â€¢ é€‰æ‹©ã€Œæ‰‹åŠ¨æ·»åŠ æŠ„é€ã€å¯ä»¥è¾“å…¥æ–°çš„é‚®ç®±åœ°å€\n"
        "â€¢ å®Œæˆåç‚¹å‡»ã€Œå®Œæˆã€ç»§ç»­",
        parse_mode="HTML",
        reply_markup=reply_markup,
        disable_notification=True
    )
    
    context.user_data["reply_messages"].append(message.message_id)
    return REPLY_ENTER_CC

async def handle_reply_bcc(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """å¤„ç†å›å¤é‚®ä»¶çš„å¯†é€åˆ—è¡¨"""
    user_input = update.message.text
    
    # ä¿å­˜ç”¨æˆ·æ¶ˆæ¯IDä»¥ä¾¿åç»­æ¸…ç†
    context.user_data["reply_messages"].append(update.message.message_id)
    
    # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å–æ¶ˆæ“ä½œ
    if user_input.lower() == "/cancel" or user_input == "âŒ å–æ¶ˆ":
        return await cancel_reply(update, context)
    
    # å®Œæˆå¯†é€ç®¡ç†
    if user_input == "âœ… å®Œæˆ":
        # è¿”å›ä¸»èœå•
        # ä½¿ç”¨html.escapeå¤„ç†æ˜¾ç¤ºçš„å¯†é€åˆ—è¡¨
        escaped_bcc = [html.escape(bcc) for bcc in context.user_data['reply_bcc']] if context.user_data['reply_bcc'] else []
        bcc_display = ", ".join(escaped_bcc) if escaped_bcc else 'æ— '
        
        message = await update.message.reply_text(
            f"âœ… å·²è®¾ç½®å¯†é€: {bcc_display}ã€‚\nè¯·é€‰æ‹©ä¸‹ä¸€æ­¥æ“ä½œï¼š",
            reply_markup=ReplyKeyboardMarkup(
                [
                    ["ğŸ‘¥ ç®¡ç†æ”¶ä»¶äººåˆ—è¡¨"],
                    ["ğŸ“‹ ç®¡ç†æŠ„é€åˆ—è¡¨"],
                    ["ğŸ•¶ ç®¡ç†å¯†é€åˆ—è¡¨"],
                    ["âœ… ç»§ç»­ç¼–å†™æ­£æ–‡", "âŒ å–æ¶ˆ"]
                ],
                resize_keyboard=True,
                one_time_keyboard=True
            ),
            parse_mode="HTML",
            disable_notification=True
        )
        context.user_data["reply_messages"].append(message.message_id)
        context.user_data["reply_recipients_state"] = None
        return REPLY_ENTER_RECIPIENTS
    
    # æ‰‹åŠ¨æ·»åŠ å¯†é€
    elif user_input == "â• æ‰‹åŠ¨æ·»åŠ å¯†é€":
        message = await update.message.reply_text(
            "âœï¸ è¯·è¾“å…¥å¯†é€é‚®ç®±åœ°å€ï¼š\n"
            "- å¤šä¸ªå¯†é€åœ°å€è¯·ç”¨é€—å·åˆ†éš”\n"
            "- æˆ–è¾“å…¥ /cancel å–æ¶ˆæ“ä½œ",
            reply_markup=ForceReply(selective=True),
            disable_notification=True
        )
        context.user_data["reply_messages"].append(message.message_id)
        context.user_data["reply_recipients_state"] = "adding_manual_bcc"
        return REPLY_ENTER_BCC
    
    # å¤„ç†æ·»åŠ å€™é€‰å¯†é€äºº
    elif user_input.startswith("â• æ·»åŠ :"):
        bcc = user_input[len("â• æ·»åŠ : "):]
        if bcc not in context.user_data["reply_bcc"]:
            context.user_data["reply_bcc"].append(bcc)
        
        # åˆ·æ–°å¯†é€ç®¡ç†é”®ç›˜
        return await refresh_reply_bcc_keyboard(update, context)
    
    # å¤„ç†ç§»é™¤ç°æœ‰å¯†é€äºº
    elif user_input.startswith("âŒ ç§»é™¤:"):
        bcc = user_input[len("âŒ ç§»é™¤: "):]
        if bcc in context.user_data["reply_bcc"]:
            context.user_data["reply_bcc"].remove(bcc)
        
        # åˆ·æ–°å¯†é€ç®¡ç†é”®ç›˜
        return await refresh_reply_bcc_keyboard(update, context)
    
    # å¤„ç†æ‰‹åŠ¨æ·»åŠ å¯†é€çŠ¶æ€ä¸‹çš„è¾“å…¥
    elif context.user_data.get("reply_recipients_state") == "adding_manual_bcc":
        # è§£æç”¨æˆ·è¾“å…¥çš„å¯†é€äºº
        bcc_list = [bcc.strip() for bcc in user_input.split(",") if bcc.strip()]
        # æ·»åŠ åˆ°å¯†é€äººåˆ—è¡¨
        for bcc in bcc_list:
            if bcc not in context.user_data["reply_bcc"]:
                context.user_data["reply_bcc"].append(bcc)
        
        # è¿”å›å¯†é€ç®¡ç†ç•Œé¢
        context.user_data["reply_recipients_state"] = "managing_bcc"
        return await refresh_reply_bcc_keyboard(update, context)
    
    # å…¶ä»–æƒ…å†µç»§ç»­æ˜¾ç¤ºå¯†é€ç®¡ç†é”®ç›˜
    return await refresh_reply_bcc_keyboard(update, context)

async def refresh_reply_bcc_keyboard(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """åˆ·æ–°å›å¤é‚®ä»¶å¯†é€åˆ—è¡¨ç®¡ç†çš„é”®ç›˜"""
    # å‡†å¤‡å¯†é€é”®ç›˜
    keyboard = []
    bcc_candidates = context.user_data["reply_candidates"]["bcc"]
    
    # æ·»åŠ å·²é€‰æ‹©çš„å¯†é€äººï¼ˆå¦‚æœæœ‰ï¼‰
    current_bcc = context.user_data["reply_bcc"]
    if current_bcc:
        keyboard.append(["ğŸ‘¤ å½“å‰å¯†é€:"])
        for bcc in current_bcc:
            keyboard.append([f"âŒ ç§»é™¤: {bcc}"])
    
    # æ·»åŠ å€™é€‰å¯†é€äºº
    if bcc_candidates:
        keyboard.append(["ğŸ‘¥ å€™é€‰å¯†é€:"])
        for candidate in bcc_candidates:
            if candidate not in current_bcc:
                keyboard.append([f"â• æ·»åŠ : {candidate}"])
    
    # æ·»åŠ æ“ä½œæŒ‰é’®
    keyboard.append(["â• æ‰‹åŠ¨æ·»åŠ å¯†é€"])
    keyboard.append(["âœ… å®Œæˆ", "âŒ å–æ¶ˆ"])
    
    reply_markup = ReplyKeyboardMarkup(
        keyboard,
        resize_keyboard=True,
        one_time_keyboard=True
    )
    
    # ä½¿ç”¨html.escapeå¤„ç†æ˜¾ç¤ºçš„å¯†é€åˆ—è¡¨
    escaped_bcc = [html.escape(bcc) for bcc in current_bcc] if current_bcc else []
    bcc_display = ", ".join(escaped_bcc) if escaped_bcc else "æ— "
    
    message = await update.message.reply_text(
        f"ğŸ•¶ <b>å¯†é€åˆ—è¡¨å·²æ›´æ–°</b>\n\nå½“å‰å¯†é€: {bcc_display}\n\n"
        "â€¢ ç‚¹å‡»å€™é€‰äººå¯ä»¥å°†å…¶æ·»åŠ åˆ°å¯†é€åˆ—è¡¨\n"
        "â€¢ ç‚¹å‡»ç°æœ‰å¯†é€äººå¯ä»¥å°†å…¶ç§»é™¤\n"
        "â€¢ é€‰æ‹©ã€Œæ‰‹åŠ¨æ·»åŠ å¯†é€ã€å¯ä»¥è¾“å…¥æ–°çš„é‚®ç®±åœ°å€\n"
        "â€¢ å®Œæˆåç‚¹å‡»ã€Œå®Œæˆã€ç»§ç»­",
        parse_mode="HTML",
        reply_markup=reply_markup,
        disable_notification=True
    )
    
    context.user_data["reply_messages"].append(message.message_id)
    return REPLY_ENTER_BCC

async def prompt_reply_body(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """æç¤ºç”¨æˆ·è¾“å…¥å›å¤é‚®ä»¶æ­£æ–‡"""
    keyboard = [
        ["âœ… å‘é€", "âŒ å–æ¶ˆ"]
    ]
    
    reply_markup = ReplyKeyboardMarkup(
        keyboard, 
        resize_keyboard=True,
        one_time_keyboard=True,
        input_field_placeholder="è¾“å…¥é‚®ä»¶æ­£æ–‡..."
    )
    
    message = await update.message.reply_text(
        "âœï¸ è¯·è¾“å…¥é‚®ä»¶æ­£æ–‡ï¼š\n\n"
        "ğŸ“ æ”¯æŒMarkdownæ ¼å¼ï¼š\n"
        "â€¢ æ–œä½“ï¼š*æ–‡æœ¬*\n"
        "â€¢ é“¾æ¥ï¼š[æ–‡æœ¬](URL)\n"
        "â€¢ æ ‡é¢˜ï¼š# æ ‡é¢˜1, ## æ ‡é¢˜2\n"
        "â€¢ æœ‰åºåˆ—è¡¨ï¼š1. é¡¹ç›®1\n"
        "â€¢ æ— åºåˆ—è¡¨ï¼š- é¡¹ç›®æˆ–* é¡¹ç›®\n"
        "â€¢ å¼•ç”¨ï¼š> å¼•ç”¨æ–‡æœ¬\n\n"
        "âš ï¸ ç‰¹æ®Šæ ¼å¼æ ‡è®°ï¼ˆTelegramä¼šæ¸²æŸ“å¸¸è§„æ ‡è®°å¯¼è‡´æ ¼å¼ä¸¢å¤±ï¼‰ï¼š\n"
        "â€¢ åŠ ç²—ï¼š\\*\\*æ–‡æœ¬\\*\\*\n"
        "â€¢ å†…è”ä»£ç ï¼š\\`ä»£ç \\`\n"
        "â€¢ ä»£ç å—ï¼š\n\\`\\`\\`\nä»£ç å—\n\\`\\`\\`\n\n"
        "ğŸ’¡ æç¤ºï¼šä½¿ç”¨ä¸Šè¿°å¸¦è½¬ä¹‰ç¬¦å·çš„æ ¼å¼ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨å¤„ç†æˆæ­£ç¡®çš„æ ¼å¼å‘é€\n\n"
        "ğŸ“Œ ç¡®ä¿ç©ºè¡Œæ­£ç¡®ä»¥ä¿æŒæ®µè½æ ¼å¼",
        reply_markup=reply_markup,
        disable_notification=True
    )
    context.user_data["reply_messages"].append(message.message_id)
    
    return REPLY_ENTER_BODY

async def handle_reply_body(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """å¤„ç†ç”¨æˆ·è¾“å…¥çš„å›å¤é‚®ä»¶æ­£æ–‡"""
    user_input = update.message.text
    chat_id = update.effective_chat.id
    
    # ä¿å­˜ç”¨æˆ·æ¶ˆæ¯IDä»¥ä¾¿åç»­æ¸…ç†
    context.user_data["reply_messages"].append(update.message.message_id)
    
    # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å–æ¶ˆæ“ä½œ
    if user_input.lower() == "/cancel" or user_input == "âŒ å–æ¶ˆ":
        return await cancel_reply(update, context)
    
    # å­˜å‚¨é‚®ä»¶æ­£æ–‡
    context.user_data["reply_body"] = user_input
    
    # æç¤ºç”¨æˆ·æ·»åŠ é™„ä»¶
    keyboard = [
        ["âœ… å‘é€é‚®ä»¶ï¼ˆæ— é™„ä»¶ï¼‰"],
        ["ğŸ“ æ·»åŠ é™„ä»¶"],
        ["âŒ å–æ¶ˆ"]
    ]
    reply_markup = ReplyKeyboardMarkup(
        keyboard, 
        one_time_keyboard=True,
        resize_keyboard=True
    )
    
    message = await update.message.reply_text(
        """ğŸ“© æ‚¨çš„å›å¤é‚®ä»¶å·²å‡†å¤‡å°±ç»ª!

æ‚¨å¯ä»¥é€‰æ‹©ç›´æ¥å‘é€é‚®ä»¶ï¼Œæˆ–è€…æ·»åŠ é™„ä»¶åå‘é€ã€‚

ğŸ“ è‹¥è¦æ·»åŠ é™„ä»¶ï¼Œè¯·ç‚¹å‡»"æ·»åŠ é™„ä»¶"æŒ‰é’®ï¼Œç„¶åä¸Šä¼ æ–‡ä»¶ã€‚
âœ… è‹¥ä¸éœ€è¦é™„ä»¶ï¼Œè¯·ç‚¹å‡»"å‘é€é‚®ä»¶(æ— é™„ä»¶)"æŒ‰é’®ã€‚
âŒ è‹¥è¦å–æ¶ˆå‘é€ï¼Œè¯·ç‚¹å‡»"å–æ¶ˆ"æŒ‰é’®ã€‚""",
        reply_markup=reply_markup,
        disable_notification=True
    )
    context.user_data["reply_messages"].append(message.message_id)
    
    # åˆå§‹åŒ–é™„ä»¶åˆ—è¡¨
    if "reply_attachments" not in context.user_data:
        context.user_data["reply_attachments"] = []
    
    return REPLY_ADD_ATTACHMENTS

async def handle_reply_attachments(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """å¤„ç†ç”¨æˆ·é€‰æ‹©çš„é™„ä»¶æ“ä½œï¼ˆé’ˆå¯¹å›å¤é‚®ä»¶ï¼‰"""
    chat_id = update.effective_chat.id
    
    # ä¿å­˜ç”¨æˆ·æ¶ˆæ¯IDä»¥ä¾¿åç»­æ¸…ç†
    context.user_data["reply_messages"].append(update.message.message_id)
    
    # åˆå§‹åŒ–é™„ä»¶åˆ—è¡¨ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
    if "reply_attachments" not in context.user_data:
        context.user_data["reply_attachments"] = []
    
    # å¤„ç†æ–‡æœ¬è¾“å…¥ï¼ˆæŒ‰é’®é€‰æ‹©ï¼‰
    if update.message.text:
        user_input = update.message.text
        
        # å¤„ç†æŒ‰é’®é€‰æ‹©
        if user_input == "âœ… å‘é€é‚®ä»¶ï¼ˆæ— é™„ä»¶ï¼‰" or user_input == "âœ… å‘é€é‚®ä»¶":
            # å‘é€é‚®ä»¶
            return await send_reply_email(update, context)
        
        elif user_input == "âŒ å–æ¶ˆ":
            # å–æ¶ˆå‘é€
            return await cancel_reply(update, context)
        
        elif user_input == "ğŸ“ æ·»åŠ é™„ä»¶" or user_input == "ğŸ“ æ·»åŠ æ›´å¤šé™„ä»¶":
            # æç¤ºç”¨æˆ·ä¸Šä¼ æ–‡ä»¶
            message = await update.message.reply_text(
                "ğŸ“ è¯·ä¸Šä¼ æ–‡ä»¶ä½œä¸ºé™„ä»¶ï¼Œæˆ–é€‰æ‹©ä»¥ä¸‹æ“ä½œï¼š",
                reply_markup=ReplyKeyboardMarkup(
                    [["âœ… å®Œæˆæ·»åŠ ", "âŒ å–æ¶ˆ"]],
                    resize_keyboard=True,
                    one_time_keyboard=True
                ),
                disable_notification=True
            )
            context.user_data["reply_messages"].append(message.message_id)
            return REPLY_ADD_ATTACHMENTS
        
        elif user_input == "âœ… å®Œæˆæ·»åŠ ":
            # è·å–å½“å‰é™„ä»¶åˆ—è¡¨
            attachments = context.user_data.get("reply_attachments", [])
            
            if not attachments:
                # å¦‚æœæ²¡æœ‰é™„ä»¶ï¼Œæç¤ºç”¨æˆ·æ·»åŠ æˆ–ç»§ç»­
                message = await update.message.reply_text(
                    "âš ï¸ æ‚¨è¿˜æ²¡æœ‰æ·»åŠ ä»»ä½•é™„ä»¶ã€‚è¯·ä¸Šä¼ æ–‡ä»¶æˆ–é€‰æ‹©æ“ä½œï¼š",
                    reply_markup=ReplyKeyboardMarkup(
                        [["âœ… å‘é€é‚®ä»¶ï¼ˆæ— é™„ä»¶ï¼‰"], ["âŒ å–æ¶ˆ"]],
                        resize_keyboard=True,
                        one_time_keyboard=True
                    ),
                    disable_notification=True
                )
                context.user_data["reply_messages"].append(message.message_id)
                return REPLY_ADD_ATTACHMENTS
            
            # æ˜¾ç¤ºå½“å‰é™„ä»¶åˆ—è¡¨
            attachment_names = [att['filename'] for att in attachments]
            attachment_list = "\n".join([f"- {name}" for name in attachment_names])
            
            # åˆ›å»ºé”®ç›˜æä¾›ç»§ç»­é€‰é¡¹
            keyboard = [
                ["âœ… å‘é€é‚®ä»¶"],
                ["ğŸ“ æ·»åŠ æ›´å¤šé™„ä»¶"],
                ["âŒ å–æ¶ˆ"]
            ]
            reply_markup = ReplyKeyboardMarkup(
                keyboard, 
                one_time_keyboard=True,
                resize_keyboard=True
            )
            
            message = await update.message.reply_text(
                f"""ğŸ“© æ‚¨çš„å›å¤é‚®ä»¶å·²å‡†å¤‡å°±ç»ª!

å½“å‰é™„ä»¶åˆ—è¡¨({len(attachment_names)}ä¸ª)ï¼š
{attachment_list}

æ‚¨å¯ä»¥ï¼š
ğŸ“ ç»§ç»­æ·»åŠ æ›´å¤šé™„ä»¶
âœ… å‘é€å¸¦æœ‰å½“å‰é™„ä»¶çš„é‚®ä»¶
âŒ å–æ¶ˆå‘é€""",
                reply_markup=reply_markup,
                disable_notification=True
            )
            context.user_data["reply_messages"].append(message.message_id)
            return REPLY_ADD_ATTACHMENTS
    
    # åˆ¤æ–­æ˜¯å¦ä¸ºåª’ä½“æ¶ˆæ¯
    is_media = (update.message.document or update.message.photo or 
                hasattr(update.message, 'media_group_id') and update.message.media_group_id)
    
    # å¤„ç†åª’ä½“ï¼ˆæ–‡æ¡£ã€ç…§ç‰‡ç­‰ï¼‰
    if is_media:
        # æ£€æŸ¥æ˜¯å¦æ˜¯åª’ä½“ç»„ï¼ˆå¤šä¸ªæ–‡ä»¶ï¼‰
        is_media_group = hasattr(update.message, 'media_group_id') and update.message.media_group_id
        
        # æ˜¾ç¤ºå¤„ç†ä¸­çŠ¶æ€æ¶ˆæ¯
        processing_msg = None
        if is_media_group:
            processing_msg = await update.message.reply_text(
                "ğŸ“ æ­£åœ¨å¤„ç†å¤šä¸ªé™„ä»¶ï¼Œè¯·ç¨å€™...",
                disable_notification=True
            )
            context.user_data["reply_messages"].append(processing_msg.message_id)
        
        added_files = []
        
        # å¤„ç†æ–‡æ¡£
        if update.message.document:
            document = update.message.document
            file_name = document.file_name
            file_id = document.file_id
            mime_type = document.mime_type or "application/octet-stream"
            
            # ä¸‹è½½æ–‡ä»¶
            file = await context.bot.get_file(file_id)
            file_bytes = await file.download_as_bytearray()
            
            # å°†é™„ä»¶æ·»åŠ åˆ°åˆ—è¡¨
            attachment = {
                'filename': file_name,
                'content': file_bytes,
                'content_type': mime_type
            }
            
            context.user_data["reply_attachments"].append(attachment)
            added_files.append(file_name)
        
        # å¤„ç†ç…§ç‰‡
        elif update.message.photo:
            # è·å–æœ€å¤§å°ºå¯¸çš„ç…§ç‰‡
            photo = update.message.photo[-1]
            file_id = photo.file_id
            
            # ç”Ÿæˆæ–‡ä»¶å (ç…§ç‰‡æ²¡æœ‰åŸå§‹æ–‡ä»¶å)
            current_time = datetime.now().strftime("%Y%m%d_%H%M%S")
            file_name = f"photo_{current_time}.jpg"
            
            # ä¸‹è½½æ–‡ä»¶
            file = await context.bot.get_file(file_id)
            file_bytes = await file.download_as_bytearray()
            
            # å°†é™„ä»¶æ·»åŠ åˆ°åˆ—è¡¨
            attachment = {
                'filename': file_name,
                'content': file_bytes,
                'content_type': 'image/jpeg'
            }
            
            context.user_data["reply_attachments"].append(attachment)
            added_files.append(file_name)
        
        # å¦‚æœæ˜¯åª’ä½“ç»„ï¼Œéœ€è¦å¤„ç†åª’ä½“ç»„å®Œæˆçš„æƒ…å†µ
        if is_media_group:
            # TODO: å®ç°ç±»ä¼¼äºcomposeçš„åª’ä½“ç»„å¤„ç†é€»è¾‘
            # è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œç›´æ¥æ˜¾ç¤ºæ·»åŠ çš„æ–‡ä»¶
            # åœ¨å®é™…å®ç°ä¸­åº”è¯¥ä¸composeå‘½ä»¤ä¸­çš„åª’ä½“ç»„å¤„ç†ä¿æŒä¸€è‡´
            
            if processing_msg:
                try:
                    await context.bot.delete_message(chat_id=chat_id, message_id=processing_msg.message_id)
                    # ä»è®°å½•åˆ—è¡¨ä¸­ç§»é™¤ï¼Œé¿å…åç»­é‡å¤åˆ é™¤
                    if processing_msg.message_id in context.user_data["reply_messages"]:
                        context.user_data["reply_messages"].remove(processing_msg.message_id)
                except Exception as e:
                    logger.error(f"åˆ é™¤å¤„ç†çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")
        
        # æ˜¾ç¤ºå½“å‰é™„ä»¶åˆ—è¡¨
        attachment_names = [att['filename'] for att in context.user_data["reply_attachments"]]
        attachment_list = "\n".join([f"- {name}" for name in attachment_names])
        
        # åˆ›å»ºé”®ç›˜æä¾›ç»§ç»­é€‰é¡¹
        keyboard = [
            ["âœ… å‘é€é‚®ä»¶"],
            ["ğŸ“ æ·»åŠ æ›´å¤šé™„ä»¶"],
            ["âŒ å–æ¶ˆ"]
        ]
        reply_markup = ReplyKeyboardMarkup(
            keyboard, 
            one_time_keyboard=True,
            resize_keyboard=True
        )
        
        # æ˜¾ç¤ºæ¶ˆæ¯
        if len(added_files) == 1:
            message_text = f"""âœ… å·²æ·»åŠ é™„ä»¶ï¼š{added_files[0]}

å½“å‰é™„ä»¶åˆ—è¡¨({len(attachment_names)}ä¸ª)ï¼š
{attachment_list}

æ‚¨å¯ä»¥ï¼š
ğŸ“ ç»§ç»­æ·»åŠ æ›´å¤šé™„ä»¶
âœ… å‘é€å¸¦æœ‰å½“å‰é™„ä»¶çš„é‚®ä»¶
âŒ å–æ¶ˆå‘é€"""
        else:
            message_text = f"""âœ… å·²æ·»åŠ æ–°é™„ä»¶

å½“å‰é™„ä»¶åˆ—è¡¨({len(attachment_names)}ä¸ª)ï¼š
{attachment_list}

æ‚¨å¯ä»¥ï¼š
ğŸ“ ç»§ç»­æ·»åŠ æ›´å¤šé™„ä»¶
âœ… å‘é€å¸¦æœ‰å½“å‰é™„ä»¶çš„é‚®ä»¶
âŒ å–æ¶ˆå‘é€"""
        
        message = await update.message.reply_text(
            message_text,
            reply_markup=reply_markup,
            disable_notification=True
        )
        context.user_data["reply_messages"].append(message.message_id)
        
    return REPLY_ADD_ATTACHMENTS

async def send_reply_email(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """å‘é€å›å¤é‚®ä»¶"""
    # è·å–èŠå¤©ID
    chat_id = update.effective_chat.id
    
    # è·å–æ‰€æœ‰å¿…è¦æ•°æ®
    email_id = context.user_data.get("reply_email_id")
    account_id = context.user_data.get("reply_account_id")
    subject = context.user_data.get("reply_subject", "")
    recipients = context.user_data.get("reply_recipients", [])
    cc = context.user_data.get("reply_cc", [])
    bcc = context.user_data.get("reply_bcc", [])
    body = context.user_data.get("reply_body", "")
    attachments = context.user_data.get("reply_attachments", [])
    
    # æ£€æŸ¥æœ‰æ²¡æœ‰æ”¶ä»¶äºº
    if not recipients:
        message = await update.message.reply_text(
            "âš ï¸ è¯·è‡³å°‘æ·»åŠ ä¸€ä¸ªæ”¶ä»¶äºº",
            reply_markup=ReplyKeyboardMarkup(
                [["ğŸ‘¥ ç®¡ç†æ”¶ä»¶äººåˆ—è¡¨"], ["âŒ å–æ¶ˆ"]],
                resize_keyboard=True,
                one_time_keyboard=True
            ),
            disable_notification=True
        )
        context.user_data["reply_messages"].append(message.message_id)
        return REPLY_ENTER_RECIPIENTS
    
    # è·å–å›å¤çš„åŸå§‹é‚®ä»¶ï¼Œæ·»åŠ å¼•ç”¨
    original_email = get_email_by_id(email_id)
    # æ£€æŸ¥è´¦æˆ·
    account = get_email_account_by_id(account_id)
    if not account:
        message = await update.message.reply_text(
            "âš ï¸ é‚®ç®±è´¦æˆ·ä¸å­˜åœ¨ï¼Œæ— æ³•å‘é€",
            reply_markup=ReplyKeyboardRemove(),
            disable_notification=True
        )
        context.user_data["reply_messages"].append(message.message_id)
        return ConversationHandler.END
    
    # æ˜¾ç¤ºæ­£åœ¨å‘é€çš„æ¶ˆæ¯ï¼Œå¹¶åœ¨ç•Œé¢ä¸Šæ˜¾ç¤ºæ‰€æœ‰æ”¶ä»¶äºº
    # ä½¿ç”¨html.escapeå¤„ç†æ‰€æœ‰æ˜¾ç¤ºçš„æ”¶ä»¶äººã€æŠ„é€ã€å¯†é€åˆ—è¡¨
    escaped_recipients = [html.escape(r) for r in recipients]
    escaped_cc = [html.escape(c) for c in cc] if cc else []
    escaped_bcc = [html.escape(b) for b in bcc] if bcc else []
    
    recipients_display = ", ".join(escaped_recipients)
    cc_display = ", ".join(escaped_cc) if escaped_cc else "æ— "
    bcc_display = ", ".join(escaped_bcc) if escaped_bcc else "æ— "
    
    send_message = await update.message.reply_text(
        f"ğŸ•’ <b>æ­£åœ¨å‘é€å›å¤é‚®ä»¶...</b>\n\n"
        f"<b>ä»:</b> {html.escape(account.email)}\n"
        f"<b>ä¸»é¢˜:</b> {html.escape(subject)}\n"
        f"<b>æ”¶ä»¶äºº:</b> {recipients_display}\n"
        f"<b>æŠ„é€:</b> {cc_display}\n"
        f"<b>å¯†é€:</b> {bcc_display}\n"
        f"<b>é™„ä»¶:</b> {len(attachments)} ä¸ª\n\n"
        f"è¯·ç¨å€™...",
        parse_mode="HTML",
        reply_markup=ReplyKeyboardRemove(),
        disable_notification=True
    )
    context.user_data["reply_messages"].append(send_message.message_id)
    
    try:
        # åˆ›å»ºSMTPå®¢æˆ·ç«¯
        smtp_client = SMTPClient(
            server=account.smtp_server,
            port=account.smtp_port,
            username=account.username,
            password=account.password
        )
        
        # æ„å»ºå›å¤å¼•ç”¨
        quoted_body = f"\n\n-------- åŸå§‹é‚®ä»¶ --------\nå‘ä»¶äºº: {original_email.sender}\næ—¥æœŸ: {original_email.date}\nä¸»é¢˜: {original_email.subject}\n\n{original_email.text_content or original_email.html_content or '(é‚®ä»¶å†…å®¹ä¸ºç©ºæˆ–ä¸æ”¯æŒçš„æ ¼å¼)'}"
        
        # å®Œæ•´å›å¤å†…å®¹
        full_reply = f"{body}{quoted_body}"
        
        # åˆ›å»ºHTMLç‰ˆæœ¬çš„å›å¤å†…å®¹
        # å°†çº¯æ–‡æœ¬å›å¤å†…å®¹è½¬æ¢ä¸ºHTMLï¼ˆå¤„ç†æ¢è¡Œç¬¦å¹¶è½¬ä¹‰HTMLæ ‡ç­¾ï¼‰
        html_body_content = html.escape(body).replace('\n', '<br>')
        
        # åˆ›å»ºHTMLç‰ˆæœ¬çš„å¼•ç”¨å†…å®¹
        html_quoted_content = ""
        if original_email.html_content:
            # å¦‚æœåŸé‚®ä»¶æœ‰HTMLå†…å®¹ï¼Œä½¿ç”¨åŸå§‹HTMLä½œä¸ºå¼•ç”¨
            html_quoted_content = f"""
            <div style="margin-top:20px; border-top:1px solid #ddd; padding-top:10px;">
                <p style="color:#777;"><b>-------- åŸå§‹é‚®ä»¶ --------</b></p>
                <p><b>å‘ä»¶äºº:</b> {html.escape(original_email.sender)}</p>
                <p><b>æ—¥æœŸ:</b> {original_email.date}</p>
                <p><b>ä¸»é¢˜:</b> {html.escape(original_email.subject)}</p>
                <div style="margin-top:10px;">{original_email.html_content}</div>
            </div>
            """
        else:
            # å¦‚æœåŸé‚®ä»¶åªæœ‰æ–‡æœ¬å†…å®¹ï¼Œå°†å…¶è½¬æ¢ä¸ºHTML
            original_content = original_email.text_content or '(é‚®ä»¶å†…å®¹ä¸ºç©ºæˆ–ä¸æ”¯æŒçš„æ ¼å¼)'
            html_original_content = html.escape(original_content).replace('\n', '<br>')
            html_quoted_content = f"""
            <div style="margin-top:20px; border-top:1px solid #ddd; padding-top:10px;">
                <p style="color:#777;"><b>-------- åŸå§‹é‚®ä»¶ --------</b></p>
                <p><b>å‘ä»¶äºº:</b> {html.escape(original_email.sender)}</p>
                <p><b>æ—¥æœŸ:</b> {original_email.date}</p>
                <p><b>ä¸»é¢˜:</b> {html.escape(original_email.subject)}</p>
                <div style="margin-top:10px; font-family:monospace;">{html_original_content}</div>
            </div>
            """
        
        # å®Œæ•´HTMLå›å¤å†…å®¹
        full_html_reply = f"""
        <div style="font-family:Arial, sans-serif; line-height:1.6;">
            <div>{html_body_content}</div>
            {html_quoted_content}
        </div>
        """
        
        # å‘é€é‚®ä»¶
        from_addr = account.email
        
        # å‡†å¤‡é™„ä»¶æ ¼å¼
        formatted_attachments = None
        if attachments:
            formatted_attachments = attachments
        
        # ä½¿ç”¨SMTPå®¢æˆ·ç«¯å‘é€é‚®ä»¶
        success = await smtp_client.send_email(
            from_addr=from_addr,
            to_addrs=recipients,
            subject=subject,
            text_body=full_reply,
            html_body=full_html_reply,  # æ·»åŠ HTMLå†…å®¹
            cc_addrs=cc,
            bcc_addrs=bcc,
            reply_to=account.email,
            attachments=formatted_attachments
        )
        
        if success:
            # è®°å½•å›å¤ä¿¡æ¯åˆ°æ•°æ®åº“
            reply_id = add_reply_to_email(
                email_id=email_id,
                reply_text=body,
                reply_date=datetime.now(),
                sender=account.email
            )
            
            # å‘é€æˆåŠŸæ¶ˆæ¯
            recipients_str = ", ".join(recipients)
            success_message = await update.message.reply_text(
                f"âœ… å›å¤é‚®ä»¶å·²æˆåŠŸå‘é€è‡³ {recipients_str}",
                reply_markup=ReplyKeyboardRemove(),
                disable_notification=True
            )
            context.user_data["reply_messages"].append(success_message.message_id)
            
            # å°è¯•ä»IMAPè·å–æœ€æ–°å‘é€çš„é‚®ä»¶å¹¶å‘é€åˆ°Telegram
            try:
                from app.email.imap_client import IMAPClient
                from app.bot.notifications import send_sent_email_notification
                from app.database.operations import save_email_metadata
                
                # åˆ›å»ºIMAPå®¢æˆ·ç«¯
                imap_client = IMAPClient(account=account)
                
                # è·å–æœ€æ–°å‘é€çš„é‚®ä»¶
                latest_sent_email = await imap_client.get_latest_sent_email()
                
                # æ–­å¼€IMAPè¿æ¥
                imap_client.disconnect()
                
                if latest_sent_email:
                    # æ£€æŸ¥æ”¶ä»¶äººæ˜¯å¦åŒ¹é…ï¼Œç¡®ä¿è·å–çš„æ˜¯åˆšåˆšå‘é€çš„é‚®ä»¶
                    sent_recipients = set(r.lower().strip() for r in latest_sent_email.get('recipients', []))
                    current_recipients = set(r.lower().strip() for r in recipients)
                    
                    if sent_recipients and current_recipients and sent_recipients.intersection(current_recipients):
                        logger.info(f"æ‰¾åˆ°åŒ¹é…çš„å·²å‘é€å›å¤é‚®ä»¶ï¼Œå°†å‘é€åˆ° Telegram")
                        
                        # è·å–åŸå§‹é‚®ä»¶çš„Telegramæ¶ˆæ¯IDä½œä¸ºå›å¤çš„ç›®æ ‡
                        telegram_message_id = None
                        if original_email and hasattr(original_email, 'telegram_message_id') and original_email.telegram_message_id:
                            telegram_message_id = original_email.telegram_message_id
                            logger.info(f"æ‰¾åˆ°åŸå§‹é‚®ä»¶çš„Telegramæ¶ˆæ¯ID: {telegram_message_id}")
                        
                        # ä¿å­˜é‚®ä»¶å…ƒæ•°æ®åˆ°æ•°æ®åº“
                        email_id = save_email_metadata(account.id, latest_sent_email)
                        if email_id:
                            # å‘é€æ— å£°é€šçŸ¥åˆ°Telegram
                            await send_sent_email_notification(
                                context, 
                                account.id, 
                                latest_sent_email, 
                                email_id,
                                telegram_message_id
                            )
                            logger.info(f"å·²å›å¤é‚®ä»¶é€šçŸ¥å·²å‘é€åˆ°Telegramï¼ŒID: {email_id}")
                        else:
                            logger.error("ä¿å­˜å·²å‘é€å›å¤é‚®ä»¶å…ƒæ•°æ®å¤±è´¥")
                    else:
                        logger.warning(f"æœ€æ–°å·²å‘é€é‚®ä»¶çš„æ”¶ä»¶äººä¸å½“å‰å‘é€ä¸åŒ¹é…ï¼Œè·³è¿‡é€šçŸ¥")
                else:
                    logger.warning("æœªæ‰¾åˆ°æœ€æ–°å‘é€çš„å›å¤é‚®ä»¶ï¼Œæ— æ³•å‘é€é€šçŸ¥")
            except Exception as e:
                logger.error(f"è·å–å’Œå‘é€å·²å›å¤é‚®ä»¶é€šçŸ¥æ—¶å‡ºé”™: {e}")
                logger.error(traceback.format_exc())
        else:
            # å‘é€å¤±è´¥æ¶ˆæ¯
            await send_message.edit_text(
                f"âš ï¸ å‘é€å¤±è´¥ï¼šSMTPæœåŠ¡å™¨è¿æ¥æˆ–å‘é€å‡ºé”™",
                reply_markup=ReplyKeyboardMarkup(
                    [["ğŸ”„ é‡è¯•", "âŒ å–æ¶ˆ"]],
                    resize_keyboard=True
                )
            )
            return REPLY_ADD_ATTACHMENTS
    
    except Exception as e:
        logger.error(f"å›å¤é‚®ä»¶æ—¶å‡ºé”™: {str(e)}")
        logger.error(traceback.format_exc())
        
        # å‘é€å¤±è´¥æ¶ˆæ¯
        await send_message.edit_text(
            f"âš ï¸ å‘é€å¤±è´¥ï¼š{str(e)}",
            reply_markup=ReplyKeyboardMarkup(
                [["ğŸ”„ é‡è¯•", "âŒ å–æ¶ˆ"]],
                resize_keyboard=True
            )
        )
        return REPLY_ADD_ATTACHMENTS
    finally:
        # è®¾ç½®å»¶è¿Ÿæ¸…ç†ä»»åŠ¡ï¼ˆ3ç§’åï¼‰
        asyncio.create_task(
            delayed_clean_reply_messages(context, chat_id, 3)
        )
    
    # æ¸…ç†ä¼šè¯æ•°æ®
    cleanup_reply_data(context)
    
    return ConversationHandler.END

async def cancel_reply(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """å–æ¶ˆå›å¤é‚®ä»¶"""
    chat_id = update.effective_chat.id
    
    # è®°å½•å½“å‰æ¶ˆæ¯ä»¥ä¾¿åç»­æ¸…ç†
    if "reply_messages" in context.user_data:
        context.user_data["reply_messages"].append(update.message.message_id)
    
    # å‘é€å–æ¶ˆç¡®è®¤æ¶ˆæ¯
    cancel_msg = await update.message.reply_text(
        "âŒ å·²å–æ¶ˆå›å¤é‚®ä»¶ã€‚",
        reply_markup=ReplyKeyboardRemove(),
        disable_notification=True
    )
    
    if "reply_messages" in context.user_data:
        context.user_data["reply_messages"].append(cancel_msg.message_id)
    
    # è®¾ç½®å»¶è¿Ÿæ¸…ç†ä»»åŠ¡ï¼ˆ3ç§’åï¼‰
    asyncio.create_task(
        delayed_clean_reply_messages(context, chat_id, 3)
    )
    
    # æ¸…ç†ä¼šè¯æ•°æ®
    cleanup_reply_data(context)
    
    return ConversationHandler.END

def cleanup_reply_data(context):
    """æ¸…ç†å›å¤é‚®ä»¶çš„ä¼šè¯æ•°æ®"""
    # æ¸…ç†ä¼šè¯æ•°æ®ï¼ˆä½†ä¿ç•™æ¶ˆæ¯IDåˆ—è¡¨ï¼Œå»¶è¿Ÿæ¸…ç†åä¼šåˆ é™¤ï¼‰
    keys_to_remove = [
        "reply_email_id", "reply_account_id", "reply_account_email",
        "reply_subject", "reply_recipients", "reply_cc", "reply_bcc",
        "reply_body", "reply_attachments", "reply_recipients_state", "reply_candidates",
        "reply_default_recipient", "reply_original_message_id"
    ]
    
    for key in keys_to_remove:
        if key in context.user_data:
            del context.user_data[key]

async def clean_reply_messages(context, chat_id):
    """æ¸…ç†å›å¤é‚®ä»¶ä¼šè¯ä¸­çš„å†å²æ¶ˆæ¯"""
    if "reply_messages" in context.user_data and context.user_data["reply_messages"]:
        try:
            # ä½¿ç”¨delete_messagesæ‰¹é‡åˆ é™¤æ¶ˆæ¯
            await context.bot.delete_messages(
                chat_id=chat_id,
                message_ids=context.user_data["reply_messages"]
            )
        except Exception as e:
            # å¦‚æœæ‰¹é‡åˆ é™¤å¤±è´¥ï¼Œå›é€€åˆ°é€ä¸ªåˆ é™¤
            logger.error(f"æ‰¹é‡åˆ é™¤æ¶ˆæ¯å¤±è´¥: {e}ï¼Œå°è¯•é€ä¸ªåˆ é™¤")
            for msg_id in context.user_data["reply_messages"]:
                try:
                    await context.bot.delete_message(chat_id=chat_id, message_id=msg_id)
                except Exception as inner_e:
                    # å¿½ç•¥æ— æ³•åˆ é™¤çš„æ¶ˆæ¯é”™è¯¯
                    logger.debug(f"æ— æ³•åˆ é™¤æ¶ˆæ¯ {msg_id}: {inner_e}")
        
        # æ¸…ç©ºæ¶ˆæ¯IDåˆ—è¡¨
        context.user_data["reply_messages"] = []

async def delayed_clean_reply_messages(context, chat_id, delay_seconds):
    """å»¶è¿Ÿæ¸…ç†å›å¤é‚®ä»¶ä¼šè¯ä¸­çš„å†å²æ¶ˆæ¯"""
    await asyncio.sleep(delay_seconds)
    await clean_reply_messages(context, chat_id)

async def delayed_delete_message(context, chat_id, message_id, delay_seconds):
    """å»¶è¿Ÿåˆ é™¤å•ä¸ªæ¶ˆæ¯"""
    await asyncio.sleep(delay_seconds)
    try:
        await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
    except Exception as e:
        logger.debug(f"æ— æ³•åˆ é™¤æ¶ˆæ¯ {message_id}: {e}")

def handle_reply_conversation():
    """åˆ›å»ºå’Œé…ç½®å›å¤é‚®ä»¶ä¼šè¯å¤„ç†å™¨"""
    return ConversationHandler(
        entry_points=[
            CallbackQueryHandler(
                lambda u, c: handle_reply_email(u, c, int(u.callback_query.data.split("_")[2])), 
                pattern="^reply_email_"
            ),
        ],
        states={
            REPLY_ENTER_RECIPIENTS: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_reply_recipients)],
            REPLY_ENTER_CC: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_reply_cc)],
            REPLY_ENTER_BCC: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_reply_bcc)],
            REPLY_ENTER_BODY: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_reply_body)],
            REPLY_ADD_ATTACHMENTS: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_reply_attachments),
                MessageHandler(filters.Document.ALL, handle_reply_attachments),
                MessageHandler(filters.PHOTO, handle_reply_attachments),
            ],
        },
        fallbacks=[CommandHandler("cancel", cancel_reply)],
        name="reply_conversation",
        persistent=False
    )